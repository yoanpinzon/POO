
---

# üíª 300CIS017 Programaci√≥n Orientada a Objetos 2025-01  <!-- omit in toc -->
![Version](https://img.shields.io/badge/version-1.2-blue)
[![License: CC BY-NC-ND 4.0](https://img.shields.io/badge/License-CC%20BY--NC--ND%204.0-lightgrey.svg?color=#007ec6)](https://creativecommons.org/licenses/by-nc-nd/4.0/)

---

# üåü Tema 2: El lenguaje C++ - Parte 1<!-- omit in toc -->

---

### üé• Videos que inspiraron este tema:

<table style="border-collapse: collapse; width: 100%; border: none; margin: 10px 0;">
  <tr>
    <td style="text-align: center; padding: 5px; border: none;">
      <a href="https://www.youtube.com/watch?v=Hh9yZWeTmVM">
        <img src="img/vid4.png" alt="The Beginning - OOR" width="150">
      </a>
      <br>
      <span style="font-size: 12px; margin-top: 5px; display: inline-block;">The Beginning<br>OOR</span>
    </td>
    <td style="text-align: center; padding: 5px; border: none;">
      <a href="https://www.youtube.com/watch?v=Ibp_y21LHJY">
        <img src="img/vid5.png" alt="Push Back - OOR" width="150">
      </a>
      <br>
      <span style="font-size: 12px; margin-top: 5px; display: inline-block;">Push Back<br>OOR</span>
    </td>
  </tr>
</table>

---

### üíª Creado por   

Profesorcito ¬© 2025

<!-- <svg version="1.1" width="16" height="16" viewBox="0 0 16 16" class="octicon octicon-trash" aria-label="The trash icon" role="img"><path d="M11 1.75V3h2.25a.75.75 0 0 1 0 1.5H2.75a.75.75 0 0 1 0-1.5H5V1.75C5 .784 5.784 0 6.75 0h2.5C10.216 0 11 .784 11 1.75ZM4.496 6.675l.66 6.6a.25.25 0 0 0 .249.225h5.19a.25.25 0 0 0 .249-.225l.66-6.6a.75.75 0 0 1 1.492.149l-.66 6.6A1.748 1.748 0 0 1 10.595 15h-5.19a1.75 1.75 0 0 1-1.741-1.575l-.66-6.6a.75.75 0 1 1 1.492-.15ZM6.5 1.75V3h3V1.75a.25.25 0 0 0-.25-.25h-2.5a.25.25 0 0 0-.25.25Z"></path></svg>

<svg version="1.1" width="16" height="16" viewBox="0 0 16 16" class="octicon octicon-pencil" aria-label="The pencil icon" role="img"><path d="M11.013 1.427a1.75 1.75 0 0 1 2.474 0l1.086 1.086a1.75 1.75 0 0 1 0 2.474l-8.61 8.61c-.21.21-.47.364-.756.445l-3.251.93a.75.75 0 0 1-.927-.928l.929-3.25c.081-.286.235-.547.445-.758l8.61-8.61Zm.176 4.823L9.75 4.81l-6.286 6.287a.253.253 0 0 0-.064.108l-.558 1.953 1.953-.558a.253.253 0 0 0 .108-.064Zm1.238-3.763a.25.25 0 0 0-.354 0L10.811 3.75l1.439 1.44 1.263-1.263a.25.25 0 0 0 0-.354Z"></path></svg>

<svg aria-hidden="true" focusable="false" class="mt-1" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;"><path d="M10.561 8.073a6.005 6.005 0 0 1 3.432 5.142.75.75 0 1 1-1.498.07 4.5 4.5 0 0 0-8.99 0 .75.75 0 0 1-1.498-.07 6.004 6.004 0 0 1 3.431-5.142 3.999 3.999 0 1 1 5.123 0ZM10.5 5a2.5 2.5 0 1 0-5 0 2.5 2.5 0 0 0 5 0Z"></path></svg>

<svg version="1.1" width="16" height="16" viewBox="0 0 16 16" class="octicon octicon-repo" aria-hidden="true"><path d="M2 2.5A2.5 2.5 0 0 1 4.5 0h8.75a.75.75 0 0 1 .75.75v12.5a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5h1.75v-2h-8a1 1 0 0 0-.714 1.7.75.75 0 1 1-1.072 1.05A2.495 2.495 0 0 1 2 11.5Zm10.5-1h-8a1 1 0 0 0-1 1v6.708A2.486 2.486 0 0 1 4.5 9h8ZM5 12.25a.25.25 0 0 1 .25-.25h3.5a.25.25 0 0 1 .25.25v3.25a.25.25 0 0 1-.4.2l-1.45-1.087a.249.249 0 0 0-.3 0L5.4 15.7a.25.25 0 0 1-.4-.2Z"></path></svg>

<svg version="1.1" width="16" height="16" viewBox="0 0 16 16" class="octicon octicon-trash" aria-label="The trash icon" role="img"><path d="M11 1.75V3h2.25a.75.75 0 0 1 0 1.5H2.75a.75.75 0 0 1 0-1.5H5V1.75C5 .784 5.784 0 6.75 0h2.5C10.216 0 11 .784 11 1.75ZM4.496 6.675l.66 6.6a.25.25 0 0 0 .249.225h5.19a.25.25 0 0 0 .249-.225l.66-6.6a.75.75 0 0 1 1.492.149l-.66 6.6A1.748 1.748 0 0 1 10.595 15h-5.19a1.75 1.75 0 0 1-1.741-1.575l-.66-6.6a.75.75 0 1 1 1.492-.15ZM6.5 1.75V3h3V1.75a.25.25 0 0 0-.25-.25h-2.5a.25.25 0 0 0-.25.25Z"></path></svg>

<svg aria-hidden="true" focusable="false" class="Octicon-sc-9kayk9-0 kfGkqo" viewBox="0 0 16 16" width="16" height="16" fill="currentColor" style="display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>
 -->
---

### üé∂ Dedicado a 

[Takahiro Moriuchi](https://es.wikipedia.org/wiki/Takahiro_Moriuchi) (Taka) üé§


--- 

En este cap√≠tulo, habiendo comprendido previamente el manejo de versiones con **Git** üßë‚Äçüíª, nos adentraremos en los fundamentos del lenguaje **C++** üíª. A lo largo de esta secci√≥n, aprenderemos a estructurar programas, manejar tipos de datos, usar operadores, implementar estructuras de control y ciclos para crear soluciones eficientes. Tambi√©n exploraremos temas m√°s avanzados como el manejo de memoria din√°mica, el uso de punteros y la creaci√≥n de funciones y estructuras. üöÄ

### **Tabla de Contenido**

- [1. **Introducci√≥n a C++**](#1-introducci√≥n-a-c)
- [2. **Estructura del Programa**](#2-estructura-del-programa)
  - [**Comentarios**](#comentarios)
  - [**Archivo de Encabezado**](#archivo-de-encabezado)
  - [**Directivas del Preprocesador**](#directivas-del-preprocesador)
  - [**Funci√≥n `main`**](#funci√≥n-main)
  - [**Llaves y Bloques**](#llaves-y-bloques)
  - [**Identificadores y Palabras Reservadas**](#identificadores-y-palabras-reservadas)
  - [**Ejemplo de Programa**](#ejemplo-de-programa)
- [3. **Buenas Pr√°cticas al Escribir C√≥digo**](#3-buenas-pr√°cticas-al-escribir-c√≥digo)
- [4. **Tipos de Datos**](#4-tipos-de-datos)
  - [**Enteros**](#enteros)
  - [**N√∫meros Reales**](#n√∫meros-reales)
  - [**Booleanos**](#booleanos)
  - [**Tipo `void`**](#tipo-void)
  - [**Cadenas de Texto**](#cadenas-de-texto)
  - [**Ejemplo de Programa con Tipos de Datos**](#ejemplo-de-programa-con-tipos-de-datos)
- [5. **Literales**](#5-literales)
  - [**Literales Enteros**](#literales-enteros)
  - [**Literales de Punto Flotante**](#literales-de-punto-flotante)
  - [**Literales de Caracter y Cadenas**](#literales-de-caracter-y-cadenas)
- [6. **Operadores**](#6-operadores)
  - [**Aritm√©ticos**](#aritm√©ticos)
  - [**Relacionales y L√≥gicos**](#relacionales-y-l√≥gicos)
  - [**Bitwise**](#bitwise)
  - [**De Asignaci√≥n**](#de-asignaci√≥n)
  - [**Unarios**](#unarios)
  - [**Orden de Precedencia**](#orden-de-precedencia)
- [7. **Conversi√≥n de Tipos de Datos**](#7-conversi√≥n-de-tipos-de-datos)
  - [**Conversi√≥n Impl√≠cita**](#conversi√≥n-impl√≠cita)
  - [**Conversi√≥n Expl√≠cita**](#conversi√≥n-expl√≠cita)
- [8. **Variables Constantes**](#8-variables-constantes)
- [9. **Estructuras de Control**](#9-estructuras-de-control)
  - [**Estructura de Selecci√≥n `if`**](#estructura-de-selecci√≥n-if)
  - [**Estructura de Selecci√≥n `if-else`**](#estructura-de-selecci√≥n-if-else)
  - [**Estructura `switch`**](#estructura-switch)
- [**üëΩ Tarea - Estacionamiento Intergal√°ctico**](#-tarea---estacionamiento-intergal√°ctico)

---

# 1. **Introducci√≥n a C++**

C++ fue creado por *Bjarne Stroustrup*, un ingeniero dan√©s, en AT&T Bell Laboratories a principios de los a√±os 80 como una extensi√≥n del lenguaje C. Su objetivo era a√±adir nuevas capacidades, como la programaci√≥n orientada a objetos, mientras manten√≠a la velocidad y eficiencia de C.  

>[!NOTE]
>    
> Los Laboratorios Bell (1925-1996) revolucionaron la tecnolog√≠a con el transistor, el l√°ser, Unix y C++, transformando la computaci√≥n y la programaci√≥n.
>

<details><summary>üí° Hint: Bjarne Stroustrup</summary>

<p align="center">
  <img src="img/stroustrup.png" height="">
</p>
</details>

---

# 2. **Estructura del Programa**

En C++, el c√≥digo se organiza para asegurar claridad y ejecuci√≥n correcta: *directivas del preprocesador* como #include <iostream>, seguidas de las definiciones de funciones (en caso de que existan) y, finalmente, la funci√≥n principal `main()`. El siguiente diagrama ilustra la estructura b√°sica de un programa en C++:

```cpp
#include <iostream>
// otras directivas del preprocesador

definici√≥n-de-funci√≥n 1;
definici√≥n-de-funci√≥n 2;
...

int main() {
    declaraci√≥n 1;
    declaraci√≥n 2;
    ...
    instrucci√≥n-de-ejecuci√≥n 1;
    instrucci√≥n-de-ejecuci√≥n 2;
    ...
    return 0;
}
```

Como puedes observar, `main()` re√∫ne todas las declaraciones (variables u objetos que usar√°s) y las sentencias de ejecuci√≥n (las acciones concretas que realizar√° tu programa).

---

## **Comentarios**

Para facilitar la lectura del c√≥digo y explicar su funcionamiento, se utilizan comentarios. En C++, existen dos tipos principales:

- **Comentarios de una sola l√≠nea**, utilizando `//`.
- **Comentarios de m√∫ltiples l√≠neas**, utilizando `/* ... */`. Este estilo fue heredado del lenguaje C.

Estos comentarios no afectan la ejecuci√≥n del programa, pero son muy √∫tiles para documentar o aclarar partes de tu c√≥digo.

> [!WARNING]
> Si colocas un comentario dentro de otro utilizando `/* ... */`, el compilador generar√° un error. Esto ocurre porque los **comentarios anidados** no son compatibles con los comentarios de m√∫ltiples l√≠neas. Utiliza `//` para evitar problemas. üòä

---

## **Archivo de Encabezado**

En C++, los **archivos de cabecera** contienen definiciones y declaraciones necesarias para utilizar funcionalidades predefinidas del lenguaje, como entrada/salida, operaciones matem√°ticas o manipulaci√≥n de texto. Se incluyen en el programa utilizando la [directiva del preprocesador](#directivas-del-preprocesador) `#include`. Por ejemplo:

### üíª `#include <iostream>` <!-- omit in toc -->

Proporciona funcionalidades b√°sicas de entrada y salida, como:
  - `std::cout` para imprimir en pantalla.  
  - `std::cin` para recibir datos del usuario.  

<details>
<summary>Ejemplo de uso</summary>

**C√≥digo en C++:**
```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Introduce un n√∫mero: ";
    int num;
    cin >> num;
    cout << "Has introducido: " << num << endl;
    return 0;
}
```

**Posible salida en consola:**
```
Introduce un n√∫mero: 5
Has introducido: 5
```
</details>

---

### üßÆ `#include <cmath>` <!-- omit in toc -->

Proporciona funciones matem√°ticas avanzadas, como:
  - `sqrt()` para calcular ra√≠ces cuadradas.  
  - `pow()` para calcular potencias.  
  - `sin()`, `cos()`, y `tan()` para operaciones trigonom√©tricas.  

<details>
<summary>Ejemplo de uso</summary>

**C√≥digo en C++:**
```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    double base = 2.0, exponente = 3.0;
    cout << "2^3 = " << pow(base, exponente) << endl;
    cout << "Ra√≠z cuadrada de 25: " << sqrt(25) << endl;
    cout << "Seno de 90 grados: " << sin(90 * M_PI / 180) << endl;
    return 0;
}
```

**Posible salida en consola:**
```
2^3 = 8
Ra√≠z cuadrada de 25: 5
Seno de 90 grados: 1
```
</details>

---

### üìù `#include <string>` <!-- omit in toc -->

Permite trabajar con cadenas de texto de manera sencilla:
  - Concatenar con el operador `+`.  
  - Comparar cadenas con `==`.  
  - Obtener el tama√±o de una cadena usando `.size()` o `.length()`.  

<details>
<summary>Ejemplo de uso</summary>

**C√≥digo en C++:**
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string nombre = "Juan";
    string saludo = "Hola, " + nombre + "!";
    cout << saludo << endl;
    cout << "El saludo tiene " << saludo.length() << " caracteres." << endl;
    return 0;
}
```

**Posible salida en consola:**
```
Hola, Juan!
El saludo tiene 11 caracteres.
```
</details>

---

### üöÄ `#include <vector>` <!-- omit in toc -->

Permite manejar arreglos din√°micos de manera eficiente:
  - Los `vector` pueden crecer y encogerse seg√∫n sea necesario.  
  - Permiten agregar y eliminar elementos f√°cilmente.  
  - Se pueden recorrer con bucles `for` de manera sencilla.  

<details>
<summary>Ejemplo de uso</summary>

**C√≥digo en C++:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> numeros = {1, 2, 3, 4, 5};
    numeros.push_back(6); // Agregar un n√∫mero al final

    cout << "Elementos del vector: ";
    for (int num : numeros) {
        cout << num << " ";
    }
    cout << endl;

    cout << "El tama√±o del vector es: " << numeros.size() << endl;
    return 0;
}
```

**Posible salida en consola:**
```
Elementos del vector: 1 2 3 4 5 6
El tama√±o del vector es: 6
```
</details>

---

A lo largo del curso, se utilizar√°n otros encabezados seg√∫n las necesidades espec√≠ficas de cada programa, e incluso aprenderemos a crear nuestros propios archivos de cabecera.

> [!NOTE]
> 
> Se llaman **archivos de cabecera** porque se colocan en la **parte superior** del programa, de manera similar a c√≥mo la cabeza est√° en la parte superior del cuerpo humano.

---

## **Directivas del Preprocesador**

Una **directiva del preprocesador** en C++ es una instrucci√≥n que se procesa antes de la compilaci√≥n. Comienzan con `#` y permiten incluir archivos externos, como los [archivos de encabezado](#archivo-de-encabezado) explicados anteriormente, definir macros, y controlar bloques condicionales, preparando el c√≥digo para su compilaci√≥n.

Ejemplos comunes de directivas:

- `#include`  

   Trae archivos de cabecera al programa, asegurando que ciertas herramientas est√©n disponibles.  
   ```cpp
   #include <iostream> // Entrada y salida est√°ndar
   #include <cmath>    // Funciones matem√°ticas
   ```

- `#define`  

   Define macros o constantes reutilizables.  
   ```cpp
   #define PI 3.14159
   #define AREA(r) (PI * (r) * (r)) // Calcula √°reas de un c√≠rculo
   ```

- `#ifdef` y `#ifndef`  

   Permiten incluir o excluir partes del c√≥digo seg√∫n condiciones.  
   ```cpp
   #define DEBUG // Activa modo depuraci√≥n

   #ifdef DEBUG
   std::cout << "Modo depuraci√≥n activado!" << std::endl;
   #endif
   ```

El preprocesador trabaja **antes de compilar**, procesando estas directivas para preparar el programa y asegurarse de que el compilador tenga todo lo necesario para crear el ejecutable.

---

## **Funci√≥n `main`**  

En C++, la funci√≥n principal, llamada **`main()`** (del ingl√©s 'principal'), es el punto de entrada del programa. Su declaraci√≥n est√°ndar es `int main()`, y puede devolver un valor entero (‚úÖ `0` para √©xito, ‚ùå otro valor para indicar error) al sistema operativo.  

Tambi√©n acepta argumentos desde la l√≠nea de comandos:  
- **`argc`** (argument count) ‚Üí Indica el n√∫mero total de argumentos, incluyendo el nombre del programa.  
- **`argv`** (argument vector) ‚Üí Es un array de `char*` que almacena los argumentos como cadenas de caracteres.  

<details>
<summary>üîç Ejemplo avanzado de uso de `argc` y `argv`</summary>

### **üìå C√≥digo en C++:** <!-- omit in toc -->
```cpp
#include <iostream>
using namespace std;

int main(int argc, char* argv[]) {
    if (argc < 3) { // Se esperan al menos 2 argumentos adicionales
        cerr << "Error: Debes proporcionar al menos dos argumentos.\n";
        cerr << "Uso: ./programa <nombre> <edad> <ciudad> <pa√≠s>\n";
        return 1; // C√≥digo de error
    }

    cout << "Nombre del programa: " << argv[0] << endl;
    cout << "Argumentos recibidos:\n";
    
    cout << "  Nombre: " << argv[1] << endl;
    cout << "  Edad: " << argv[2] << " a√±os" << endl;
    
    if (argc >= 4) cout << "  Ciudad: " << argv[3] << endl;
    if (argc >= 5) cout << "  Pa√≠s: " << argv[4] << endl;

    cout << "Ejecuci√≥n finalizada correctamente.\n";
    return 0; // √âxito
}
```

---

### **üñ•Ô∏è Uso y salida en consola con diferentes argumentos:** <!-- omit in toc -->
‚úÖ **Ejecutando el programa con 4 argumentos:**  
```
$ ./programa Juan 25 Bogot√° Colombia
Nombre del programa: ./programa
Argumentos recibidos:
  Nombre: Juan
  Edad: 25 a√±os
  Ciudad: Bogot√°
  Pa√≠s: Colombia
Ejecuci√≥n finalizada correctamente.
```

‚úÖ **Ejecutando el programa con menos argumentos:**  
```
$ ./programa Ana 30
Nombre del programa: ./programa
Argumentos recibidos:
  Nombre: Ana
  Edad: 30 a√±os
Ejecuci√≥n finalizada correctamente.
```

‚ùå **Ejecutando sin suficientes argumentos:**  
```
$ ./programa
Error: Debes proporcionar al menos dos argumentos.
Uso: ./programa <nombre> <edad> <ciudad> <pa√≠s>
```

---

### **‚ö° `return 0` y `ERRORLEVEL` en el sistema operativo**  <!-- omit in toc -->
üîπ `return 0;` indica que el programa termin√≥ **sin errores**.  
üîπ `return 1;` o cualquier otro valor representa un **c√≥digo de error**.  
üîπ En **Windows**, puedes verificarlo con `echo %ERRORLEVEL%`.  
üîπ En **Linux/macOS**, puedes usar `$?` en la terminal.

**Ejemplo en `cmd.exe` (Windows):**
```
C:\> programa.exe
Error: Debes proporcionar al menos dos argumentos.
Uso: programa.exe <nombre> <edad> <ciudad> <pa√≠s>

C:\> echo %ERRORLEVEL%
1
```

```
C:\> programa.exe Pedro 28 Madrid Espa√±a
Nombre del programa: programa.exe
Argumentos recibidos:
  Nombre: Pedro
  Edad: 28 a√±os
  Ciudad: Madrid
  Pa√≠s: Espa√±a
Ejecuci√≥n finalizada correctamente.

C:\> echo %ERRORLEVEL%
0
```

**Ejemplo en terminal (Linux/macOS):**
```
$ ./programa
Error: Debes proporcionar al menos dos argumentos.
Uso: ./programa <nombre> <edad> <ciudad> <pa√≠s>
$ echo $?
1
```

```
$ ./programa Mar√≠a 22 Lima Per√∫
Nombre del programa: ./programa
Argumentos recibidos:
  Nombre: Mar√≠a
  Edad: 22 a√±os
  Ciudad: Lima
  Pa√≠s: Per√∫
Ejecuci√≥n finalizada correctamente.
$ echo $?
0
```

</details>

>[!NOTE]
>
> En C++, debe existir **solo una funci√≥n `main()`** en cada programa, ya que define el √∫nico punto de entrada donde comienza la ejecuci√≥n. Si existieran varias funciones `main()`, el compilador no sabr√≠a cu√°l usar como punto de inicio, lo que generar√≠a un error.  

---

## **Llaves y Bloques**

En C++, las **llaves** (`{` y `}`) se utilizan para definir un **bloque* de c√≥digo, que agrupa instrucciones y determina el *alcance* o *√°mbito* (*scope* en ingl√©s) de las variables y funciones. Esto significa que los elementos declarados dentro del bloque solo son accesibles ah√≠, organizando el flujo del programa y delimitando estructuras como funciones, bucles y condiciones.

Todo lo contenido entre un par de llaves pertenece al mismo *bloque* y se ejecuta seg√∫n el contexto. Por ejemplo, en una funci√≥n, las llaves delimitan su cuerpo, mientras que en estructuras de control como `if` o `while`, especifican qu√© instrucciones se ejecutan dependiendo de la condici√≥n.  

El uso correcto de las llaves asegura un c√≥digo claro, organizado y con un manejo adecuado del alcance o √°mbito.  

---

## **Identificadores y Palabras Reservadas**

En C++, los identificadores son nombres definidos por el programador para variables, funciones, clases y otros elementos del c√≥digo. Las **palabras reservadas**, en cambio, son t√©rminos con significado especial en el lenguaje y no pueden ser usadas como identificadores.

Las palabras reservadas en C++ son:

```cpp
alignas   continue   friend     operator  this  
alignof   decltype   goto       private   throw  
asm       default    if         protected true  
auto      delete     inline     public    try  
bool      do         int        register  typedef  
break     double     long       reinterpret_cast  
typeid    case       dynamic_cast mutable  typename 
catch     else       namespace  return    union  
char      enum       new        short     unsigned  
class     explicit   noexcept   signed    using  
const     export     nullptr    sizeof    virtual  
constexpr extern     operator   static    void  
const_cast false     private    static_cast  
volatile  template   wchar_t    while
```

> [!CAUTION]
> 
> Si intentas usar una palabra reservada como identificador (por ejemplo, llamando a una variable `int`), el compilador generar√° un error, ya que estas palabras tienen un prop√≥sito espec√≠fico en el lenguaje.

---

## **Ejemplo de Programa**

Aqu√≠ tienes un ejemplo de un programa completo en C++:

```cpp
// Proyecto: PrimerPrograma
// Archivo: main.cpp
// Este programa solicita al usuario dos n√∫meros enteros.
// Luego calcula y muestra su suma
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iostream>

int main() {
    int valor1, valor2; // Manteniendo el tipo int
    std::cout << "Introduce dos valores enteros: " << std::endl;
    std::cin >> valor1 >> valor2;
    std::cout << "La suma de " << valor1 << " y " << valor2 << " es " << (valor1 + valor2) << std::endl;
    return 0;
}
```

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Crear un nuevo proyecto en CLion:**
   * Abre CLion y selecciona **"New Project"**. Si ya tienes un proyecto abierto, dir√≠gete al men√∫ `File` -> `New` -> `Project...` en la barra de men√∫.
   * Escoge un proyecto del tipo **C++ Executable**.
   * Asigna el nombre **PrimerPrograma** al proyecto y elige guardarlo en la carpeta `CLionProjects` dentro de tu escritorio para mantener todo organizado.
     - Ejemplo de ubicaci√≥n: `C:\Users\Portatil\Desktop\CLionProjects\PrimerPrograma`
   * Donde dice "Lenguaje est√°ndar", selecciona `c++20`
   * Cuando te pregunte si quieres abrir el proyecto en una nueva ventana o en la misma ventana, selecciona **"this window"** para que el proyecto se abra en la ventana actual de CLion.

<p align="center">
  <img src="img/PrimerPrograma.png" height="500">
</p>

**2. Escribir el c√≥digo:**
   * Una vez creado el proyecto, abre el archivo principal (por defecto ser√° `main.cpp`).
   * Reemplaza el contenido de `main.cpp` con el c√≥digo del programa anterior.

**3. Ejecutar el programa:**
   * Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>
.
   * Aparecer√° la consola integrada donde podr√°s ver los resultados.
</details>

<details><summary>üì• Accede al proyecto PrimerPrograma en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/PrimerPrograma.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd TiposDeDatos
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/TiposDeDatos` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.

</details>

# 3. **Buenas Pr√°cticas al Escribir C√≥digo**

En programaci√≥n, seguir buenas pr√°cticas para nombrar proyectos, archivos, variables, clases, constantes y otros elementos es crucial para garantizar un c√≥digo m√°s legible, mantenible y profesional. Las convenciones claras y consistentes no solo facilitan la colaboraci√≥n entre desarrolladores, sino que tambi√©n ayudan a reducir errores y a mantener un flujo de trabajo organizado.  

**[Nombrar Proyectos]**: Para nombrar proyectos, es habitual emplear la convenci√≥n conocida como **PascalCase**. Este estilo implica que cada palabra comience con una letra may√∫scula, incluida la primera, y evita el uso de espacios o guiones bajos. Ejemplos t√≠picos de nombres de proyectos son:
- `PrimerPrograma`  
- `BankingSystem`  
- `MathTools`  
  
**[Nombrar Clases y Estructuras]**: La convenci√≥n **PascalCase** tambi√©n se utiliza com√∫nmente para nombrar **clases y estructuras**, ya que proporciona un aspecto formal y profesional, ideal para representar componentes clave del c√≥digo, tales como:
- `CuentaBancaria`  
- `Estudiante`  
- `MathOperations`  

**[Nombrar Variables y Funciones]**: Por otro lado, las **variables y funciones** suelen seguir la convenci√≥n **camelCase**. En este caso, la primera palabra comienza en min√∫scula, mientras que las palabras subsiguientes inician con may√∫scula, lo que visualmente crea una forma que recuerda las jorobas de un camello üê™. Esto permite que las palabras dentro del nombre se destaquen sin romper el flujo de lectura. Ejemplos de nombres de variables podr√≠an ser:  
- `totalAmount`  
- `userInput`  

Mientras que las funciones suelen escribirse como:  
- `calculateSum()`  
- `findMaxValue()`  

**[Nombrar Constantes y Macros]**: En el caso de las **constantes y macros**, la convenci√≥n ampliamente aceptada es escribir los nombres completamente en may√∫sculas, separando las palabras con guiones bajos para mayor claridad. Esto permite que estos elementos sean f√°cilmente distinguibles de otros componentes del c√≥digo y refuerza su naturaleza inmutable. Ejemplos incluyen:  
- `PI_VALUE`  
- `MAX_SIZE`  
- `DEBUG_MODE`  

El uso de estas convenciones no es arbitrario, sino que responde a est√°ndares ampliamente adoptados en la industria de la programaci√≥n. Adoptar estas pr√°cticas desde el principio puede marcar una gran diferencia en la claridad, organizaci√≥n y profesionalismo de tu c√≥digo. ¬°Incorporarlas es un paso hacia un desarrollo m√°s eficiente y colaborativo! üöÄ

**Comparaci√≥n Visual de Convenciones**
| Elemento           | Convenci√≥n      | Ejemplo               |
|---------------------|----------------|-----------------------|
| **Proyectos**       | PascalCase     | `PrimerPrograma`      |
| **Variables**       | camelCase      | `totalAmount`         |
| **Funciones**       | camelCase      | `calculateSum()`      |
| **Clases**          | PascalCase     | `CuentaBancaria`      |
| **Constantes/Macros** | MAY√öSCULAS    | `MAX_SIZE`, `PI_VALUE` |


> [!NOTE]
> 
> - **camelCase** üê´: Se llama as√≠ porque las letras may√∫sculas recuerdan las **jorobas de un camello**, con la primera palabra en min√∫scula.  
> - **PascalCase** üè´: Recibe su nombre del lenguaje de programaci√≥n **Pascal**, creado en los a√±os 70, que utilizaba esta convenci√≥n para nombrar las variables.  

---

# 4. **Tipos de Datos**

En C++, adem√°s de los tipos de datos fundamentales como `int`, `char`, y `float`, existe un sistema robusto de tipos que permite construir tipos m√°s complejos. Estos tipos b√°sicos se combinan con modificadores como `short`, `long`, `unsigned`, y otros.

> [!NOTE]
> 
> **C++ es un lenguaje altamente tipado**: En C++, cada variable debe tener un tipo de dato expl√≠cito que no puede cambiar durante la ejecuci√≥n. Esto ayuda a prevenir errores y garantiza mayor control sobre los datos.  
> 
> **Lenguajes no altamente tipados**, como Python, permiten que las variables cambien de tipo sin errores, lo que ofrece mayor flexibilidad pero con un mayor riesgo de errores.  


<details><summary>üí° Hint: Entendiendo los modificadores de tipo</summary>
    
### ¬øQu√© son los modificadores? <!-- omit in toc -->

Los modificadores son palabras clave en C++ que se utilizan para ajustar el rango y comportamiento de los tipos de datos b√°sicos. Aqu√≠ hay una descripci√≥n breve de cada uno:

1. **`signed`**  
   Este modificador permite almacenar valores **positivos y negativos**. Por defecto, los tipos como `int` y `char` son `signed` si no se especifica lo contrario.  

2. **`unsigned`**  
   Al usar este modificador, el tipo solo almacena valores **positivos**, lo que duplica el rango de n√∫meros positivos posibles.  

3. **`short`**  
   Reduce el tama√±o del tipo de dato (en bytes), por lo que ocupa menos memoria y tiene un rango m√°s limitado.  

4. **`long`**  
   Incrementa el tama√±o del tipo de dato, permitiendo manejar n√∫meros m√°s grandes.  

5. **`long long`**  
   Es una extensi√≥n del modificador `long`, permitiendo manejar n√∫meros a√∫n m√°s grandes, especialmente en sistemas de 64 bits.  

### Combinaciones √∫tiles <!-- omit in toc -->
Los modificadores pueden combinarse para definir tipos espec√≠ficos. Por ejemplo:
- `unsigned long` permite trabajar con n√∫meros enteros positivos grandes.
- `signed short` es redundante, ya que `short` ya incluye el signo de manera predeterminada.
</details>

---

## **Enteros**

[](https://gist.githubusercontent.com/yoanpinzon/5b2814a82213ec2b3788da37c32945fa/raw/981b1859d02dc2bf831cf5016253c56173180182/main.cpp)

| Tipo de dato         | Bytes | Valores                |
|----------------------|:-----:|------------------------|
| [`signed char`](https://gist.githubusercontent.com/yoanpinzon/5b2814a82213ec2b3788da37c32945fa/raw/981b1859d02dc2bf831cf5016253c56173180182/main.cpp) ü§™       | 1     | [-128, 127]             |
| `unsigned char`      | 1     | [0, 255]               |
| `short int`          | 2     | [-32768, 32767]        |
| `unsigned short`     | 2     | [0, 65535]             |
| `int`                | 4     | [-2^31, 2^31-1]        |
| `unsigned int`       | 4     | [0, 4294967295]        |
| `long`               | 4     | [-2^31, 2^31-1]        |
| `unsigned long`      | 4     | [0, 4294967295]        |
| `long long int`      | 8     | [-2^63, 2^63-1]        |
| `unsigned long long int` | 8  | [0, 2^64-1]           |


---

## **N√∫meros Reales**

| Tipo de dato    | Bytes | Valores                                  |
|-----------------|:-----:|------------------------------------------|
| `float`         | 4     | 1.17549435√ó10^-38 a 3.40282347√ó10^38    |
| `double`        | 8     | 2.2250738585072014√ó10^-308 a 1.7976931348623157√ó10^308 |
| `long double`   | 16    | ‚âà 10^-4931 a ‚âà 10^4932                  |

---

## **Booleanos**

En C++, el tipo `bool` se usa para representar valores l√≥gicos, es decir, `true` (verdadero) o `false` (falso). Es un tipo integral de 1 byte que es especialmente √∫til en estructuras de control y en la l√≥gica booleana. [üßõ](https://gist.githubusercontent.com/yoanpinzon/6ec692080af01f7ac4fad8ade36d97d3/raw/deb18a148491df51341596084f0d4ee720a4492d/main.cpp)


| Tipo de dato  | Bytes | Valores      |
|---------------|:-----:|--------------|
| `bool`        | 1     | `true` o `false` |

---

## **Tipo `void`**

En C++, el tipo `void` se utiliza para indicar la ausencia de un valor o un tipo de dato. A diferencia de otros tipos (como `int` o `char`), `void` no puede almacenar informaci√≥n ni representar un valor en s√≠ mismo. En espa√±ol, `void` significa "vac√≠o", lo que refleja perfectamente su prop√≥sito

---

## **Cadenas de Texto**

Una cadena de texto no es un tipo fundamental como `int`, `float`, o `char`. En C++, las cadenas son representadas como arreglos de caracteres (`char[]`), o mediante la clase `std::string` de la biblioteca est√°ndar, que facilita muchas operaciones con cadenas de texto.

---

## **Ejemplo de Programa con Tipos de Datos**

A continucion encontraras un programa que incorpora algunos de estos tipos de datos: 

```cpp
// Proyecto: TiposDeDatos
// Archivo: main.cpp
// Este programa es una introducci√≥n a los tipos de datos b√°sicos en C++.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iostream>
#include <string>  // Para usar el tipo string
using namespace std;

int main() {
    // Uso de 'signed' (por defecto en 'int') y 'unsigned'
    signed int num1 = -10;  // Almacena valores negativos
    unsigned int num2 = 10;  // Solo almacena valores positivos

    // Uso de 'short' y 'long' para modificar el tama√±o de los enteros
    short int smallValue = 32767;  // Valor peque√±o, solo puede almacenar valores hasta 32767
    long int largeValue = 2147483647;  // Valor largo, m√°s grande que el 'int' tradicional

    // Uso de 'long long' para valores a√∫n m√°s grandes
    long long int veryLargeValue = 9223372036854775807;  // Valor m√°ximo para 'long long'

    // Uso de 'bool' para representar valores l√≥gicos
    bool isPositive = num2 > 0;  // Verifica si num2 es mayor que 0

    // Uso de 'string' para almacenar una cadena de texto
    string greeting = "¬°Hola, mundo de C++!";

    // Imprimir los resultados
    cout << "Valor con signo (signed int): " << num1 << endl;
    cout << "Valor sin signo (unsigned int): " << num2 << endl;
    cout << "Valor peque√±o (short int): " << smallValue << endl;
    cout << "Valor largo (long int): " << largeValue << endl;
    cout << "Valor muy largo (long long int): " << veryLargeValue << endl;

    // Imprimir los resultados de 'bool' y 'string'
    cout << "¬øEs num2 positivo? " << (isPositive ? "S√≠" : "No") << endl;  // Uso del operador ternario
    cout << "Mensaje de saludo: " << greeting << endl;

    return 0;
}
```

<details><summary>üë®‚Äçüè´ Explicaci√≥n</summary>

  Este programa en C++ est√° dise√±ado para ilustrar c√≥mo utilizar diferentes tipos de datos b√°sicos, como enteros, valores booleanos y cadenas de texto. Comienza con la declaraci√≥n de varias variables de distintos tipos, utilizando modificadores para controlar c√≥mo se almacenan los datos.

  Primero, se declaran dos variables enteras: una con signo (`signed int`), que puede almacenar tanto n√∫meros positivos como negativos, y otra sin signo (`unsigned int`), que solo puede almacenar valores positivos. En este caso, se asignan valores de `-10` y `10`, respectivamente. Adem√°s, se utilizan otros tipos de enteros con tama√±os modificados, como `short int`, que tiene un l√≠mite de `32767`, y `long int`, que es m√°s grande que el tipo est√°ndar `int`. Luego, se introduce `long long int`, que permite almacenar valores a√∫n m√°s grandes, como el n√∫mero `9223372036854775807`.

  El programa tambi√©n emplea el tipo `bool`, que representa valores l√≥gicos como `true` o `false`. Aqu√≠, se utiliza para verificar si el valor de la variable `num2` es positivo, asignando `true` a la variable `isPositive` porque el valor de `num2` es mayor que cero. Este valor se imprime utilizando un operador ternario, que es una forma compacta de tomar decisiones en C++: si `isPositive` es `true`, imprime "S√≠", y si no lo es, imprime "No".

  Finalmente, se declara una variable de tipo `string` para almacenar una cadena de texto, y su valor se muestra en pantalla. Al final del programa, se imprime todo el contenido de las variables declaradas, mostrando c√≥mo se gestionan diferentes tipos de datos en C++ y c√≥mo se pueden manipular y presentar los resultados al usuario.

  En resumen, este programa es un ejemplo b√°sico de c√≥mo trabajar con tipos de datos primitivos en C++, realizando comparaciones l√≥gicas y mostrando mensajes al usuario.
</details>

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Crear un nuevo proyecto en CLion:**
   * Abre CLion y selecciona **"New Project"**. Si ya tienes un proyecto abierto, dir√≠gete al men√∫ `File` -> `New` -> `Project...` en la barra de men√∫.
   * Escoge un proyecto del tipo **C++ Executable**.
   * Asigna el nombre **TiposDeDatos** al proyecto y elige guardarlo en la carpeta `CLionProjects` dentro de tu escritorio para mantener todo organizado.
     - Ejemplo de ubicaci√≥n: `C:\Users\Portatil\Desktop\CLionProjects\TiposDeDatos`
   * Donde dice "Lenguaje est√°ndar", selecciona `c++20`
   * Cuando te pregunte si quieres abrir el proyecto en una nueva ventana o en la misma ventana, selecciona **"this window"** para que el proyecto se abra en la ventana actual de CLion.

**2. Escribir el c√≥digo:**
   * Una vez creado el proyecto, abre el archivo principal (por defecto ser√° `main.cpp`).
   * Reemplaza el contenido de `main.cpp` con el c√≥digo del programa anterior.

**3. Ejecutar el programa:**
   * Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>
.
   * Aparecer√° la consola integrada donde podr√°s ver los resultados.
</details>

<details><summary>üì• Accede al proyecto TiposDeDatos en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y sigue estos pasos:

1. Navega a la carpeta donde quieres guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto usando el siguiente comando:

   ```bash
   git clone https://github.com/yoanpinzon/TiposDeDatos.git
   ```

3. Una vez clonado, accede a la carpeta del proyecto:

   ```bash
   cd TiposDeDatos
   ```

4. Luego, abre la carpeta `~/Desktop/CLionProjects/TiposDeDatos` en **CLion**.

Cuando el proyecto est√© abierto en **CLion**, podr√°s ejecutar el programa desde all√≠.

</details>

---

# 5. **Literales**

En C++, un **literal** es un valor constante que se escribe directamente en el c√≥digo fuente. Estos valores pueden ser de distintos tipos, como enteros, flotantes, caracteres, cadenas de texto y booleanos. Adem√°s, C++ permite el uso de sufijos para especificar el tipo exacto de un literal.

---

## **Literales Enteros**

Un literal entero es un n√∫mero sin punto decimal. Puede representarse en diferentes bases num√©ricas:

| Notaci√≥n    | Ejemplo    | Base |
| ----------- | ---------- | ---- |
| Decimal     | `42`       | 10   |
| Octal       | `052`      | 8    |
| Hexadecimal | `0x2A`     | 16   |
| Binario     | `0b101010` | 2    |

### Sufijos para Literales Enteros <!-- omit in toc -->

C++ permite agregar sufijos para modificar el tipo de un literal entero:

| Sufijo                   | Tipo                                              |
| ------------------------ | ------------------------------------------------- |
| `u` o `U`                | `unsigned`                                        |
| `l` o `L`                | `long`                                            |
| `ll` o `LL`              | `long long`                                       |
| `ul`, `UL`, `ull`, `ULL` | Variaciones de unsigned long y unsigned long long |

### Ejemplo 1: <!-- omit in toc -->

```cpp
// Proyecto: Literales
// Archivo: main.cpp
// Este programa demuestra el uso de literales enteros en C++.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iostream>

int main() {
    int decimal = 42;
    int octal = 052;
    int hexadecimal = 0x2A;
    int binario = 0b101010;
    unsigned long long grande = 123456789ULL;
    
    std::cout << "Decimal: " << decimal << "\n";
    std::cout << "Octal: " << octal << "\n";
    std::cout << "Hexadecimal: " << hexadecimal << "\n";
    std::cout << "Binario: " << binario << "\n";
    std::cout << "Unsigned Long Long: " << grande << "\n";
    return 0;
}
```

Salida:
```
Decimal: 42
Octal: 42
Hexadecimal: 42
Binario: 42
Unsigned Long Long: 123456789
```


<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Crear un nuevo proyecto en CLion:**
   * Abre CLion y selecciona **"New Project"**. Si ya tienes un proyecto abierto, dir√≠gete al men√∫ `File` -> `New` -> `Project...` en la barra de men√∫.
   * Escoge un proyecto del tipo **C++ Executable**.
   * Asigna el nombre **Literales** al proyecto y elige guardarlo en la carpeta `CLionProjects` dentro de tu escritorio para mantener todo organizado.
     - Ejemplo de ubicaci√≥n: `C:\Users\Portatil\Desktop\CLionProjects\Literales`
   * Donde dice "Lenguaje est√°ndar", selecciona `c++20`
   * Cuando te pregunte si quieres abrir el proyecto en una nueva ventana o en la misma ventana, selecciona **"this window"** para que el proyecto se abra en la ventana actual de CLion.

**2. Escribir el c√≥digo:**
   * Una vez creado el proyecto, abre el archivo principal (por defecto ser√° `main.cpp`).
   * Reemplaza el contenido de `main.cpp` con el c√≥digo del programa anterior.

**3. Ejecutar el programa:**
   * Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>.
   * Aparecer√° la consola integrada donde podr√°s ver el resultado.
</details>

<details><summary>üì• Accede al proyecto Literales en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/Literales.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd Literales
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/Literales` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.
</details>

---

## **Literales de Punto Flotante**

Los literales de punto flotante representan n√∫meros con decimales o en notaci√≥n cient√≠fica:

| Ejemplo  | Representaci√≥n                     |
| -------- | ---------------------------------- |
| `3.14`   | Notaci√≥n est√°ndar                  |
| `2.5e-3` | Notaci√≥n cient√≠fica (`2.5 √ó 10‚Åª¬≥`) |

### Sufijos para Literales Flotantes <!-- omit in toc -->

| Sufijo    | Tipo          |
| --------- | ------------- |
| `f` o `F` | `float`       |
| `l` o `L` | `long double` |

### Ejemplo 2: <!-- omit in toc -->

```cpp
// Proyecto: Literales
// Archivo: lietralesFlotantes.cpp
// Este programa demuestra el uso de literales de punto flotante en C++.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iostream>

int main() {
    double normal = 3.14;
    float flotante = 3.14f;
    long double grande = 2.5e-3L;
    
    std::cout << "Double: " << normal << "\n";
    std::cout << "Float: " << flotante << "\n";
    std::cout << "Long Double: " << grande << "\n";
    return 0;
}
```

Salida:
```
Double: 3.14
Float: 3.14
Long Double: 0.0025
```

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Agregar un nuevo archivo fuente C++ en el proyecto `Literales`:**
* Haz clic derecho en el proyecto `Literales` y selecciona `New` > `C/C++ Source File`.
* Nombra el archivo como `literalesFlotantes.cpp`.
* Haz clic en `Add new target`, a la derecha de `Add to targets`.
* En el campo `new_target`, reemplaza el nombre por `literalesFlotantes` y luego haz clic en `Add...`.
* Aseg√∫rate de que solo `literalesFlotantes` est√© seleccionado en la lista de targets y desmarca otros si est√°n seleccionados.
* Ahora, Dale clic a OK ‚úÖ para confirmar.

**2. Escribir el c√≥digo en `literalesFlotantes.cpp`:**
* Abre el archivo `literalesFlotantes.cpp` y copia el c√≥digo del programa que se te proporcion√≥.

**3. Compilar el programa:**
* Antes de compilar, en la parte superior, haz clic en el men√∫ desplegable junto al bot√≥n **Build** (üî®) y selecciona `literalesFlotantes`
* Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>.
* Una vez que la ejecuci√≥n haya finalizado, podr√°s interactuar con la aplicaci√≥n.
</details>

<details><summary>üì• Accede al proyecto Literales en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/Literales.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd Literales
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/Literales` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.
</details>

---

## **Literales de Caracter y Cadenas**

### Literales de Caracter <!-- omit in toc -->

Un literal de car√°cter se escribe entre comillas simples `'A'` y puede usar secuencias de escape como `\n`, `\t`, etc.

| Ejemplo | Representaci√≥n  |
| ------- | --------------- |
| `'A'`   | Car√°cter simple |
| `'\n'`  | Nueva l√≠nea     |
| `'\t'`  | Tabulaci√≥n      |

> [!NOTE]
>
> Estos son todos los literales con secuencias de escape disponibles en C++:  
> 
>| Secuencia | Descripci√≥n |  
>|-----------|------------|  
>| `\'` | Comilla simple |  
>| `\"` | Comilla doble |  
>| `\?` | Signo de interrogaci√≥n para evitar `??` (trigraphs) |  
>| `\\` | Barra invertida (`\`) |  
>| `\a` | Sonido de alerta (beep) |  
>| `\b` | Retroceso |  
>| `\f` | Avance de p√°gina |  
>| `\n` | Nueva l√≠nea |  
>| `\r` | Retorno de carro |  
>| `\t` | Tabulaci√≥n horizontal |  
>| `\v` | Tabulaci√≥n vertical |  
>| `\xhh` | Car√°cter en hexadecimal (ejemplo: `\x41` ‚Üí 'A') |  
>| `\ooo` | Car√°cter en octal (ejemplo: `\101` ‚Üí 'A') |  
>

### Literales de Cadenas <!-- omit in toc -->

Los literales de cadena se escriben entre comillas dobles (`""`) y pueden contener secuencias de escape para caracteres especiales.

| Ejemplo                  | Representaci√≥n        |
|--------------------------|----------------------|
| `"Hola"`                | Cadena de caracteres |
| `"La vida\nes\nbella"`  | Cadena de caracteres |

### Ejemplo 3: <!-- omit in toc -->

A continuaci√≥n, se presenta un programa en C++ que demuestra el uso de literales de car√°cter y cadenas.

```cpp
// Proyecto: Literales
// Archivo: literalesCaracter.cpp
// Este programa demuestra el uso de literales de car√°cter y cadenas en C++.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iostream>
#include <string>

int main() {
    char letra = 'A';
    const char* cadena = "Hola, C++";
    std::string mensaje = "La vida\nes\nbella";

    std::cout << "Letra: " << letra << std::endl;
    std::cout << "Cadena: " << cadena << std::endl;
    std::cout << "Mensaje: " << mensaje << std::endl;

    return 0;
}
```

Salida:
```
Letra: A
Cadena: Hola, C++
Mensaje: La vida
es
bella
```

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Agregar un nuevo archivo fuente C++ en el proyecto `Literales`:**
* Haz clic derecho en el proyecto `Literales` y selecciona `New` > `C/C++ Source File`.
* Nombra el archivo como `literalesCaracter.cpp`.
* Haz clic en `Add new target`, a la derecha de `Add to targets`.
* En el campo `new_target`, reemplaza el nombre por `literalesCaracter` y luego haz clic en `Add...`.
* Aseg√∫rate de que solo `literalesCaracter` est√© seleccionado en la lista de targets y desmarca otros si est√°n seleccionados.
* Ahora, Dale clic a OK ‚úÖ para confirmar.

**2. Escribir el c√≥digo en `literalesCaracter.cpp`:**
* Abre el archivo `literalesCaracter.cpp` y copia el c√≥digo del programa que se te proporcion√≥.

**3. Compilar el programa:**
* Antes de compilar, en la parte superior, haz clic en el men√∫ desplegable junto al bot√≥n **Build** (üî®) y selecciona `literalesCaracter`
* Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>.
* Una vez que la ejecuci√≥n haya finalizado, podr√°s interactuar con la aplicaci√≥n.
</details>

<details><summary>üì• Accede al proyecto Literales en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/Literales.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd Literales
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/Literales` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.
</details>

---

> <h4>‚ö° Hack</h4>  
>
> En C++, puedes usar literales de usuario para definir unidades personalizadas. Por ejemplo, puedes hacer que 100_km represente 100 kil√≥metros directamente en tu c√≥digo:
>
> ```cpp
> #include <iostream>
> using namespace std;
>
> constexpr double operator"" _km(long double distancia) {
>     return distancia * 1000; // Convierte km a metros
> }
>
> int main() {
>     double distancia = 5.0_km; // Se interpreta como 5000 metros
>     cout << "Distancia en metros: " << distancia << "m" << endl;
>     return 0;
> }
>

---

# 6. **Operadores**

C++ incluye una amplia variedad de operadores divididos en categor√≠as seg√∫n su funci√≥n. Aqu√≠ te presento una gu√≠a completa, con ejemplos claros para entender su uso y precedencia.

---

## **Aritm√©ticos**

| Operator | Function     | Use                 | Association |
|:-:|:-:|:-:|:-:|
| `()`     | parentheses  | `(expr list)`       | L-to-R      |
| `*`      | multiply     | `expr1 * expr2`     | L-to-R      |
| `/`      | divide       | `expr1 / expr2`     | L-to-R      |
| `%`      | modulo       | `expr1 % expr2`     | L-to-R      |
| `+`      | plus         | `expr1 + expr2`     | L-to-R      |
| `-`      | minus        | `expr1 - expr2`     | L-to-R      |

### Ejemplo: <!-- omit in toc -->

```cpp
// Proyecto: ManejoDeOperadores
// Archivo: main.cpp
// Este programa demuestra c√≥mo funciona la jerarqu√≠a de operadores en C++
// mediante ejemplos de c√°lculos con operaciones aritm√©ticas y l√≥gicas.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iostream>

int main() {
    int i = 4, j = 7, k = 5, val1, val2;

    // C√°lculo de val1:
    // i * j = 4 * 7 = 28
    // 28 / 2 = 14
    // k % 2 = 5 % 2 = 1 (resto de dividir 5 entre 2)
    // 14 + 1 - 3 = 12
    val1 = i * j / 2 + k % 2 - 3;

    // C√°lculo de val2:
    // 2 + k = 2 + 5 = 7
    // i * j = 4 * 7 = 28
    // 28 / 7 = 4
    // 4 % 2 = 0 (resto de dividir 4 entre 2)
    // 0 - 3 = -3
    val2 = (i * j / (2 + k)) % 2 - 3;

    // Mostrar los resultados calculados
    std::cout << "val1 = " << val1 << std::endl; // outputs 12
    std::cout << "val2 = " << val2 << std::endl; // outputs -3

    return 0;
}
```

Salida:
```
val1 = 12
val2 = -3
```

<details><summary>üë®‚Äçüè´ Explicaci√≥n</summary>

### C√°lculo de `val1`: <!-- omit in toc -->
```cpp
val1 = i * j / 2 + k % 2 - 3;
```
- **`i * j`** = 4 * 7 = 28
- **`28 / 2`** = 14
- **`k % 2`** = 5 % 2 = 1 (el resto de dividir 5 entre 2)
- **`14 + 1 - 3`** = 12

Por lo tanto, **`val1`** ser√° igual a **12**.

### C√°lculo de `val2`: <!-- omit in toc -->
```cpp
val2 = (i * j / (2 + k)) % 2 - 3;
```
- **`2 + k`** = 2 + 5 = 7
- **`i * j / 7`** = 4 * 7 / 7 = 28 / 7 = 4
- **`4 % 2`** = 0 (el resto de dividir 4 entre 2)
- **`0 - 3`** = -3

Por lo tanto, **`val2`** ser√° igual a **-3**.
</details>

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Crear un nuevo proyecto en CLion:**
   * Abre CLion y selecciona **"New Project"**. Si ya tienes un proyecto abierto, dir√≠gete al men√∫ `File` -> `New` -> `Project...` en la barra de men√∫.
   * Escoge un proyecto del tipo **C++ Executable**.
   * Asigna el nombre **ManejoDeOperadores** al proyecto y elige guardarlo en la carpeta `CLionProjects` dentro de tu escritorio para mantener todo organizado.
     - Ejemplo de ubicaci√≥n: `C:\Users\Portatil\Desktop\CLionProjects\ManejoDeOperadores`
   * Donde dice "Lenguaje est√°ndar", selecciona `c++20`
   * Cuando te pregunte si quieres abrir el proyecto en una nueva ventana o en la misma ventana, selecciona **"this window"** para que el proyecto se abra en la ventana actual de CLion.

**2. Escribir el c√≥digo:**
   * Una vez creado el proyecto, abre el archivo principal (por defecto ser√° `main.cpp`).
   * Reemplaza el contenido de `main.cpp` con el c√≥digo del programa anterior.

**3. Ejecutar el programa:**
   * Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>
.
   * Aparecer√° la consola integrada donde podr√°s ver el resultado.
</details>

<details><summary>üì• Accede al proyecto ManejoDeOperadores en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/ManejoDeOperadores.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd ManejoDeOperadores
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/ManejoDeOperadores` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.

</details>

---

## **Relacionales y L√≥gicos**

| Operator | Function               | Use                   | Association |
|:-:|:-:|:-:|:-:|
| `!`      | logical NOT            | `!expr`               | R-to-L      |
| `<`      | less than              | `expr1 < expr2`       | L-to-R      |
| `<=`     | less than or equal     | `expr1 <= expr2`      | L-to-R      |
| `>`      | greater than           | `expr1 > expr2`       | L-to-R      |
| `>=`     | greater than or equal  | `expr1 >= expr2`      | L-to-R      |
| `==`     | equal                  | `expr1 == expr2`      | L-to-R      |
| `!=`     | not equal              | `expr1 != expr2`      | L-to-R      |
| `&&`     | logical AND            | `expr1 && expr2`      | L-to-R      |
| `\|\|`     | logical OR             | `expr1 \|\| expr2`      | L-to-R      |

### Ejemplo 1: <!-- omit in toc -->

```cpp
// Proyecto: ManejoDeOperadores
// Archivo: evaluacionAdmisiones.cpp
// Este programa eval√∫a si un estudiante cumple los requisitos de admisi√≥n a una universidad.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iostream>
#include <string>

int main() {
    // Variables de entrada
    int edad;
    float promedio;
    int experienciaLaboral; // A√±os de experiencia laboral
    bool requisitosAdicionales;

    // Solicitar informaci√≥n del usuario
    std::cout << "Ingrese su edad: ";
    std::cin >> edad;

    std::cout << "Ingrese su promedio escolar (0.0 - 10.0): ";
    std::cin >> promedio;

    std::cout << "Ingrese sus a√±os de experiencia laboral: ";
    std::cin >> experienciaLaboral;

    std::cout << "¬øHa cumplido con los requisitos adicionales? (1 para S√≠, 0 para No): ";
    std::cin >> requisitosAdicionales;

    // Evaluar criterios de admisi√≥n usando operadores relacionales y l√≥gicos
    bool cumpleEdad = edad >= 18 && edad <= 35; // Edad entre 18 y 35 a√±os
    bool cumplePromedio = promedio >= 8.0; // Promedio m√≠nimo de 8.0
    bool cumpleExperiencia = experienciaLaboral >= 2 || requisitosAdicionales; // Experiencia m√≠nima de 2 a√±os o cumplir requisitos adicionales

    // Evaluar si es admitido
    bool admitido = cumpleEdad && cumplePromedio && cumpleExperiencia;

    // Mostrar resultados
    std::cout << "\nResultados de la evaluaci√≥n:\n";
    std::cout << "Cumple con el rango de edad (18-35): " << (cumpleEdad ? "S√≠" : "No") << std::endl;
    std::cout << "Cumple con el promedio m√≠nimo (>= 8.0): " << (cumplePromedio ? "S√≠" : "No") << std::endl;
    std::cout << "Cumple con experiencia laboral o requisitos adicionales: " << (cumpleExperiencia ? "S√≠" : "No") << std::endl;

    std::cout << "\nEstado final de admisi√≥n: " << (admitido ? "¬°Admitido!" : "No admitido. Int√©ntalo de nuevo.") << std::endl;

    return 0;
}
```

Salida:

```
Ingrese su edad: 20
Ingrese su promedio escolar (0.0 - 10.0): 8.5
Ingrese sus a√±os de experiencia laboral: 3
¬øHa cumplido con los requisitos adicionales? (1 para S√≠, 0 para No):0

Resultados de la evaluaci√≥n:
Cumple con el rango de edad (18-35): S√≠
Cumple con el promedio m√≠nimo (>= 8.0): S√≠
Cumple con experiencia laboral o requisitos adicionales: S√≠

Estado final de admisi√≥n: ¬°Admitido!
```

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Agregar un nuevo archivo fuente C++ en el proyecto `ManejoDeOperadores` creado anteriormente:**
* Para crear un nuevo archivo fuente en tu proyecto `ManejoDeOperadores`, tienes dos caminos r√°pidos:
   -  Haz clic derecho en el proyecto `ManejoDeOperadores` en la ventana del proyecto (<kbd>Alt</kbd>-<kbd>1</kbd>) y selecciona `New` > `C/C++ Source File`.
   - Ir a `File` > `New` > `C/C++ Source File` en la barra de men√∫. 
* Nombra el archivo como `evaluacionAdmisiones` y en tipo selecciona `.cpp`
* Haz clic en `Add new target`, a la derecha de `Add to targets`.
* En el campo `new_target`, reemplaza el nombre por `evaluacionAdmisiones` y luego haz clic en `Add...`.
* Aseg√∫rate de que solo `evaluacionAdmisiones` est√© seleccionado en la lista de targets y desmarca `ManejoDeOperadores` si est√° seleccionado.
* La ventana deber√≠a verse de la siguiente manera:

<p align="center">
  <img src="img/evaluacionAdmisiones.png" height="400">
</p>

* Ahora, Dale clic a OK ‚úÖ para confirmar.

**3. Escribir el c√≥digo en `evaluacionAdmisiones.cpp`:**
* Abre el archivo `evaluacionAdmisiones.cpp` y copia el c√≥digo del programa que se te proporcion√≥.

**4. Compilar el programa:**
* Antes de compilar, en la parte superior, haz clic en el men√∫ desplegable junto al bot√≥n **Build** (üî®) y selecciona `evaluacionAdmisiones` como se muestra en la imagen:

<p align="center">
  <img src="img/evaluacionAdmisiones2.png" height="140">
</p>

* Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>
.
* Aparecer√° la consola integrada donde podr√°s ver los resultados del programa.

* **Nota:** Si no aparecen correctamente las tildes o caracteres especiales, puedes agregar la l√≠nea `system("chcp 65001");` al inicio del `main`. Esto configurar√° la consola para usar `UTF-8` y mostrar√° los caracteres correctamente.  

**5. Modificar el CMakeLists.txt manualmente:**
* Si no pudiste compilar correctamente siguiendo los pasos anteriores, puedes modificar directamente el archivo `CMakeLists.txt` para que quede de la siguiente manera:

```cpp
cmake_minimum_required(VERSION 3.30)
project(ManejoDeOperadores)

set(CMAKE_CXX_STANDARD 20)

add_executable(ManejoDeOperadores main.cpp)
add_executable(evaluacionAdmisiones evaluacionAdmisiones.cpp)
```
</details>

<details><summary>üì• Accede al proyecto ManejoDeOperadores en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/ManejoDeOperadores.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd ManejoDeOperadores
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/ManejoDeOperadores` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.

</details>

### Ejemplo 2: <!-- omit in toc -->

```cpp
// Proyecto: ManejoDeOperadores
// Archivo: operadoresLogicosRelacionales.cpp
// Este programa eval√∫a expresiones usando operadores de igualdad, relacionales y l√≥gicos.
// Incluye ejemplos pr√°cticos y casos complejos para su an√°lisis.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iostream>

int main() {
    std::cout << "Exploraci√≥n de Operadores L√≥gicos y Relacionales\n\n";

    // Caso 1: Evaluaci√≥n con AND y OR combinados
    bool caso1 = (5 < 3) && (6 <= 6) || (5 != 6);
    std::cout << "Caso 1: (5 < 3) && (6 <= 6) || (5 != 6) = "
              << (caso1 ? "true" : "false") << "\n";

    // Caso 2: Uso de par√©ntesis para alterar la precedencia
    bool caso2 = (5 < 3) && ((6 <= 6) || (5 != 6));
    std::cout << "Caso 2: (5 < 3) && ((6 <= 6) || (5 != 6)) = "
              << (caso2 ? "true" : "false") << "\n";

    // Caso 3: Negaci√≥n de una combinaci√≥n compleja
    bool caso3 = !((5 < 3) && ((6 <= 6) || (5 != 6)));
    std::cout << "Caso 3: !((5 < 3) && ((6 <= 6) || (5 != 6))) = "
              << (caso3 ? "true" : "false") << "\n";

    // Caso 4: Evaluaci√≥n condicional con cortocircuito
    bool ladoIzquierdoEvaluado = false;
    bool caso4 = (ladoIzquierdoEvaluado = (6 <= 6)) || (5 < 3);
    std::cout << "Caso 4: (ladoIzquierdoEvaluado = (6 <= 6)) || (5 < 3) = "
              << (caso4 ? "true" : "false") << "\n";
    std::cout << "El valor de ladoIzquierdoEvaluado es: "
              << (ladoIzquierdoEvaluado ? "true" : "false") << "\n";

    // Caso 5: Uso avanzado de negaci√≥n y AND
    bool caso5 = !(5 != 6 && (6 > 5 || 3 < 2));
    std::cout << "Caso 5: !(5 != 6 && (6 > 5 || 3 < 2)) = "
              << (caso5 ? "true" : "false") << "\n";

    // Caso 6: Ejemplo pr√°ctico - Decidir si salir a caminar
    bool estaLloviendo = false;
    bool tienesTiempoLibre = true;
    bool salirACaminar = !estaLloviendo && tienesTiempoLibre; // Evaluar
    std::cout << "Caso 6: ¬øPuedo salir a caminar?\n";
    std::cout << "Respuesta: " << (salirACaminar ? "S√≠, puedes salir." : "No, no puedes salir.") << "\n";
    std::cout << "Explicaci√≥n: La condici√≥n combina el operador NOT (!) y AND (&&).\n";
    std::cout << "Si no est√° lloviendo y tienes tiempo libre, puedes aprovechar para salir.\n";
    std::cout << "Esta es la magia de la l√≥gica aplicada a nuestra vida cotidiana.\n\n";

    // Conclusi√≥n
    std::cout << "Estos casos ilustran c√≥mo los operadores l√≥gicos y relacionales trabajan en conjunto.\n";
    std::cout << "Recuerda que el orden de evaluaci√≥n y el uso de par√©ntesis son claves para obtener el resultado esperado.\n";

    return 0;
}
```

Salida:

```
Exploraci√≥n de Operadores L√≥gicos y Relacionales

Caso 1: (5 < 3) && (6 <= 6) || (5 != 6) = true
Caso 2: (5 < 3) && ((6 <= 6) || (5 != 6)) = false
Caso 3: !((5 < 3) && ((6 <= 6) || (5 != 6))) = true
Caso 4: (ladoIzquierdoEvaluado = (6 <= 6)) || (5 < 3) = true
El valor de ladoIzquierdoEvaluado es: true
Caso 5: !(5 != 6 && (6 > 5 || 3 < 2)) = false
Caso 6: ¬øPuedo salir a caminar?
Respuesta: S√≠, puedes salir.
Explicaci√≥n: La condici√≥n combina el operador NOT (!) y AND (&&).
Si no est√° lloviendo y tienes tiempo libre, puedes aprovechar para salir.
Esta es la magia de la l√≥gica aplicada a nuestra vida cotidiana.

Estos casos ilustran c√≥mo los operadores l√≥gicos y relacionales trabajan en conjunto.
Recuerda que el orden de evaluaci√≥n y el uso de par√©ntesis son claves para obtener el resultado esperado.
```

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Agregar un nuevo archivo fuente C++ en el proyecto `ManejoDeOperadores`:**
* Haz clic derecho en el proyecto `ManejoDeOperadores` y selecciona `New` > `C/C++ Source File`.
* Nombra el archivo como `operadoresLogicosRelacionales.cpp`.
* Haz clic en `Add new target`, a la derecha de `Add to targets`.
* En el campo `new_target`, reemplaza el nombre por `operadoresLogicosRelacionales` y luego haz clic en `Add...`.
* Aseg√∫rate de que solo `operadoresLogicosRelacionales` est√© seleccionado en la lista de targets y desmarca otros si est√°n seleccionados.
* La ventana deber√≠a verse de la siguiente manera:

<p align="center">
  <img src="img/operadoresLogicosRelacionales.png" height="400">
</p>

* Ahora, Dale clic a OK ‚úÖ para confirmar.

**2. Escribir el c√≥digo en `operadoresLogicosRelacionales.cpp`:**
* Abre el archivo `operadoresLogicosRelacionales.cpp` y copia el c√≥digo del programa que se te proporcion√≥.

**3. Compilar el programa:**
* Antes de compilar, en la parte superior, haz clic en el men√∫ desplegable junto al bot√≥n **Build** (üî®) y selecciona `operadoresLogicosRelacionales` como se muestra en la imagen:

<p align="center">
  <img src="img/operadoresLogicosRelacionales2.png" height="140">
</p>

* Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>
.
* Una vez que se complete la ejecuci√≥n, ver√°s las salidas y las explicaciones correspondientes.
</details>

<details><summary>üì• Accede al proyecto ManejoDeOperadores en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/ManejoDeOperadores.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd ManejoDeOperadores
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/ManejoDeOperadores` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.

</details>

---

## **Bitwise**

| Operator | Function          | Use                | Association |
|:-:|:-:|:-:|:-:|
| `~`      | bitwise NOT       | `~expr`            | R-to-L      |
| `<<`     | shift left        | `expr1 << expr2`   | L-to-R      |
| `>>`     | shift right       | `expr1 >> expr2`   | L-to-R      |
| `&`      | bitwise AND       | `expr1 & expr2`    | L-to-R      |
| `^`      | bitwise XOR       | `expr1 ^ expr2`    | L-to-R      |
| `\|`      | bitwise OR        | `expr1 | expr2`    | L-to-R      |

### Ejemplo 1: <!-- omit in toc -->

```cpp
// Proyecto: ManejoDeOperadores
// Archivo: operadoresBitwise.cpp
// Este programa muestra c√≥mo los operadores bitwise trabajan a nivel de bits en n√∫meros enteros.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iostream>
#include <bitset>  // Para visualizar los n√∫meros en su representaci√≥n binaria

int main() {
    // Definir dos n√∫meros para las operaciones bitwise
    unsigned int a = 5;  // 0000 0101 en binario
    unsigned int b = 3;  // 0000 0011 en binario

    // Mostrar los n√∫meros en su forma binaria y decimal
    std::cout << "a = " << a << " (" << std::bitset<8>(a) << " en binario)\n";
    std::cout << "b = " << b << " (" << std::bitset<8>(b) << " en binario)\n\n";

    // Operador bitwise NOT (~)
    unsigned int not_a = ~a;
    std::cout << "Operador ~ (bitwise NOT) de a: ~a = " << not_a 
              << " (" << std::bitset<8>(not_a) << " en binario) - En decimal: " << not_a << "\n\n";

    // Operador bitwise AND (&)
    unsigned int and_ab = a & b;
    std::cout << "Operador & (bitwise AND) de a y b: a & b = " << and_ab
              << " (" << std::bitset<8>(and_ab) << " en binario) - En decimal: " << and_ab << "\n\n";

    // Operador bitwise OR (|)
    unsigned int or_ab = a | b;
    std::cout << "Operador | (bitwise OR) de a y b: a | b = " << or_ab
              << " (" << std::bitset<8>(or_ab) << " en binario) - En decimal: " << or_ab << "\n\n";

    // Operador bitwise XOR (^)
    unsigned int xor_ab = a ^ b;
    std::cout << "Operador ^ (bitwise XOR) de a y b: a ^ b = " << xor_ab
              << " (" << std::bitset<8>(xor_ab) << " en binario) - En decimal: " << xor_ab << "\n\n";

    // Operador de desplazamiento a la izquierda (<<)
    unsigned int shift_left = a << 1;
    std::cout << "Operador << (shift left) de a: a << 1 = " << shift_left
              << " (" << std::bitset<8>(shift_left) << " en binario) - En decimal: " << shift_left << "\n\n";

    // Operador de desplazamiento a la derecha (>>)
    unsigned int shift_right = a >> 1;
    std::cout << "Operador >> (shift right) de a: a >> 1 = " << shift_right
              << " (" << std::bitset<8>(shift_right) << " en binario) - En decimal: " << shift_right << "\n\n";

    // Resumen de lo aprendido
    std::cout << "Resumen de operadores bitwise utilizados:\n";
    std::cout << "~: Invierte los bits (bitwise NOT).\n";
    std::cout << "&: Compara los bits de dos n√∫meros, resultando en 1 solo si ambos bits son 1 (bitwise AND).\n";
    std::cout << "|: Compara los bits de dos n√∫meros, resultando en 1 si al menos uno de los bits es 1 (bitwise OR).\n";
    std::cout << "^: Compara los bits de dos n√∫meros, resultando en 1 si los bits son diferentes (bitwise XOR).\n";
    std::cout << "<<: Desplaza los bits de un n√∫mero hacia la izquierda (shift left), multiplicando el valor por 2.\n";
    std::cout << ">>: Desplaza los bits de un n√∫mero hacia la derecha (shift right), dividiendo el valor por 2.\n";

    return 0;
}
```

Salida:

```
a = 5 (00000101 en binario)
b = 3 (00000011 en binario)

Operador ~ (bitwise NOT) de a: ~a = 4294967290 (11111010 en binario) - En decimal: 4294967290

Operador & (bitwise AND) de a y b: a & b = 1 (00000001 en binario) - En decimal: 1

Operador | (bitwise OR) de a y b: a | b = 7 (00000111 en binario) - En decimal: 7

Operador ^ (bitwise XOR) de a y b: a ^ b = 6 (00000110 en binario) - En decimal: 6

Operador << (shift left) de a: a << 1 = 10 (00001010 en binario) - En decimal: 10

Operador >> (shift right) de a: a >> 1 = 2 (00000010 en binario) - En decimal: 2

Resumen de operadores bitwise utilizados:
~: Invierte los bits (bitwise NOT).
&: Compara los bits de dos n√∫meros, resultando en 1 solo si ambos bits son 1 (bitwise AND).
|: Compara los bits de dos n√∫meros, resultando en 1 si al menos uno de los bits es 1 (bitwise OR).
^: Compara los bits de dos n√∫meros, resultando en 1 si los bits son diferentes (bitwise XOR).
<<: Desplaza los bits de un n√∫mero hacia la izquierda (shift left), multiplicando el valor por 2.
>>: Desplaza los bits de un n√∫mero hacia la derecha (shift right), dividiendo el valor por 2.
```

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Agregar un nuevo archivo fuente C++ en el proyecto `ManejoDeOperadores`:**
* Haz clic derecho en el proyecto `ManejoDeOperadores` y selecciona `New` > `C/C++ Source File`.
* Nombra el archivo como `operadoresBitwise.cpp`.
* Haz clic en `Add new target`, a la derecha de `Add to targets`.
* En el campo `new_target`, reemplaza el nombre por `operadoresBitwise` y luego haz clic en `Add...`.
* Aseg√∫rate de que solo `operadoresBitwise` est√© seleccionado en la lista de targets y desmarca otros si est√°n seleccionados.
* Ahora, Dale clic a OK ‚úÖ para confirmar.

**2. Escribir el c√≥digo en `operadoresBitwise.cpp`:**
* Abre el archivo `operadoresBitwise.cpp` y copia el c√≥digo del programa que se te proporcion√≥.

**3. Compilar el programa:**
* Antes de compilar, en la parte superior, haz clic en el men√∫ desplegable junto al bot√≥n **Build** (üî®) y selecciona `operadoresBitwise`
* Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>
.
* Una vez que se complete la ejecuci√≥n, ver√°s las salidas y las explicaciones correspondientes.
</details>

<details><summary>üì• Accede al proyecto ManejoDeOperadores en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/ManejoDeOperadores.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd ManejoDeOperadores
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/ManejoDeOperadores` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.

</details>


### Ejemplo 2: <!-- omit in toc -->

```cpp
// Proyecto: ManejoDeOperadores
// Archivo: gestionPermisos.cpp
// Este programa muestra c√≥mo los operadores bitwise trabajan a nivel de bits en n√∫meros enteros.
// Se utiliza para gestionar permisos en un archivo representados mediante bits.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iostream>
#include <bitset>

// Definimos una constante para cada permiso
const int PERMISO_LECTURA = 0b100;
const int PERMISO_ESCRITURA = 0b010;
const int PERMISO_EJECUCION = 0b001;

int main() {
    // Inicializamos permisos sin ning√∫n permiso activado
    int permisos = 0b000; 
    
    // Explicaci√≥n de la representaci√≥n de permisos
    std::cout << "Representaci√≥n de permisos:\n";
    std::cout << "bit 2 -> Lectura\n";
    std::cout << "bit 1 -> Escritura\n";
    std::cout << "bit 0 -> Ejecuci√≥n\n\n";
    
    int opcion;
    
    // Ciclo principal del men√∫
    do {
        std::cout << "\nMen√∫ de Permisos:\n";
        std::cout << "1. Agregar permiso de lectura\n";
        std::cout << "2. Quitar permiso de lectura\n";
        std::cout << "3. Agregar permiso de escritura\n";
        std::cout << "4. Quitar permiso de escritura\n";
        std::cout << "5. Agregar permiso de ejecuci√≥n\n";
        std::cout << "6. Quitar permiso de ejecuci√≥n\n";
        std::cout << "7. Ver permisos actuales\n";
        std::cout << "8. Salir\n";
        std::cout << "Seleccione una opci√≥n: ";
        std::cin >> opcion;
        
        switch (opcion) {
            case 1: // Agregar permiso de lectura
                permisos |= PERMISO_LECTURA;
                std::cout << "Permiso de lectura agregado.\n";
                break;
            case 2: // Quitar permiso de lectura
                permisos &= ~PERMISO_LECTURA;
                std::cout << "Permiso de lectura quitado.\n";
                break;
            case 3: // Agregar permiso de escritura
                permisos |= PERMISO_ESCRITURA;
                std::cout << "Permiso de escritura agregado.\n";
                break;
            case 4: // Quitar permiso de escritura
                permisos &= ~PERMISO_ESCRITURA;
                std::cout << "Permiso de escritura quitado.\n";
                break;
            case 5: // Agregar permiso de ejecuci√≥n
                permisos |= PERMISO_EJECUCION;
                std::cout << "Permiso de ejecuci√≥n agregado.\n";
                break;
            case 6: // Quitar permiso de ejecuci√≥n
                permisos &= ~PERMISO_EJECUCION;
                std::cout << "Permiso de ejecuci√≥n quitado.\n";
                break;
            case 7: // Ver permisos actuales
                std::cout << "Permisos actuales (en binario): " << std::bitset<3>(permisos) << "\n";
                std::cout << "Permisos actuales (en decimal): " << permisos << "\n";
                break;
            case 8: // Salir
                std::cout << "Saliendo del programa.\n";
                break;
            default:
                std::cout << "Opci√≥n no v√°lida.\n";
                break;
        }
    } while (opcion != 8);  // El ciclo sigue hasta que el usuario elija salir

    return 0;
}
```

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Agregar un nuevo archivo fuente C++ en el proyecto `ManejoDeOperadores`:**
* Haz clic derecho en el proyecto `ManejoDeOperadores` y selecciona `New` > `C/C++ Source File`.
* Nombra el archivo como `gestionPermisos.cpp`.
* Haz clic en `Add new target`, a la derecha de `Add to targets`.
* En el campo `new_target`, reemplaza el nombre por `gestionPermisos` y luego haz clic en `Add...`.
* Aseg√∫rate de que solo `gestionPermisos` est√© seleccionado en la lista de targets y desmarca otros si est√°n seleccionados.
* Ahora, Dale clic a OK ‚úÖ para confirmar.

**2. Escribir el c√≥digo en `gestionPermisos.cpp`:**
* Abre el archivo `gestionPermisos.cpp` y copia el c√≥digo del programa que se te proporcion√≥.

**3. Compilar el programa:**
* Antes de compilar, en la parte superior, haz clic en el men√∫ desplegable junto al bot√≥n **Build** (üî®) y selecciona `gestionPermisos`
* Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>
.
* Una vez que se complete la ejecuci√≥n podras interactuar con el programa.
</details>

<details><summary>üì• Accede al proyecto ManejoDeOperadores en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/ManejoDeOperadores.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd ManejoDeOperadores
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/ManejoDeOperadores` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.

</details>

---

## **De Asignaci√≥n**

| Operator | Function              | Use              | Association |
|:-:|:-:|:-:|:-:|
| `=`       | conventional assignment | `lvalue = expr`   | R-to-L      |
| `*=`      | multiply and assign    | `lvalue *= expr`  | R-to-L      |
| `/=`      | divide and assign      | `lvalue /= expr`  | R-to-L      |
| `%=`      | modulo and assign      | `lvalue %= expr`  | R-to-L      |
| `+=`      | add and assign         | `lvalue += expr`  | R-to-L      |
| `-=`      | subtract and assign     | `lvalue -= expr`  | R-to-L      |
| `<<=`     | shift left and assign   | `lvalue <<= expr` | R-to-L      |
| `>>=`     | shift right and assign  | `lvalue >>= expr` | R-to-L      |
| `&=`      | AND and assign         | `lvalue &= expr`  | R-to-L      |
| `\|=`      | OR and assign           | `lvalue \|= expr`  | R-to-L      |
| `^=`      | XOR and assign         | `lvalue ^= expr`  | R-to-L      |


generally `a op= b` is equivalent to `a = a op b`.

### Ejemplo 1: <!-- omit in toc -->

```cpp
// Proyecto: ManejoDeOperadores
// Archivo: cuentaBancaria.cpp
// Este programa permite gestionar una cuenta bancaria con operaciones de dep√≥sito, retiro, consulta de saldo y bonificaci√≥n por saldo alto.
// Los operadores de asignaci√≥n se usan para modificar el saldo de la cuenta y se aplican bonificaciones si se cumplen las condiciones.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iostream>
#include <vector>
#include <string>
#include <iomanip>  // Para std::setw

int main() {
    int saldo = 1000;  // Saldo inicial
    std::vector<std::string> historial;  // Historial de transacciones
    int deposito, retiro, opcion;
    int umbralBonificacion = 5000;  // Umbral para bonificaci√≥n
    double bonificacion = 1.10;  // Bonificaci√≥n del 10%

    do {
        std::cout << "Saldo actual: $" << saldo << "\n";
        std::cout << "1. Depositar\n2. Retirar\n3. Ver historial\n4. Bonificaci√≥n\n5. Salir\n";
        std::cout << "Seleccione una opci√≥n: ";
        std::cin >> opcion;

        switch (opcion) {
            case 1:  // Depositar
                std::cout << "Ingrese el monto a depositar: $";
                std::cin >> deposito;
                saldo += deposito;
                historial.push_back("Dep√≥sito: $" + std::to_string(deposito) + " | Saldo antes: " + std::to_string(saldo - deposito) + " | Saldo despu√©s: " + std::to_string(saldo));
                break;
            case 2:  // Retirar
                std::cout << "Ingrese el monto a retirar: $";
                std::cin >> retiro;
                if (retiro > saldo) {
                    std::cout << "Saldo insuficiente.\n";
                } else {
                    saldo -= retiro;
                    historial.push_back("Retiro: $" + std::to_string(retiro) + " | Saldo antes: " + std::to_string(saldo + retiro) + " | Saldo despu√©s: " + std::to_string(saldo));
                }
                break;
            case 3:  // Ver historial
                std::cout << "Historial de transacciones:\n";

                // Agregar la consulta del historial al historial
                historial.push_back("Consulta de historial | Saldo antes: " + std::to_string(saldo) + " | Saldo despu√©s: " + std::to_string(saldo));

                // Mostrar historial con contador
                for (int i = 0; i < historial.size(); ++i) {
                    std::cout << std::setw(3) << i + 1 << ". " << historial[i] << "\n";
                }
                break;
            case 4:  // Bonificaci√≥n
                if (saldo > umbralBonificacion) {
                    saldo *= bonificacion;
                    historial.push_back("Bonificaci√≥n aplicada | Saldo antes: " + std::to_string(saldo / bonificacion) + " | Saldo despu√©s: " + std::to_string(saldo));
                    std::cout << "Bonificaci√≥n aplicada. Nuevo saldo: $" << saldo << "\n";
                } else {
                    // Asegurarse de que el evento quede registrado en el historial
                    historial.push_back("Bonificaci√≥n no aplicada | Saldo antes: " + std::to_string(saldo) + " | Saldo despu√©s: " + std::to_string(saldo));
                    std::cout << "No se alcanz√≥ el umbral para bonificaci√≥n.\n";
                }
                break;
            case 5:  // Salir
                std::cout << "Saliendo...\n";
                break;
            default:
                std::cout << "Opci√≥n no v√°lida.\n";
        }
    } while (opcion != 5);

    return 0;
}
```

<details><summary>üíªüîç Descubriendo el Poder de C++: Vectores y Formato con iomanip </summary>

**¬øPor qu√© se han agregado `vector` e `iomanip`?**

1. **Uso de `vector`** üìä:  
   El `vector` es una de las estructuras de datos m√°s √∫tiles en C++. Es una colecci√≥n din√°mica de elementos, lo que significa que no necesitas definir su tama√±o al momento de crearla. A medida que se a√±aden elementos, el `vector` se ajusta autom√°ticamente, lo que lo hace muy flexible. 

En el programa, usamos un `vector` para almacenar el historial de las transacciones bancarias. Cada vez que se realiza una operaci√≥n (dep√≥sito, retiro, bonificaci√≥n), se agrega una nueva entrada al `vector`. Esto es muy √∫til cuando no sabemos cu√°ntas transacciones se realizar√°n, ya que el `vector` manejar√° el tama√±o por s√≠ mismo.

   **Algunas funcionalidades clave de `vector`**:
   - **`push_back()`**: Agrega un nuevo elemento al final del `vector`. Por ejemplo, cuando se realiza una transacci√≥n, se usa `push_back()` para agregar la descripci√≥n de esa transacci√≥n al historial.
   - **Acceso a elementos**: Puedes acceder a cualquier elemento en el `vector` usando el operador `[]`. Por ejemplo, `historial[i]` nos permite acceder a la transacci√≥n en la posici√≥n `i` del `vector`.
   - **`size()`**: Esta funci√≥n devuelve el n√∫mero de elementos almacenados en el `vector`. En nuestro caso, se usa en el bucle `for` para iterar sobre cada transacci√≥n en el historial.

2. **Uso de `iomanip`** üé®:  
   La librer√≠a `iomanip` se utiliza para mejorar la presentaci√≥n de los datos en la consola. Nos permite controlar aspectos como el formato de los n√∫meros y la alineaci√≥n de la salida. En este programa, se emplea la funci√≥n `std::setw()` para alinear de manera ordenada los n√∫meros de las transacciones en el historial. A continuaci√≥n, algunos manipuladores b√°sicos que puedes usar con `iomanip`:

   - **`std::setw(int n)`**: Esta funci√≥n establece el ancho m√≠nimo de campo para la siguiente salida. Si el n√∫mero de caracteres en la salida es menor que el valor de `n`, se a√±aden espacios a la izquierda. Esto es √∫til para alinear las columnas de los datos, asegurando que los n√∫meros se vean ordenados y bien formateados.
   - **`std::setprecision(int n)`**: Establece el n√∫mero de d√≠gitos despu√©s del punto decimal cuando se imprime un n√∫mero. Es √∫til para mostrar n√∫meros flotantes con una cantidad espec√≠fica de decimales.
   - **`std::left`**: Alinea los datos a la izquierda en el campo de salida.
   - **`std::right`**: Alinea los datos a la derecha en el campo de salida.
</details>


<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Agregar un nuevo archivo fuente C++ en el proyecto `ManejoDeOperadores`:**
* Haz clic derecho en el proyecto `ManejoDeOperadores` y selecciona `New` > `C/C++ Source File`.
* Nombra el archivo como `cuentaBancaria.cpp`.
* Haz clic en `Add new target`, a la derecha de `Add to targets`.
* En el campo `new_target`, reemplaza el nombre por `cuentaBancaria` y luego haz clic en `Add...`.
* Aseg√∫rate de que solo `cuentaBancaria` est√© seleccionado en la lista de targets y desmarca otros si est√°n seleccionados.
* Ahora, Dale clic a OK ‚úÖ para confirmar.

**2. Escribir el c√≥digo en `cuentaBancaria.cpp`:**
* Abre el archivo `cuentaBancaria.cpp` y copia el c√≥digo del programa que se te proporcion√≥.

**3. Compilar el programa:**
* Antes de compilar, en la parte superior, haz clic en el men√∫ desplegable junto al bot√≥n **Build** (üî®) y selecciona `cuentaBancaria`
* Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>
.
* Una vez que la ejecuci√≥n haya finalizado, podr√°s interactuar con la aplicaci√≥n.
</details>

<details><summary>üì• Accede al proyecto ManejoDeOperadores en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/ManejoDeOperadores.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd ManejoDeOperadores
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/ManejoDeOperadores` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.

</details>

### Ejemplo 2: <!-- omit in toc -->

```cpp
// Proyecto: ManejoDeOperadores
// Archivo: operadoresAsignacion.cpp
// Este programa demuestra el uso de varios operadores de asignaci√≥n y el operador coma (",") en C++.
// El operador coma permite ejecutar m√∫ltiples expresiones en una misma l√≠nea, mientras que los operadores
// de asignaci√≥n como "/=" y ">>=" permiten modificar el valor de las variables de forma eficiente.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iostream>

int main() {
    // Definir algunas variables para trabajar
    int a = 20, b = 10, c = 60, d = 200;

    // Explicaci√≥n del operador coma (,)
    // El operador coma (,) se llama **operador de secuencia** o **operador coma**.
    // Permite ejecutar varias expresiones dentro de una misma instrucci√≥n.
    // Las expresiones se ejecutan de izquierda a derecha, pero el valor de la expresi√≥n
    // es el de la √∫ltima expresi√≥n. Es √∫til cuando queremos realizar varias operaciones
    // y devolver el valor de la √∫ltima de ellas.

    std::cout << "Valor inicial de a: " << a << ", b: " << b << ", c: " << c << ", d: " << d << std::endl;

    // Usando el operador coma para realizar varias asignaciones
    // Primero, se asigna 10 a b, luego 20 a c, y finalmente el valor de c (20) a a.
    a = (b = 10, c = 20);

    std::cout << "Despu√©s de usar el operador coma (secuencia):" << std::endl;
    std::cout << "a: " << a << ", b: " << b << ", c: " << c << ", d: " << d << std::endl;

    // Ahora con el operador /= (divisi√≥n)
    // Dividimos a por 2, b por 5, c por 10 y luego asignamos el resultado de a / b
    a /= 2;  // a = a / 2
    b /= 5;  // b = b / 5
    c /= 10; // c = c / 10

    std::cout << "Despu√©s de usar el operador /= (divisi√≥n):" << std::endl;
    std::cout << "a: " << a << ", b: " << b << ", c: " << c << ", d: " << d << std::endl;

    // Usando el operador de desplazamiento a la derecha (>>= 2)
    // Desplazamos a a la derecha 2 bits, es decir, dividimos a entre 4 (equivalente a a = a / 4).
    a >>= 2;  // a = a >> 2, es equivalente a a / 4

    std::cout << "Despu√©s de usar el operador >>= (desplazamiento a la derecha):" << std::endl;
    std::cout << "a: " << a << ", b: " << b << ", c: " << c << ", d: " << d << std::endl;

    // Tambi√©n podemos usar el operador coma para realizar m√°s operaciones en una sola l√≠nea:
    // Primero, se realiza la suma en a, resta en b, multiplicaci√≥n en c y luego se asigna el
    // valor de a * b a d.
    d = (a += 5, b -= 2, c *= 3, a * b);

    std::cout << "Despu√©s de usar coma con operadores adicionales:" << std::endl;
    std::cout << "a: " << a << ", b: " << b << ", c: " << c << ", d: " << d << std::endl;

    return 0;
}
```

Salida:

```
Valor inicial de a: 20, b: 10, c: 60, d: 200
Despu√©s de usar el operador coma (secuencia):
a: 20, b: 10, c: 20, d: 200
Despu√©s de usar el operador /= (divisi√≥n):
a: 10, b: 2, c: 2, d: 200
Despu√©s de usar el operador >>= (desplazamiento a la derecha):
a: 2, b: 2, c: 2, d: 200
Despu√©s de usar coma con operadores adicionales:
a: 7, b: 0, c: 6, d: 0
```

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Agregar un nuevo archivo fuente C++ en el proyecto `ManejoDeOperadores`:**
* Haz clic derecho en el proyecto `ManejoDeOperadores` y selecciona `New` > `C/C++ Source File`.
* Nombra el archivo como `operadoresAsignacion.cpp`.
* Haz clic en `Add new target`, a la derecha de `Add to targets`.
* En el campo `new_target`, reemplaza el nombre por `operadoresAsignacion` y luego haz clic en `Add...`.
* Aseg√∫rate de que solo `operadoresAsignacion` est√© seleccionado en la lista de targets y desmarca otros si est√°n seleccionados.
* Ahora, Dale clic a OK ‚úÖ para confirmar.

**2. Escribir el c√≥digo en `operadoresAsignacion.cpp`:**
* Abre el archivo `operadoresAsignacion.cpp` y copia el c√≥digo del programa que se te proporcion√≥.

**3. Compilar el programa:**
* Antes de compilar, en la parte superior, haz clic en el men√∫ desplegable junto al bot√≥n **Build** (üî®) y selecciona `operadoresAsignacion`
* Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>
.
* Una vez que se complete la ejecuci√≥n, ver√°s las salidas.
</details>

<details><summary>üì• Accede al proyecto ManejoDeOperadores en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/ManejoDeOperadores.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd ManejoDeOperadores
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/ManejoDeOperadores` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.

</details>

---

## **Unarios**

| Operator | Function           | Use            | Association |
|:-:|:-:|:-:|:-:|
|  `++`     | post increment     | `lvalue++`       | L-to-R      |
|  `--`     | post decrement     | `lvalue--`       | L-to-R      |
| `sizeof`  | size of object     | `sizeof(expr)`   | R-to-L      |
| `sizeof`  | size of type      | `sizeof(type)`   | R-to-L      |
|  `++`     | pre increment      | `++lvalue`       | R-to-L      |
|  `--`     | pre decrement      | `--lvalue`       | L-to-R      |
|  `+`      | unary plus         | `+lvalue`        | R-to-L      |
|  `-`      | unary minus        | `-lvalue`        | R-to-L      |

### Ejemplo: <!-- omit in toc -->

```cpp
// Proyecto: ManejoDeOperadores
// Archivo: operadoresIncrementoPrePost.cpp
// Este programa demuestra la diferencia entre los operadores de incremento pre-incremento (++) y post-incremento (++) en C++.
// Se utiliza para entender c√≥mo afectan estos operadores al valor de las variables en una expresi√≥n.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <bitset>
#include <iostream>

int main() {
    int a = 5;

    // Usando el operador post-incremento (a++)
    // En el caso del post-incremento, primero se usa el valor actual de 'a' y luego se incrementa.
    std::cout << "Post-incremento (a++):" << std::endl;
    std::cout << "Valor de a antes de a++: " << a << std::endl;  // Imprime 5
    std::cout << "Resultado de a++: " << a++ << std::endl;      // Imprime 5 (a se incrementa despu√©s de la expresi√≥n)
    std::cout << "Valor de a despu√©s de a++: " << a << std::endl; // Imprime 6

    // Restablecemos 'a' a su valor inicial para probar el pre-incremento
    a = 5;

    // Usando el operador pre-incremento (++a)
    // En el caso del pre-incremento, primero se incrementa el valor de 'a' y luego se usa el valor incrementado.
    std::cout << "\nPre-incremento (++a):" << std::endl;
    std::cout << "Valor de a antes de ++a: " << a << std::endl;  // Imprime 5
    std::cout << "Resultado de ++a: " << ++a << std::endl;      // Imprime 6 (a se incrementa antes de la expresi√≥n)
    std::cout << "Valor de a despu√©s de ++a: " << a << std::endl; // Imprime 6

    return 0;
}
```

Salida:

```
Post-incremento (a++):
Valor de a antes de a++: 5
Resultado de a++: 5
Valor de a despu√©s de a++: 6

Pre-incremento (++a):
Valor de a antes de ++a: 5
Resultado de ++a: 6
Valor de a despu√©s de ++a: 6
```
<details><summary>üë®‚Äçüè´ Explicaci√≥n</summary>

1. **Post-incremento (`a++`)**:
   - En la primera parte, el valor de `a` antes del post-incremento es 5.
   - Se imprime el valor de `a++`, que es 5, y luego `a` se incrementa a 6.
   - Despu√©s del post-incremento, `a` se imprime como 6.

2. **Pre-incremento (`++a`)**:
   - Despu√©s de restablecer `a` a 5, se usa el pre-incremento.
   - El valor de `a` antes del pre-incremento es 5.
   - Se imprime el valor de `++a`, que es 6 (porque `a` se incrementa antes de ser usado en la expresi√≥n).
   - Despu√©s del pre-incremento, `a` sigue siendo 6.

**Resumen:**

1. Cuando usamos a++ ‚û°Ô∏è, el valor de la variable se utiliza primero en la expresi√≥n y luego se incrementa.
2. Cuando escribimos ++a üîù, el valor de la variable se incrementa primero y luego se utiliza en la expresi√≥n.
</details>

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Agregar un nuevo archivo fuente C++ en el proyecto `ManejoDeOperadores`:**
* Haz clic derecho en el proyecto `ManejoDeOperadores` y selecciona `New` > `C/C++ Source File`.
* Nombra el archivo como `operadoresIncrementoPrePost.cpp`.
* Haz clic en `Add new target`, a la derecha de `Add to targets`.
* En el campo `new_target`, reemplaza el nombre por `operadoresIncrementoPrePost` y luego haz clic en `Add...`.
* Aseg√∫rate de que solo `operadoresIncrementoPrePost` est√© seleccionado en la lista de targets y desmarca otros si est√°n seleccionados.
* Ahora, Dale clic a OK ‚úÖ para confirmar.

**2. Escribir el c√≥digo en `operadoresIncrementoPrePost.cpp`:**
* Abre el archivo `operadoresIncrementoPrePost.cpp` y copia el c√≥digo del programa que se te proporcion√≥.

**3. Compilar el programa:**
* Antes de compilar, en la parte superior, haz clic en el men√∫ desplegable junto al bot√≥n **Build** (üî®) y selecciona `operadoresIncrementoPrePost`
* Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>
.
* Al ejecutar el programa, observar√°s los resultados.
</details>

<details><summary>üì• Accede al proyecto ManejoDeOperadores en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/ManejoDeOperadores.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd ManejoDeOperadores
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/ManejoDeOperadores` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.

</details>

---

## **Orden de Precedencia**

| Operator | Function           | Use            | Association |
|:-:|:-:|:-:|:-:|
|  `(`     | parentheses        | `(expr list)`      | L-to-R      |
|  `++`     | post increment     | `lvalue++`         | L-to-R      |
|  `--`     | post decrement     | `lvalue--`         | L-to-R      |
| `sizeof`  | size of object     | `sizeof(expr)`     | R-to-L      |
| `sizeof`  | size of type      | `sizeof(type)`     | R-to-L      |
|  `++`     | pre increment      | `++lvalue`         | R-to-L      |
|  `--`     | pre decrement      | `--lvalue`         | L-to-R      |
|  `~`     | bitwise NOT        | `~expr`           | R-to-L      |
|  `!`     | logical NOT        | `!expr`           | R-to-L      |
|  `-`     | unary minus        | `-lvalue`         | R-to-L      |
|  `+`     | unary plus         | `+lvalue`         | R-to-L      |
|  `&`     | address of         | `&expr`           | R-to-L      |
|  `*`     | dereference       | `*expr`           | R-to-L      |
|  `*`     | multiply          | `expr1 * expr2`   | L-to-R      |
|  `/`     | divide            | `expr1 / expr2`   | L-to-R      |
|  `%`     | modulo            | `expr1 % expr2`   | L-to-R      |
|  `+`     | plus              | `expr1 + expr2`   | L-to-R      |
|  `-`     | minus             | `expr1 - expr2`   | L-to-R      |
|  `<<`    | shift left        | `expr1 << expr2`  | L-to-R      |
|  `>>`    | shift right       | `expr1 >> expr2`  | L-to-R      |
|  `<`     | less than         | `expr1 < expr2`   | L-to-R      |
|  `<=`    | less than or equal | `expr1 <= expr2`  | L-to-R      |
|  `>`     | greater than      | `expr1 > expr2`   | L-to-R      |
|  `>=`    | greater than or equal | `expr1 >= expr2` | L-to-R      |
|  `==`    | equal             | `expr1 == expr2`  | L-to-R      |
|  `!=`    | not equal         | `expr1 != expr2`  | L-to-R      |
|  `&`     | bitwise AND        | `expr1 & expr2`   | L-to-R      |
|  `^`     | bitwise XOR        | `expr1^expr2`     | L-to-R      |
|  `\|`     | bitwise OR         | `expr1 \| expr2`   | L-to-R      |
|  `&&`    | logic AND         | `expr1 && expr2`  | L-to-R      |
|  `\|\|`    | logic OR          | `expr1 \|\| expr2`  | L-to-R      |
|  `?:`    | alternative if    | `expr1 ? expr2 : expr3` | L-to-R      |
|  `<<`    | stream insertion  | `expr1 << expr2`  | L-to-R      |
|  `>>`    | stream extraction | `expr1 >> expr2`  | L-to-R      |
|  `=`     | conventional assignment | `lvalue = expr`   | R-to-L      |
|  `*=`    | multiply and assign    | `lvalue *= expr`  | R-to-L      |
|  `/=`    | divide and assign      | `lvalue /= expr`  | R-to-L      |
|  `%=`    | modulo and assign      | `lvalue %= expr`  | R-to-L      |
|  `+=`    | add and assign         | `lvalue += expr`  | R-to-L      |
|  `-=`    | subtract and assign     | `lvalue -= expr`  | R-to-L      |
|  `<<=`   | shift left and assign   | `lvalue <<= expr` | R-to-L      |
|  `>>=`   | shift right and assign  | `lvalue >>= expr` | R-to-L      |
|  `&=`    | AND and assign         | `lvalue &= expr`  | R-to-L      |
|  `\|=`    | OR and assign           | `lvalue \|= expr`  | R-to-L      |
|  `^=`    | XOR and assign         | `lvalue ^= expr`  | R-to-L      |

---

## Representaciones alternativas de operadores en C++ <!-- omit in toc -->

En C++, algunos operadores tienen representaciones alternativas que funcionan igual, permitiendo escribirlos de manera diferente. Estas alternativas facilitan la escritura del c√≥digo en diferentes entornos sin perder funcionalidad.

| Token principal | Alternativa    |
|-----------------|----------------|
| `&&`            | `and`          |
| `&=`            | `and_eq`       |
| `&`             | `bitand`       |
| `\|`             | `bitor`        |
| `~`             | `compl`        |
| `!`             | `not`          |
| `!=`            | `not_eq`       |
| `\|\|`            | `or`           |
| `\|=`            | `or_eq`        |
| `^`             | `xor`          |
| `^=`            | `xor_eq`       |
| `{`             | `<%`           |
| `}`             | `%>`           |
| `[`             | `<:`           |
| `]`             | `:>`           |
| `#`             | `%:`           |
| `##`            | `%:%:`         |

### Ejemplo: <!-- omit in toc -->

```cpp
// Proyecto: ManejoDeOperadores
// Archivo: tolkensAlternativos.cpp
// Este programa realiza operaciones bitwise (OR, AND, XOR, NOT) y l√≥gicas (OR, AND) usando operadores alternativos en C++.
// Se utiliza 'bitor', 'bitand', 'xor', 'compl' para las operaciones bitwise y 'or' y 'and' para las operaciones l√≥gicas.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iostream>
#include <bitset>
#include <iomanip> // Para setfill y setw

int main() {
    // Definir dos valores enteros
    int a = 85;  // 1000101 en binario
    int b = 112; // 11010101 en binario

    // Establecer el ancho de la salida para que todo se alinee correctamente
    std::cout << std::setw(14) << "a = " << std::bitset<8>(a) << std::endl;
    std::cout << std::setw(14) << "b = " << std::bitset<8>(b) << std::endl;

    // Operaci√≥n OR bitwise usando el token alternativo 'bitor'
    int c = a bitor b;  // Usando 'bitor' en lugar de 'or' (bitwise)
    std::cout << std::setw(14) << "a bitor b = " << std::bitset<8>(c) << std::endl;

    // Operaci√≥n AND bitwise usando el token alternativo 'bitand'
    c = a bitand b;  // Usando 'bitand' en lugar de 'and' (bitwise)
    std::cout << std::setw(14) << "a bitand b = " << std::bitset<8>(c) << std::endl;

    // Operaci√≥n XOR bitwise usando el token alternativo 'xor'
    c = a xor b;  // Usando 'xor' en lugar de 'xor' (bitwise)
    std::cout << std::setw(14) << "a xor b = " << std::bitset<8>(c) << std::endl;

    // Operaci√≥n NOT bitwise usando el token alternativo 'compl'
    c = compl(a);  // Usando 'compl' en lugar de '~'
    std::cout << std::setw(14) << "NOT a = " << std::bitset<8>(c) << std::endl;

    // Diferenciando operaciones l√≥gicas OR y AND
    bool p = true;
    bool q = false;

    // Operaci√≥n l√≥gica OR usando el token alternativo 'or'
    bool logical_or = p or q;  // Usando 'or' como operador l√≥gico
    std::cout << std::setw(14) << "p or q = " << logical_or << std::endl;

    // Operaci√≥n l√≥gica AND usando el token alternativo 'and'
    bool logical_and = p and q;  // Usando 'and' como operador l√≥gico
    std::cout << std::setw(14) << "p and q = " << logical_and << std::endl;

    return 0;
}
```

Salida:

```
          a = 01010101
          b = 01110000
  a bitor b = 01110101
 a bitand b = 01010000
    a xor b = 00100101
      NOT a = 10101010
     p or q = 1
    p and q = 0
```

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary>

**1. Agregar un nuevo archivo fuente C++ en el proyecto `ManejoDeOperadores`:**
* Haz clic derecho en el proyecto `ManejoDeOperadores` y selecciona `New` > `C/C++ Source File`.
* Nombra el archivo como `tolkensAlternativos.cpp`.
* Haz clic en `Add new target`, a la derecha de `Add to targets`.
* En el campo `new_target`, reemplaza el nombre por `tolkensAlternativos` y luego haz clic en `Add...`.
* Aseg√∫rate de que solo `tolkensAlternativos` est√© seleccionado en la lista de targets y desmarca otros si est√°n seleccionados.
* Ahora, Dale clic a OK ‚úÖ para confirmar.

**2. Escribir el c√≥digo en `tolkensAlternativos.cpp`:**
* Abre el archivo `tolkensAlternativos.cpp` y copia el c√≥digo del programa que se te proporcion√≥.

**3. Compilar el programa:**
* Antes de compilar, en la parte superior, haz clic en el men√∫ desplegable junto al bot√≥n **Build** (üî®) y selecciona `tolkensAlternativos`
* Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>
.
* Al ejecutar el programa, podr√°s observar los resultados generados por las operaciones realizadas, los cuales se mostrar√°n en la salida de la consola.
</details>

<details><summary>üì• Accede al proyecto ManejoDeOperadores en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/ManejoDeOperadores.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd ManejoDeOperadores
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/ManejoDeOperadores` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.

</details>

---

# 7. **Conversi√≥n de Tipos de Datos**


La **conversi√≥n de tipos** (o *type casting*) en C++ es el proceso de transformar una variable de un tipo de dato a otro. Existen dos tipos de conversiones:

### **Conversi√≥n Impl√≠cita** <!-- omit in toc -->
   - Tambi√©n conocida como **coerci√≥n de tipos** (*type coercion*).
   - La realiza autom√°ticamente el compilador cuando no hay p√©rdida de datos o ambig√ºedad.
   - Ejemplo: Asignar un `int` a un `float`.

### **Conversi√≥n Expl√≠cita** <!-- omit in toc -->
   - Requiere que el programador indique c√≥mo convertir el tipo.
   - En C++ se puede hacer mediante:
     - Estilo de C: `(tipo) variable` o `tipo(variable)`
     - Casts de C++: `static_cast`, `dynamic_cast`, `const_cast` y `reinterpret_cast`.

---

## **Conversi√≥n Impl√≠cita**

C++ autom√°ticamente realiza la conversi√≥n en situaciones como:
- Asignar un tipo de dato m√°s peque√±o a uno m√°s grande (por ejemplo, de `int` a `float`).
- Llamar a funciones donde los par√°metros no coinciden exactamente con los tipos.

### Ejemplo: <!-- omit in toc -->

```cpp
// Proyecto: TiposDeDatos
// Archivo: conversionTipos.cpp
// Este programa demuestra la conversi√≥n impl√≠cita de un n√∫mero entero (int) a un n√∫mero decimal (float).
// Se muestra el valor original del n√∫mero entero y su valor convertido a float.
// Programador: Profesorcito
// Fecha: 27/ene/2025

#include <iomanip>
#include <iostream>
using namespace std;

int main() {

    system("chcp 65001");

    int num = 10;          // Variable de tipo int
    float decimal = num;   // Conversi√≥n impl√≠cita de int a float

    cout << "N√∫mero entero: " << num << endl;
    cout << "N√∫mero convertido a float: " << decimal << endl;
    cout << "N√∫mero convertido a float: " << fixed << setprecision(2) << decimal << endl;
    cout << "N√∫mero convertido a float: " << fixed << setprecision(4) << decimal << endl;

    return 0;
}
```

Salida:
```
N√∫mero entero: 10
N√∫mero convertido a float: 10
N√∫mero convertido a float: 10.00
N√∫mero convertido a float: 10.0000
```

> [!NOTE]
>
> - **`setprecision(n)`** define cu√°ntos d√≠gitos significativos se imprimen. Sin `fixed`, el formato puede variar, incluso usando notaci√≥n cient√≠fica para ciertos valores.
> - **`fixed`** asegura que `setprecision` controle exclusivamente la cantidad de cifras decimales mostradas, manteniendo un formato consistente.
> - **Librer√≠a requerida:** Para usar `fixed` y `setprecision`, es necesario incluir `<iomanip>`. Sin esta librer√≠a, el programa no compilar√° correctamente.
> - En el programa, combinar `fixed` y `setprecision(2)` garantiza que el n√∫mero decimal siempre se muestre con 2 cifras decimales, incluso si el valor es un entero (por ejemplo: `10.00` en lugar de `10`).

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary> 

**1. Agregar un nuevo archivo fuente C++ en el proyecto `TiposDeDatos`:**
* Haz clic derecho en el proyecto `TiposDeDatos` y selecciona `New` > `C/C++ Source File`.
* Nombra el archivo como `conversionTipos.cpp`.
* Haz clic en `Add new target`, a la derecha de `Add to targets`.
* En el campo `new_target`, reemplaza el nombre por `conversionTipos` y luego haz clic en `Add...`.
* Aseg√∫rate de que solo `conversionTipos` est√© seleccionado en la lista de targets y desmarca otros si est√°n seleccionados.
* Ahora, dale clic a OK ‚úÖ para confirmar.

**2. Escribir el c√≥digo en `conversionTipos.cpp`:**
* Abre el archivo `conversionTipos.cpp` y copia el c√≥digo del programa que se te proporcion√≥.

**3. Compilar el programa:**
* Antes de compilar, en la parte superior, haz clic en el men√∫ desplegable junto al bot√≥n **Build** (üî®) y selecciona `conversionTipos`.
* Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>
.
* Al ejecutar el programa, podr√°s observar los resultados generados por la conversi√≥n impl√≠cita de tipos de datos, los cuales se mostrar√°n en la salida de la consola.
</details>

<details><summary>üì• Accede al proyecto PrimerPrograma en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/PrimerPrograma.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd TiposDeDatos
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/TiposDeDatos` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.

</details>

---

## **Conversi√≥n Expl√≠cita**
En los casos donde el compilador no realiza la conversi√≥n autom√°ticamente, o cuando queremos controlar c√≥mo ocurre, usamos el *casting expl√≠cito*. Hay dos enfoques:

#### **1. Estilo de C (C-style Casting)**  <!-- omit in toc -->
- Utiliza la sintaxis `(tipo) variable`.
- Aunque funciona, puede ser inseguro y poco claro en programas complejos.

#### **2. Estilo C++ (C++-style Casting)**  <!-- omit in toc -->
- Utiliza operadores de casting m√°s espec√≠ficos:
  - `static_cast`: Para conversiones seguras y bien definidas.
  - `dynamic_cast`: Para conversiones en jerarqu√≠as de clases.
  - `const_cast`: Para modificar la constancia de un objeto.
  - `reinterpret_cast`: Para conversiones de bajo nivel.

---

### **Ejemplo:** <!-- omit in toc -->

Este programa muestra la conversi√≥n usando tanto el estilo de C como el estilo de C++:

```cpp
// Proyecto: TiposDeDatos
// Archivo: conversionExpl√≠cita.cpp
// Este programa demuestra las diferentes formas de realizar conversiones de tipo de datos
// en C++, tanto con el estilo de C como con el estilo moderno de C++ (static_cast).
// Autor: Profesorcito
// Fecha: 28/ene/2025

#include <iostream>
using namespace std;

int main() {
    float a = 9.23; // Variable de tipo float
    int b = 3;      // Variable de tipo int

    // Estilo de C
    int c = (int)a;      // Convertir float a int
    float d = (float)b;  // Convertir int a float

    // Estilo C++ usando static_cast
    int e = static_cast<int>(a);   // Convertir float a int
    float f = static_cast<float>(b); // Convertir int a float

    // Mostrar resultados
    cout << "Estilo C: " << endl;
    cout << "c = " << c << " (float a int usando (int))" << endl;
    cout << "d = " << d << " (int a float usando (float))" << endl;

    cout << "\nEstilo C++: " << endl;
    cout << "e = " << e << " (float a int usando static_cast<int>)" << endl;
    cout << "f = " << f << " (int a float usando static_cast<float>)" << endl;

    return 0;
}

```

**Salida:**
```
Estilo C:
c = 9 (float a int usando (int))
d = 3 (int a float usando (float))

Estilo C++:
e = 9 (float a int usando static_cast<int>)
f = 3 (int a float usando static_cast<float>)
```

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary> 

**1. Agregar un nuevo archivo fuente C++ en el proyecto `TiposDeDatos`:**
* Haz clic derecho en el proyecto `TiposDeDatos` y selecciona `New` > `C/C++ Source File`.
* Nombra el archivo como `conversionExpl√≠cita.cpp`.
* Haz clic en `Add new target`, a la derecha de `Add to targets`.
* En el campo `new_target`, reemplaza el nombre por `conversionExpl√≠cita` y luego haz clic en `Add...`.
* Aseg√∫rate de que solo `conversionExpl√≠cita` est√© seleccionado en la lista de targets y desmarca otros si est√°n seleccionados.
* Ahora, dale clic a OK ‚úÖ para confirmar.

**2. Escribir el c√≥digo en `conversionExpl√≠cita.cpp`:**
* Abre el archivo `conversionExpl√≠cita.cpp` y copia el c√≥digo del programa que se te proporcion√≥.

**3. Compilar el programa:**
* Antes de compilar, en la parte superior, haz clic en el men√∫ desplegable junto al bot√≥n **Build** (üî®) y selecciona `conversionExpl√≠cita`.
* Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>
.
* Al ejecutar el programa, podr√°s observar los resultados generados por las conversiones expl√≠citas de tipos de datos (estilo C y C++) que se mostrar√°n en la salida de la consola.
</details>

<details><summary>üì• Accede al proyecto TiposDeDatos en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/TiposDeDatos.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd TiposDeDatos
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/TiposDeDatos` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.

</details>

---

### **Diferencias entre Estilo de C y Estilo C++** <!-- omit in toc -->

| Aspecto                  | Estilo de C              | Estilo C++                |
|--------------------------|--------------------------|---------------------------|
| **Legibilidad**          | Menos claro ‚ö†Ô∏è           | M√°s claro y expl√≠cito ‚úÖ  |
| **Seguridad**            | Menos seguro ‚ö†Ô∏è          | M√°s seguro üîí             |
| **Uso recomendado**      | Desaconsejado en C++ ‚ùå  | Recomendado en C++ ‚úÖ     |


# 8. **Variables Constantes**

Podemos especificar que el valor de una variable no puede ser alterado durante la ejecuci√≥n de un programa utilizando la palabra reservada `const`.

### Ejemplo: <!-- omit in toc -->

```cpp
// Proyecto: TiposDeDatos
// Archivo: usoDeConstantes.cpp
// Este programa utiliza una constante (PI) para calcular el √°rea y la circunferencia de un c√≠rculo
// a partir del radio ingresado por el usuario. Ejemplifica el uso de variables constantes en C++
// y presenta buenas pr√°cticas en el manejo de entrada, salida y nomenclatura de constantes.
// Autor: Profesorcito
// Fecha: 28/ene/2025

#include <iostream>
#include <iomanip> // Para controlar la salida de decimales
using namespace std;

int main() {

    const double PI_VALUE = 3.14159;  // Definimos PI como constante siguiendo las buenas pr√°cticas

    double radio, area, circunferencia;

    // Entrada del radio con validaci√≥n b√°sica
    cout << "Introduce el radio del c√≠rculo (valor positivo): ";
    cin >> radio;

    if (radio <= 0) {  // Validamos que el radio sea positivo
        cout << "El radio debe ser un valor positivo. Int√©ntalo de nuevo." << endl;
        return 1; // Terminamos el programa con un c√≥digo de error
    }

    // C√°lculos usando la constante PI_VALUE
    area = PI_VALUE * radio * radio;
    circunferencia = PI_VALUE * 2 * radio;

    // Formateamos la salida para mostrar dos decimales
    cout << fixed << setprecision(2);
    cout << "El √°rea del c√≠rculo con radio " << radio << " es " << area << endl;
    cout << "La circunferencia es " << circunferencia << endl;

    return 0;
}
```

**Salida:**
```
Introduce el radio del c√≠rculo (valor positivo):11.73
 11.73
El √°rea del c√≠rculo con radio 11.73 es 432.26
La circunferencia es 73.70
```

<details><summary>üèÉ C√≥mo Ejecutar en CLion</summary> 

**1. Agregar un nuevo archivo fuente C++ en el proyecto `TiposDeDatos`:**
* Haz clic derecho en el proyecto `TiposDeDatos` y selecciona `New` > `C/C++ Source File`.
* Nombra el archivo como `usoDeConstantes.cpp`.
* Haz clic en `Add new target`, a la derecha de `Add to targets`.
* En el campo `new_target`, reemplaza el nombre por `usoDeConstantes` y luego haz clic en `Add...`.
* Aseg√∫rate de que solo `usoDeConstantes` est√© seleccionado en la lista de targets y desmarca otros si est√°n seleccionados.
* Ahora, dale clic a OK ‚úÖ para confirmar.

**2. Escribir el c√≥digo en `usoDeConstantes.cpp`:**
* Abre el archivo `usoDeConstantes.cpp` y copia el c√≥digo del programa que se te proporcion√≥.

**3. Compilar el programa:**
* Antes de compilar, en la parte superior, haz clic en el men√∫ desplegable junto al bot√≥n **Build** (üî®) y selecciona `usoDeConstantes`.
* Haz clic en el bot√≥n de **Run** (‚ñ∂Ô∏è) en la parte superior derecha o utiliza el atajo <kbd>Shift</kbd>+<kbd>F10</kbd>.
* Al ejecutar el programa, podr√°s observar los resultados generados por los c√°lculos realizados con constantes (como PI), que se mostrar√°n en la salida de la consola.
</details>

<details><summary>üì• Accede al proyecto TiposDeDatos en el GitHub del profesorcito y cl√≥nalo</summary>

Si deseas clonar este proyecto en tu m√°quina local, abre **Git Bash** y ejecuta los siguientes comandos:

1. Navega a la carpeta donde deseas guardar el proyecto:

   ```bash
   cd ~/Desktop/CLionProjects
   ```

2. Clona el proyecto con el siguiente comando de Git:

   ```bash
   git clone https://github.com/yoanpinzon/TiposDeDatos.git
   ```

3. Una vez clonado, entra a la carpeta del proyecto:

   ```bash
   cd TiposDeDatos
   ```

4. Abre la carpeta `~/Desktop/CLionProjects/TiposDeDatos` en **CLion**.

Una vez abierto en **CLion**, puedes ejecutar el programa directamente desde all√≠.

</details>

> [!NOTE]
> 
> En **C**, las constantes se defin√≠an con `#define`, una directiva del preprocesador que sustituye el nombre por su valor antes de compilar.  
> Por ejemplo:
> ```c++
> #define PI 3.14159
> ```
> Aunque **C++** permite usar `#define`, no tiene un tipo asociado, lo que puede causar errores dif√≠ciles de depurar. Por esta raz√≥n, se recomienda usar `const`, que es m√°s seguro y compatible con el sistema de tipos de C++.

<details><summary>üíé Buenas Pr√°cticas</summary>

1. **Ubicaci√≥n de las constantes:**
   - Declara las constantes al principio del programa o en el √°mbito correspondiente para que su prop√≥sito sea m√°s claro y evitar modificaciones accidentales.
   - Las variables comunes se pueden declarar despu√©s, en el cuerpo de la funci√≥n `main` o en donde sean necesarias.

2. **Estilo de las constantes:**
   - Escribir las constantes en **may√∫sculas** y separar las palabras con un **guion bajo** (`_`) es una convenci√≥n ampliamente recomendada por est√°ndares como **C++ Core Guidelines**, **Google C++ Style Guide**, **ISO C++ Standard** y **Microsoft C++ Coding Guidelines**.
   - Ejemplo: `PI_VALUE` o `MAX_SIZE`.

3. **Uso de `const` en lugar de `#define`:**
   - En **C++**, es preferible usar `const` para definir constantes en lugar de `#define`. Las constantes declaradas con `const` son verificadas por el compilador, lo que proporciona mayor seguridad y reduce posibles errores.
   - A diferencia de `#define`, que es procesado por el preprocesador y realiza una simple sustituci√≥n de texto, las constantes `const` tienen un tipo asociado, lo que permite verificaciones m√°s estrictas en tiempo de compilaci√≥n.

### Raz√≥n: <!-- omit in toc -->

En lenguajes como **C**, las constantes se defin√≠an tradicionalmente con `#define`, que simplemente reemplaza todas las ocurrencias del nombre en el c√≥digo por su valor literal antes de la compilaci√≥n. Esto pod√≠a causar confusiones si se utilizaban nombres ambiguos, como en el siguiente caso:

```c
#define PI 3.14159

float pi = 5.0;
float radius = 10.0;
float area = PI * radius * radius;  // Aqu√≠ PI ser√° reemplazado por 3.14159
```

Si `#define pi 3.14159` se hubiera usado en lugar de `PI`, podr√≠a haber conflictos con la variable `pi` declarada m√°s abajo, causando errores dif√≠ciles de detectar. En contraste, `const` crea una constante con un tipo claro, lo que evita conflictos y hace que el c√≥digo sea m√°s seguro y legible.

4. **Ventaja de usar `const`:**
   - Las constantes declaradas con `const` son parte del sistema de tipos de C++, lo que permite aprovechar las comprobaciones de tipo en tiempo de compilaci√≥n.
   - Adem√°s, a diferencia de `#define`, las constantes con `const` respetan el √°mbito en el que se declaran, lo que mejora la organizaci√≥n y la encapsulaci√≥n del c√≥digo.

</details>

> [!CAUTION]
>
> Usar const aumenta la seguridad del c√≥digo, evitando que se modifiquen valores importantes por error 
>

---

# 9. **Estructuras de Control**

En programaci√≥n, la magia ‚ú® no est√° en escribir l√≠neas de c√≥digo üíª, sino en lograr que el programa **piense** üß† y **decida** üîÄ qu√© hacer. En C++, las **estructuras de control** üß© nos permiten decidir el flujo de un programa. Hoy veremos la **estructura de selecci√≥n `if`** üîÄ, la primera herramienta üõ†Ô∏è para ense√±arle al c√≥digo a **tomar decisiones** .  

---

## **Estructura de Selecci√≥n `if`**

La estructura if permite ejecutar bloques de c√≥digo solo si se cumple una condici√≥n espec√≠fica. Si la condici√≥n es verdadera, el bloque se ejecuta; de lo contrario, se omite.

### Sintaxis: <!-- omit in toc -->

```cpp
if (condici√≥n) {
    // Bloque de c√≥digo que se ejecuta si la condici√≥n es verdadera
}
```

### Ejemplo: <!-- omit in toc -->

```cpp
// Proyecto: EstructurasDeControl
// Archivo: verificaPrimeraLetra.cpp
// Este programa verifica si una palabra ingresada por el usuario
// comienza con una letra espec√≠fica utilizando una estructura de control condicional (if).
// Autor: Profesorcito
// Fecha: 28/ene/2025

#include <iostream>
#include <string>
using namespace std;

int main() {

    string palabra;
    char letra;

    // Solicitar al usuario una palabra
    cout << "Ingresa una palabra: ";
    cin >> palabra;

    // Solicitar al usuario una letra para verificar
    cout << "Ingresa una letra para verificar si la palabra comienza con ella: ";
    cin >> letra;

    // Convertir a min√∫scula utilizando solo las funciones de la librer√≠a string
    if (palabra[0] >= 'A' && palabra[0] <= 'Z') {
        palabra[0] = palabra[0] + ('a' - 'A');
    }
    if (letra >= 'A' && letra <= 'Z') {
        letra = letra + ('a' - 'A');
    }

    // Verificar si la palabra comienza con la letra ingresada (ignorando may√∫sculas/min√∫sculas)
    if (palabra[0] == letra) {
        cout << "¬°La palabra comienza con la letra '" << letra << "'!" << endl;
    }

    // Mensaje final
    cout << "Verificaci√≥n completada." << endl;

    return 0;
}
```

**Salida:**
```
Ingresa una palabra:yoan
Ingresa una letra para verificar si la palabra comienza con ella:y
¬°La palabra comienza con la letra 'y'!
Verificaci√≥n completada.
```

<details><summary>üë®‚Äçüè´ Explicaci√≥n</summary>

Este programa verifica si una palabra ingresada por el usuario comienza con una letra espec√≠fica, sin importar si las letras est√°n en may√∫sculas o min√∫sculas. A continuaci√≥n, se detallan algunos conceptos importantes del c√≥digo:

1. **Acceso al primer car√°cter de la palabra (`palabra[0]`)**:
   - En C++, las cadenas de texto son arrays de caracteres. `palabra[0]` hace referencia al primer car√°cter de la cadena, es decir, a la primera letra de la palabra ingresada por el usuario. Esto es crucial para la verificaci√≥n de si la palabra comienza con una letra espec√≠fica.

2. **Uso de comillas sencillas**:
   - Las comillas sencillas, como en `'A'`, se utilizan para representar caracteres individuales en C++. A diferencia de las comillas dobles (`" "`), que se usan para cadenas de texto, las comillas sencillas se emplean para un solo car√°cter. Los caracteres tienen valores num√©ricos (en el sistema ASCII) que permiten comparaciones y manipulaciones aritm√©ticas.

3. **Operador `&&`**:
   - El operador `&&` es un operador l√≥gico "Y", utilizado para combinar dos condiciones. En el programa, se emplea para verificar si el primer car√°cter de la palabra est√° en el rango de letras may√∫sculas (de `'A'` a `'Z'`). Si ambas condiciones son verdaderas (es decir, si el car√°cter est√° dentro del rango de may√∫sculas), se ejecuta el bloque de c√≥digo dentro del `if`.

4. **La operaci√≥n `'a' - 'A'`**:
   - La operaci√≥n `'a' - 'A'` calcula la diferencia entre los valores ASCII de las letras `'a'` y `'A'`, que es 32. Este valor se usa para convertir una letra may√∫scula en su equivalente en min√∫scula. 
     - **Ejemplo**: Si el primer car√°cter de la palabra es `'A'`, la operaci√≥n `'A' + ('a' - 'A')` convierte la `'A'` en una `'a'`. Esto asegura que la comparaci√≥n de las letras sea insensible a may√∫sculas/min√∫sculas.

En resumen, el programa utiliza estructuras de control, manipulaci√≥n de cadenas y operaciones con valores ASCII para realizar la verificaci√≥n de manera eficiente, ignorando las diferencias entre may√∫sculas y min√∫sculas.

</details>

> [!TIP] 
>
> El programa podr√≠a simplificarse usando `tolower` de la biblioteca `<cctype>`, que convierte autom√°ticamente las letras a min√∫sculas, haciendo el c√≥digo m√°s limpio y eficiente:
> ```c++
>#include <iostream>
>#include <string>
>#include <cctype> // Para usar tolower
>
>using namespace std;
>
>int main() {
>    string palabra;
>    char letra;
>
>    cout << "Ingresa una palabra: "; cin >> palabra;
>    cout << "Ingresa una letra para verificar si la palabra comienza con ella: "; cin >> letra;
>    if (tolower(palabra[0]) == tolower(letra)) {
>        cout << "¬°La palabra comienza con la letra '" << letra << "'!" << endl;
>    }
>    cout << "Verificaci√≥n completada." << endl;
>
>    return 0;
>}
>```

---

## **Estructura de Selecci√≥n `if-else`**

La estructura `if-else` permite ejecutar bloques de c√≥digo basados en una condici√≥n espec√≠fica. Si la condici√≥n es verdadera, se ejecuta el bloque `if`; de lo contrario, se ejecuta el bloque `else`.

### Sintaxis: <!-- omit in toc -->

```cpp
if (condici√≥n) {
    // Bloque de c√≥digo que se ejecuta si la condici√≥n es verdadera
} else {
    // Bloque de c√≥digo que se ejecuta si la condici√≥n es falsa
}
```

### Ejemplo 1: <!-- omit in toc -->

```cpp
// Proyecto: EstructurasDeControl
// Archivo: verificaPositivo.cpp
// Este programa eval√∫a si un n√∫mero ingresado por el usuario es positivo, negativo o cero,
// utilizando una estructura de control condicional (if-else).
// Autor: Profesorcito
// Fecha: 28/ene/2025

#include <iostream>

using namespace std;

int main() {
    int numero;
    cout << "Ingrese un n√∫mero: ";
    cin >> numero;
    
    if (numero > 0) {
        cout << "El n√∫mero es positivo." << endl;
    } else {
        cout << "El n√∫mero es negativo o cero." << endl;
    }
    
    return 0;
}
```

**Salida:**
```cpp
Ingrese un n√∫mero: 5
El n√∫mero es positivo.
```

<details><summary>üë®‚Äçüè´ Explicaci√≥n</summary>

Este programa verifica si un n√∫mero ingresado por el usuario es positivo, negativo o cero utilizando una estructura de control condicional `if-else`. A continuaci√≥n, se explican algunos conceptos clave:

1. **Evaluaci√≥n de la condici√≥n (`numero > 0`)**:
   - Si el n√∫mero ingresado es mayor que 0, el programa imprime que es positivo.
   - Si la condici√≥n no se cumple, se ejecuta el bloque `else`, indicando que el n√∫mero es negativo o cero.

2. **Entrada y salida de datos (`cin` y `cout`)**:
   - `cin >> numero;` permite ingresar un valor desde el teclado.
   - `cout <<` muestra los mensajes al usuario.

3. **Estructura `if-else`**:
   - Si la condici√≥n del `if` es verdadera, ejecuta el bloque de c√≥digo dentro de `{}`.
   - Si la condici√≥n es falsa, se ejecuta el bloque dentro de `else`.
</details>
  
> [!NOTE]
> 
> Esta estructura es esencial en la programaci√≥n para la toma de decisiones en tiempo de ejecuci√≥n.

---

### Ejemplo 2: <!-- omit in toc -->

```cpp
// Proyecto: EstructurasDeControl
// Archivo: verificaAprobado.cpp
// Este programa determina si un estudiante ha aprobado o reprobado un curso
// en funci√≥n de la calificaci√≥n ingresada, utilizando una estructura de control condicional (if-else).
// Autor: Profesorcito
// Fecha: 28/ene/2025

#include <iostream>

using namespace std;

int main() {
    int grade;
    cout << "Ingrese la calificaci√≥n: ";
    cin >> grade;
    
    if (grade >= 50) {
        cout << "Aprobado" << endl;
    } else {
        cout << "Reprobado" << endl;
        cout << "Debe repetir el curso" << endl;
    }
    
    return 0;
}
```

**Salida:**
```cpp
Ingrese la calificaci√≥n: 65
Aprobado
```

<details><summary>üë®‚Äçüè´ Explicaci√≥n</summary>

Este programa verifica si un estudiante ha aprobado o reprobado un curso utilizando una estructura de control condicional `if-else`. A continuaci√≥n, se explican algunos conceptos clave:

1. **Evaluaci√≥n de la condici√≥n (`grade >= 50`)**:
   - Si la calificaci√≥n ingresada es 50 o superior, el programa imprime "Aprobado".
   - Si la condici√≥n no se cumple, se ejecuta el bloque `else`, indicando "Reprobado" y que el estudiante debe repetir el curso.

2. **Entrada y salida de datos (`cin` y `cout`)**:
   - `cin >> grade;` permite ingresar un valor desde el teclado.
   - `cout <<` muestra los mensajes al usuario.

3. **Estructura `if-else`**:
   - Si la condici√≥n del `if` es verdadera, ejecuta el bloque de c√≥digo dentro de `{}`.
   - Si la condici√≥n es falsa, se ejecuta el bloque dentro de `else`.

</details>

---

### Ejemplo 3: <!-- omit in toc -->

Obtener la edad y la calificaci√≥n de un candidato, y determinar si ha aprobado el examen. Se utilizan los siguientes criterios:

- Candidatos entre 0 y 14 a√±os necesitan una calificaci√≥n m√≠nima de 50%.
- Candidatos de 15 y 16 a√±os necesitan una calificaci√≥n m√≠nima de 55%.
- Candidatos mayores de 16 a√±os necesitan una calificaci√≥n m√≠nima de 60%.

```cpp
// Proyecto: EstructurasDeControl
// Archivo: verificaCandidato.cpp
// Este programa solicita la edad y la calificaci√≥n de un candidato
// y determina si ha aprobado o reprobado el examen seg√∫n su edad.
// Autor: Profesorcito
// Fecha: 28/ene/2025

#include <iostream>

using namespace std;

int main() {
    int edad, calificacion;
    
    cout << "Ingrese la edad del candidato: ";
    cin >> edad;
    cout << "Ingrese la calificaci√≥n del candidato: ";
    cin >> calificacion;
    
    if (edad <= 14 && calificacion >= 50)
        cout << "El candidato ha aprobado el examen." << endl;
    else if (edad <= 16 && calificacion >= 55)
        cout << "El candidato ha aprobado el examen." << endl;
    else if (calificacion >= 60)
        cout << "El candidato ha aprobado el examen." << endl;
    else
        cout << "El candidato ha reprobado el examen." << endl;
    
    return 0;
}
```

**Salida:**
```cpp
Ingrese la edad del candidato: 15
Ingrese la calificaci√≥n del candidato: 56
El candidato ha aprobado el examen.
```

<details><summary>üë®‚Äçüè´ Explicaci√≥n</summary>

Este programa eval√∫a si un candidato ha aprobado un examen en funci√≥n de su edad y calificaci√≥n. Se utilizan estructuras de control condicional `if-else` para definir los criterios de aprobaci√≥n:

1. **Condiciones de aprobaci√≥n**:
   - Candidatos de 0 a 14 a√±os necesitan una calificaci√≥n m√≠nima de 50%.
   - Candidatos de 15 a 16 a√±os necesitan al menos 55%.
   - Candidatos mayores de 16 a√±os requieren un m√≠nimo de 60%.

2. **Entrada y salida de datos (`cin` y `cout`)**:
   - `cin >> edad;` permite ingresar la edad del candidato.
   - `cin >> calificacion;` permite ingresar la calificaci√≥n.
   - `cout <<` muestra los mensajes al usuario.

3. **Estructura `if-else`**:
   - Se eval√∫an las condiciones de edad y calificaci√≥n de manera secuencial con `if`, `else if`, y `else`.
   - Si se cumple alguna condici√≥n de aprobaci√≥n, se muestra un mensaje indicando que el candidato ha aprobado.
   - Si no se cumple ninguna, se informa que el candidato ha reprobado.

</details>

>[!TIP]  
>
>El operador ternario `?:` permite escribir `if-else` en una sola l√≠nea:  
>
>```cpp
>int menor = (a < b) ? a : b;
>```
>Si `a < b`, asigna `a`; de lo contrario, asigna `b`. √ötil para expresiones simples, pero evita usarlo en condiciones complejas para mantener la claridad del c√≥digo. [üè¥‚Äç‚ò†Ô∏è](https://gist.githubusercontent.com/yoanpinzon/fcf48e4a9513396412fb559d2188bc8b/raw/62ae4ee7a61c00cad776d3f0b98af9effd04d05e/main.cpp)
>

---



## **Estructura `switch`**

La estructura `switch` permite ejecutar diferentes bloques de c√≥digo seg√∫n el valor de una variable de selecci√≥n.

### Sintaxis: <!-- omit in toc -->

```cpp
switch (selector) {
    case etiqueta1: instrucci√≥n1;
        break;
    ...
    case etiquetaN: instrucci√≥nN;
        break;
    default: instrucci√≥nPorDefecto;
}
```

### Ejemplo: <!-- omit in toc -->

Obtener la calificaci√≥n de un candidato. Si la calificaci√≥n es 0, 1, 2, 3 o 4, imprimir "Has reprobado". Si la calificaci√≥n es 5, imprimir "Puedes mejorar". Si la calificaci√≥n es 6 o 7, imprimir "Has hecho un buen trabajo". Finalmente, si la calificaci√≥n es 8, 9 o 10, imprimir "¬°Muy bien!".

```cpp
// Proyecto: EstructurasDeControl
// Archivo: evaluacionCalificacion.cpp
// Este programa eval√∫a la calificaci√≥n de un candidato y muestra un mensaje correspondiente.
// Autor: Profesorcito
// Fecha: 28/ene/2025

#include <iostream>

using namespace std;

int main() {
    int calificacion;
    
    cout << "Ingrese la calificaci√≥n: ";
    cin >> calificacion;
    
    switch (calificacion) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
            cout << "Has reprobado." << endl;
            break;
        case 5:
            cout << "Puedes mejorar." << endl;
            break;
        case 6:
        case 7:
            cout << "Has hecho un buen trabajo." << endl;
            break;
        case 8:
        case 9:
        case 10:
            cout << "¬°Muy bien!" << endl;
            break;
        default:
            cout << "Calificaci√≥n incorrecta." << endl;
    }
        
    return 0;
}
```

**Salida:**
```cpp
Ingrese la calificaci√≥n: 7
Has hecho un buen trabajo.
```

<details><summary>üë®‚Äçüè´ Explicaci√≥n</summary>

Este programa eval√∫a la calificaci√≥n de un candidato y muestra un mensaje correspondiente basado en su desempe√±o. Se utiliza la estructura de selecci√≥n m√∫ltiple `switch` para asignar diferentes mensajes seg√∫n la calificaci√≥n ingresada.

1. **Condiciones de evaluaci√≥n**:
   - Si la calificaci√≥n es 0, 1, 2, 3 o 4, el candidato ha reprobado.
   - Si la calificaci√≥n es 5, el mensaje sugiere que puede mejorar.
   - Si la calificaci√≥n es 6 o 7, el mensaje indica que ha hecho un buen trabajo.
   - Si la calificaci√≥n es 8, 9 o 10, se muestra un mensaje de felicitaci√≥n.

2. **Entrada y salida de datos (`cin` y `cout`)**:
   - `cin >> calificacion;` permite ingresar la calificaci√≥n desde el teclado.
   - `cout <<` muestra los mensajes seg√∫n el valor ingresado.

3. **Estructura `switch`**:
   - Cada caso representa un rango de calificaciones con una respuesta espec√≠fica.
   - Se usa `break;` despu√©s de cada instrucci√≥n para evitar que se ejecuten casos no deseados.
   - El `default` maneja cualquier valor fuera del rango esperado, indicando una calificaci√≥n incorrecta.

</details>

> [!NOTE]  
>
> Mucha gente tiene dificultades para entender c√≥mo funciona la estructura `switch`, especialmente cuando varios `case` est√°n agrupados sin un `break` intermedio. En este ejemplo, los casos `0, 1, 2, 3 y 4` est√°n agrupados porque todos imprimen "Has reprobado.". Al no haber `break` entre ellos, el flujo de ejecuci√≥n contin√∫a hasta el `break;` final de ese bloque, ejecutando la misma instrucci√≥n para todos esos valores.

---

# **üëΩ Tarea - Estacionamiento Intergal√°ctico**

## **üì¢üö® FECHA L√çMITE: 10 de FEBRERO - 10:00 AM üö®üì¢** <!-- omit in toc --> 
‚ö†Ô∏è **ENTREGAS FUERA DE TIEMPO NO SER√ÅN ACEPTADAS.**  
‚úÖ **Haz `commit` y `push` antes del plazo y verifica tu entrega en GitHub Classroom.**


## **üìñ Historia**  <!-- omit in toc -->
En el a√±o 3025, los pilotos espaciales que visitan **Marte** deben pagar tarifas de estacionamiento en los **Puertos Orbitales de la Federaci√≥n Gal√°ctica**.  

El **Consejo de Comercio Espacial** ha establecido un sistema de tarifas, pero debido a las variaciones en la √≥rbita marciana y el tr√°fico interplanetario, los costos cambian seg√∫n el **d√≠a del ciclo marciano** y **ciertos efectos c√≥smicos**.  

## **üìú Reglas del Estacionamiento Espacial**  <!-- omit in toc -->

### **üö¶ Tarifas Base (Lunes a Viernes - D√≠as 1 a 5)** <!-- omit in toc -->
1. **Primera √≥rbita (1 hora o menos)** ‚Üí **6 cr√©ditos gal√°cticos**  
2. **De 1 a 3 √≥rbitas** ‚Üí **4 cr√©ditos por cada √≥rbita adicional**  
3. **De 3 a 5 √≥rbitas** ‚Üí **3 cr√©ditos por cada √≥rbita adicional**  
4. **M√°s de 5 √≥rbitas** ‚Üí **Tarifa fija de 22 cr√©ditos**  

### **üåå Tarifas Especiales (Fines de Semana en Marte - D√≠as 6 y 7)** <!-- omit in toc -->
- **S√°bados y Domingos**: Las tarifas incrementan un **15%** debido a la alta demanda.

### **üõ∏ Factores C√≥smicos (Eventos Aleatorios del Universo)** <!-- omit in toc -->
1. **Si la suma de los d√≠gitos del n√∫mero de √≥rbitas es un m√∫ltiplo de 3**, el piloto recibe un **descuento del 5%** gracias a la Gravedad Lunar Benefactora.  

### **‚õî Restricciones del Consejo Gal√°ctico** <!-- omit in toc -->
- **Ninguna nave puede permanecer estacionada m√°s de 24 √≥rbitas marcianas.** Si esto ocurre, el sistema debe mostrar `"ERROR"` y no calcular la tarifa.  

---

## **üìå Entrada** <!-- omit in toc -->
El programa recibir√° **una sola l√≠nea de entrada** con dos n√∫meros enteros separados por un espacio:  
- **H** *(1 ‚â§ H ‚â§ 1000)* ‚Üí Representa las √≥rbitas estacionadas.  
- **D** *(1 ‚â§ D ‚â§ 7)* ‚Üí Representa el d√≠a del ciclo marciano (**1 = Lunes, 7 = Domingo**).  

---

## **üìå Salida** <!-- omit in toc --> 
El programa debe imprimir **un √∫nico n√∫mero** con dos decimales:  
- Si **H > 24**, imprimir `"ERROR"`.  
- En caso contrario, imprimir el costo total a pagar.

---

## **üìä Ejemplo de Entrada y Salida**  <!-- omit in toc -->

### **Ejemplo 1** (D√≠a de semana sin descuentos) <!-- omit in toc -->
#### Entrada: <!-- omit in toc -->
```
2 1
```
#### Salida: <!-- omit in toc -->
```
10.00
```

---

### **Ejemplo 2** (Fin de semana con incremento) <!-- omit in toc -->
#### Entrada: <!-- omit in toc -->
```
5 6
```
#### Salida: <!-- omit in toc -->
```
23.00
```

---

### **Ejemplo 3** (Descuento por suma de d√≠gitos) <!-- omit in toc -->
#### Entrada: <!-- omit in toc -->
```
12 3
```
#### Salida: <!-- omit in toc -->
```
20.90
```

---

### **Ejemplo 4** (Error por l√≠mite excedido) <!-- omit in toc -->
#### Entrada: <!-- omit in toc -->
```
25 2
```
#### Salida: <!-- omit in toc -->
```
ERROR
```

---

## **üìú Notas del Consejo Gal√°ctico** üõ∏  <!-- omit in toc -->
- **El sistema de tarifas debe aplicar correctamente los recargos y descuentos.**  
- **Los c√°lculos deben realizarse en el orden correcto.**  
- **Los pilotos que estacionen demasiado tiempo ser√°n sancionados.**  

üöÄ **¬øEres lo suficientemente h√°bil para programar este sistema intergal√°ctico?** üõ∏  

---

## **üìå ¬øC√≥mo someter la tarea en GitHub Classroom?**   <!-- omit in toc -->
### **üìù Pasos para entregar tu c√≥digo correctamente:**  <!-- omit in toc --> 
1. **Acepta la tarea** haciendo clic en este enlace: [Assignment - Estacionamiento Intergal√°ctico](https://classroom.github.com/a/tJpLCAHZ).  
2. **Clona tu repositorio** en tu computadora con el siguiente comando (reemplaza `TU_USUARIO` con tu nombre de usuario en GitHub):  
   ```bash
   git clone https://github.com/profesorcito/tarea-1-TU_USUARIO.git
   ```
3. **Abre el proyecto en CLion** y escribe tu c√≥digo en el archivo `main.cpp`.  
4. **Verifica que tu c√≥digo compile y pase los casos de prueba.**  
5. **Guarda los cambios y s√∫belos a GitHub:**  
   ```bash
   git add .
   git commit -m "Intento 1"
   git push origin master
   ```
6. **Revisa en GitHub si tu c√≥digo se ha subido correctamente.**  
7. **Verifica los resultados en GitHub Classroom**, donde el sistema de autograding evaluar√° tu c√≥digo autom√°ticamente.  

‚ö†Ô∏è **IMPORTANTE:**  
- **No cambies el nombre del repositorio ni del archivo principal (`main.cpp`).**  
- **Aseg√∫rate de hacer `commit` y `push` antes de la fecha l√≠mite.**  
- **Si encuentras errores en el autograder, revisa tu salida y aj√∫stala seg√∫n los ejemplos dados.**  

---

### **üíª Esqueleto del C√≥digo en C++ (Incompleto para que los estudiantes lo completen)**  <!-- omit in toc -->
```cpp
#include <iostream>

using namespace std;

// TODO: Implementar funci√≥n para calcular la suma de los d√≠gitos de un n√∫mero
int sumaDigitos(int n) {
    // Completa esta funci√≥n
}

// TODO: Implementar la l√≥gica para calcular la tarifa
double calcularTarifa(int horas, int dia) {
    const double TARIFA_PRIMERA_HORA = 6.00;
    const double TARIFA_1_A_3 = 4.00;
    const double TARIFA_3_A_5 = 3.00;
    const double TARIFA_FIJA = 22.00;
    const int LIMITE_HORAS = 24;
    const double INCREMENTO_FIN_SEMANA = 1.15;
    const double DESCUENTO_DIGITOS = 0.95;

    // Validar l√≠mite de horas
    if (horas > LIMITE_HORAS) {
        return -1;
    }

    double totalPagar = 0.0;

    // TODO: Implementar la l√≥gica para calcular la tarifa base
    if (horas == 1) {
        // Completa aqu√≠
    } else if (horas > 1 && horas <= 3) {
        // Completa aqu√≠
    } else if (horas > 3 && horas <= 5) {
        // Completa aqu√≠
    } else {
        // Completa aqu√≠
    }

    // TODO: Aplicar incremento si es fin de semana
    if (/* Completa esta condici√≥n */) {
        totalPagar *= INCREMENTO_FIN_SEMANA;
    }

    // TODO: Aplicar descuento si la suma de los d√≠gitos es m√∫ltiplo de 3
    if (/* Completa esta condici√≥n */) {
        totalPagar *= DESCUENTO_DIGITOS;
    }

    return totalPagar;
}

int main() {
    int horas, dia;

    // Leer los valores de entrada
    cin >> horas >> dia;

    double resultado = calcularTarifa(horas, dia);
    if (resultado == -1) {
        cout << "ERROR" << endl;
    } else {
        printf("%.2f\n", resultado);
    }

    return 0;
}
```

---

## **üìå ¬øQu√© debes hacer?** <!-- omit in toc -->
1. **Completar la funci√≥n `sumaDigitos()`** para calcular la suma de los d√≠gitos de un n√∫mero.  
2. **Completar la l√≥gica dentro de `calcularTarifa()`** para determinar el costo base seg√∫n el tiempo estacionado.  
3. **Rellenar la condici√≥n para aplicar el recargo de fin de semana** (`D == 6` o `D == 7`).  
4. **Rellenar la condici√≥n para aplicar el descuento cuando la suma de los d√≠gitos de `H` sea m√∫ltiplo de 3**.  
5. **Probar su c√≥digo con los ejemplos de entrada/salida para verificar que funcione correctamente.**  

---
