
---

# ğŸ’» 300CIS017 ProgramaciÃ³n Orientada a Objetos 2025-01  <!-- omit in toc -->
![Version](https://img.shields.io/badge/version-1.0-blue)
[![License: CC BY-NC-ND 4.0](https://img.shields.io/badge/License-CC%20BY--NC--ND%204.0-lightgrey.svg?color=#007ec6)](https://creativecommons.org/licenses/by-nc-nd/4.0/)

---


# ğŸŒŸ Tema 2: El lenguaje C++ - Parte 2<!-- omit in toc -->

---

### ğŸ¥ Videos que inspiraron este tema:

<table style="border-collapse: collapse; width: 100%; border: none; margin: 10px 0;">
  <tr>
    <td style="text-align: center; padding: 5px; border: none;">
      <a href="https://www.youtube.com/watch?v=Hh9yZWeTmVM">
        <img src="img/vid4.png" alt="The Beginning - OOR" width="150">
      </a>
      <br>
      <span style="font-size: 12px; margin-top: 5px; display: inline-block;">The Beginning<br>OOR</span>
    </td>
    <td style="text-align: center; padding: 5px; border: none;">
      <a href="https://www.youtube.com/watch?v=Ibp_y21LHJY">
        <img src="img/vid5.png" alt="Push Back - OOR" width="150">
      </a>
      <br>
      <span style="font-size: 12px; margin-top: 5px; display: inline-block;">Push Back<br>OOR</span>
    </td>
  </tr>
</table>

---

### ğŸ’» Creado por   

Profesorcito Â© 2025

---

### ğŸ¶ Dedicado a 

[Takahiro Moriuchi](https://es.wikipedia.org/wiki/Takahiro_Moriuchi) (Taka) ğŸ¤

---

En este capÃ­tulo, aprenderemos sobre **bucles (`for`, `while`, `do-while`)**, **arreglos**, **punteros**, **referencias**, **funciones** y **asignaciÃ³n dinÃ¡mica de memoria**, conceptos clave para escribir cÃ³digo eficiente y estructurado. ğŸš€

---

### **Tabla de Contenido**

- [1. **Estructuras de RepeticiÃ³n**](#1-estructuras-de-repeticiÃ³n)
  - [**El bucle `for`**](#el-bucle-for)
    - [ğŸš€ **Ejemplo 1: Imprimir nÃºmeros del 1 al 5**](#-ejemplo-1-imprimir-nÃºmeros-del-1-al-5)
    - [ğŸš€ **Ejemplo 2: Contador en decremento**](#-ejemplo-2-contador-en-decremento)
    - [ğŸš€ **Ejemplo 3: Recorrer un array**](#-ejemplo-3-recorrer-un-array)
    - [ğŸš€ **Ejemplo 4: Tabla de multiplicar**](#-ejemplo-4-tabla-de-multiplicar)
    - [ğŸš€ **Ejemplo 5: Bucle infinito con `for`**](#-ejemplo-5-bucle-infinito-con-for)
    - [ğŸš€ **Ejemplo 6: Imprimir un triÃ¡ngulo de asteriscos con `for` anidados**](#-ejemplo-6-imprimir-un-triÃ¡ngulo-de-asteriscos-con-for-anidados)
  - [**El bucle `while`**](#el-bucle-while)
    - [ğŸš€ **Ejemplo 1: Contador del 1 al 5**](#-ejemplo-1-contador-del-1-al-5)
    - [ğŸš€ **Ejemplo 2: Cuenta regresiva**](#-ejemplo-2-cuenta-regresiva)
    - [ğŸš€ **Ejemplo 3: Leer hasta que el usuario ingrese un nÃºmero positivo**](#-ejemplo-3-leer-hasta-que-el-usuario-ingrese-un-nÃºmero-positivo)
    - [ğŸš€ **Ejemplo 4: Sumar valores ingresados por el usuario**](#-ejemplo-4-sumar-valores-ingresados-por-el-usuario)
    - [ğŸš€ **Ejemplo 5: Bucle infinito con `while`**](#-ejemplo-5-bucle-infinito-con-while)
  - [**El bucle `do-while`**](#el-bucle-do-while)
    - [ğŸš€ **Ejemplo 1: Validar entrada de usuario (BÃ¡sico y Ãºtil)**](#-ejemplo-1-validar-entrada-de-usuario-bÃ¡sico-y-Ãºtil)
    - [ğŸš€ **Ejemplo 2: Simulador de menÃº interactivo**](#-ejemplo-2-simulador-de-menÃº-interactivo)
  - [ğŸ§© **Problemas de Bucles Propuestos en C++**](#-problemas-de-bucles-propuestos-en-c)
  - [**Instrucciones `break` y `continue`**](#instrucciones-break-y-continue)
    - [ğŸš€ **Ejemplo 1: Uso de `break` (Sumar solo valores positivos)**](#-ejemplo-1-uso-de-break-sumar-solo-valores-positivos)
    - [ğŸš€ **Ejemplo 2: Uso de `continue` (Imprimir valores del 1 al 10, omitiendo el 5)**](#-ejemplo-2-uso-de-continue-imprimir-valores-del-1-al-10-omitiendo-el-5)
- [2. **Arreglos**](#2-arreglos)
  - [**DeclaraciÃ³n de un arreglo**](#declaraciÃ³n-de-un-arreglo)
  - [**InicializaciÃ³n de arreglos**](#inicializaciÃ³n-de-arreglos)
    - [ğŸš€ **Ejemplo 1: Suma de dos matrices en C++**](#-ejemplo-1-suma-de-dos-matrices-en-c)
  - [ğŸ§© **Problemas de Arreglos Propuestos en C++**](#-problemas-de-arreglos-propuestos-en-c)
- [3. **Punteros**](#3-punteros)
    - [**Ejemplo bÃ¡sico**](#ejemplo-bÃ¡sico)
  - [**AritmÃ©tica de punteros**](#aritmÃ©tica-de-punteros)
    - [**Operaciones bÃ¡sicas de aritmÃ©tica de punteros**](#operaciones-bÃ¡sicas-de-aritmÃ©tica-de-punteros)
    - [**Otras operaciones con punteros**](#otras-operaciones-con-punteros)
  - [ğŸ§© **Problemas de Punteros Propuestos en C++**](#-problemas-de-punteros-propuestos-en-c)
- [4. **Referencias**](#4-referencias)
    - [ğŸš€ **Ejemplo 1: Referencia a una variable**](#-ejemplo-1-referencia-a-una-variable)
  - [**Referencias constantes (`const &`)**](#referencias-constantes-const-)
    - [ğŸš€ **Ejemplo 2: Uso de `const &`**](#-ejemplo-2-uso-de-const-)
  - [**ComparaciÃ³n entre referencias y punteros**](#comparaciÃ³n-entre-referencias-y-punteros)
- [5. **Funciones**](#5-funciones)
    - [**Ejemplo bÃ¡sico**](#ejemplo-bÃ¡sico-1)
  - [**MÃ©todos de paso de argumentos**](#mÃ©todos-de-paso-de-argumentos)
    - [**Paso por valor**](#paso-por-valor)
    - [**Paso por referencia con punteros**](#paso-por-referencia-con-punteros)
    - [**Paso por referencia con referencias**](#paso-por-referencia-con-referencias)
  - [ğŸ§© **Problemas de Funciones Propuestos en C++**](#-problemas-de-funciones-propuestos-en-c)
- [6. **AsignaciÃ³n dinÃ¡mica de memoria en C++**](#6-asignaciÃ³n-dinÃ¡mica-de-memoria-en-c)
  - [**AsignaciÃ³n de memoria dinÃ¡mica**](#asignaciÃ³n-de-memoria-dinÃ¡mica)
  - [**LiberaciÃ³n de memoria dinÃ¡mica**](#liberaciÃ³n-de-memoria-dinÃ¡mica)
  - [**Ejemplo completo: Promedios de estudiantes (Memoria dinÃ¡mica)**](#ejemplo-completo-promedios-de-estudiantes-memoria-dinÃ¡mica)
  - [**VersiÃ³n estÃ¡tica (TamaÃ±o fijo del array)**](#versiÃ³n-estÃ¡tica-tamaÃ±o-fijo-del-array)
- [**ğŸ§® Tarea 2 - Reto C++**](#-tarea-2---reto-c)

---

# 1. **Estructuras de RepeticiÃ³n**  

En programaciÃ³n, los **bucles** ğŸ”„ permiten repetir instrucciones sin escribirlas mÃºltiples veces. En C++, existen **tres tipos de bucles** fundamentales:  

## **El bucle `for`**  

Se usa cuando **se conoce de antemano** cuÃ¡ntas veces debe repetirse la ejecuciÃ³n del bloque de cÃ³digo.  

### Sintaxis: <!-- omit in toc -->  

```cpp
for (inicializaciÃ³n; condiciÃ³n; actualizaciÃ³n) {
    // Bloque de cÃ³digo que se ejecuta en cada iteraciÃ³n
}
```  

ğŸ“Œ **ExplicaciÃ³n de cada parte:**  
1. **InicializaciÃ³n**: Se ejecuta una sola vez al inicio del bucle. Se usa para definir y asignar un valor inicial a una variable de control.  
2. **CondiciÃ³n**: Se evalÃºa antes de cada iteraciÃ³n. Si es `true`, el bloque de cÃ³digo se ejecuta; si es `false`, el bucle termina.  
3. **ActualizaciÃ³n**: Se ejecuta al final de cada iteraciÃ³n y suele modificar la variable de control.  

---

### ğŸš€ **Ejemplo 1: Imprimir nÃºmeros del 1 al 5**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 1; i <= 5; i++) {  // i inicia en 1, se detiene cuando i > 5, y se incrementa en 1
        cout << "Valor: " << i << endl;
    }
    return 0;
}
```  

ğŸ“Œ **Salida:**  
```
Valor: 1
Valor: 2
Valor: 3
Valor: 4
Valor: 5
```  

---

### ğŸš€ **Ejemplo 2: Contador en decremento**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 10; i >= 1; i--) {  // i inicia en 10 y va decreciendo hasta 1
        cout << "Cuenta regresiva: " << i << endl;
    }
    return 0;
}
```  

ğŸ“Œ **Salida:**  
```
Cuenta regresiva: 10
Cuenta regresiva: 9
Cuenta regresiva: 8
Cuenta regresiva: 7
Cuenta regresiva: 6
Cuenta regresiva: 5
Cuenta regresiva: 4
Cuenta regresiva: 3
Cuenta regresiva: 2
Cuenta regresiva: 1
```  

---

### ğŸš€ **Ejemplo 3: Recorrer un array**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numeros[] = {3, 7, 1, 9, 5};
    int tamaÃ±o = sizeof(numeros) / sizeof(numeros[0]); // Calcula el tamaÃ±o del array

    for (int i = 0; i < tamaÃ±o; i++) {  // Recorre el array usando su tamaÃ±o
        cout << "Elemento " << i << ": " << numeros[i] << endl;
    }
    return 0;
}
```  

ğŸ“Œ **Salida:**  
```
Elemento 0: 3
Elemento 1: 7
Elemento 2: 1
Elemento 3: 9
Elemento 4: 5
```  

---

### ğŸš€ **Ejemplo 4: Tabla de multiplicar**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Introduce un nÃºmero: ";
    cin >> n;

    for (int i = 1; i <= 10; i++) {
        cout << n << " x " << i << " = " << (n * i) << endl;
    }

    return 0;
}
```  

ğŸ“Œ **Salida si el usuario ingresa `7`:**  
```
7 x 1 = 7
7 x 2 = 14
7 x 3 = 21
7 x 4 = 28
7 x 5 = 35
7 x 6 = 42
7 x 7 = 49
7 x 8 = 56
7 x 9 = 63
7 x 10 = 70
```  

---

### ğŸš€ **Ejemplo 5: Bucle infinito con `for`**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (;;) {  // No hay inicializaciÃ³n, condiciÃ³n ni actualizaciÃ³n
        cout << "Esto es un bucle infinito!" << endl;
    }
    return 0;
}
```  

ğŸ“Œ **Esto imprimirÃ¡ el mensaje infinitamente hasta que detengas el programa manualmente (`Ctrl + C` en consola).**  

---

### ğŸš€ **Ejemplo 6: Imprimir un triÃ¡ngulo de asteriscos con `for` anidados**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int filas;

    cout << "Introduce el nÃºmero de filas: ";
    cin >> filas;

    for (int i = 1; i <= filas; i++) {  // Controla las filas
        for (int j = 1; j <= i; j++) {  // Controla la cantidad de asteriscos por fila
            cout << "* ";
        }
        cout << endl;  // Salto de lÃ­nea para la siguiente fila
    }

    return 0;
}
```  

ğŸ“Œ **Salida si el usuario ingresa `5`:**  
```
* 
* * 
* * * 
* * * * 
* * * * * 
```  

---

## **El bucle `while`**  

Se usa cuando **no se conoce de antemano** cuÃ¡ntas veces debe repetirse la ejecuciÃ³n del bloque de cÃ³digo. El bucle continuarÃ¡ ejecutÃ¡ndose **mientras una condiciÃ³n sea verdadera**.

### Sintaxis: <!-- omit in toc -->

```cpp
while (condiciÃ³n) {
    // Bloque de cÃ³digo que se ejecuta en cada iteraciÃ³n
}
```

ğŸ“Œ **ExplicaciÃ³n de cada parte:**  
1. **CondiciÃ³n**: Se evalÃºa antes de cada iteraciÃ³n. Si es `true`, el bloque de cÃ³digo se ejecuta; si es `false`, el bucle termina.  
2. **Bloque de cÃ³digo**: Se ejecuta una y otra vez mientras la condiciÃ³n siga siendo verdadera.  
3. **Cambio de estado**: Es necesario modificar alguna variable dentro del bucle para que eventualmente la condiciÃ³n sea `false`, evitando un bucle infinito.  

---

### ğŸš€ **Ejemplo 1: Contador del 1 al 5**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int contador = 1;  // Se inicia el contador en 1

    while (contador <= 5) {  // Se ejecuta mientras contador sea menor o igual a 5
        cout << "Valor: " << contador << endl;
        contador++;  // Se incrementa el contador en 1
    }

    return 0;
}
```

ğŸ“Œ **Salida:**
```
Valor: 1
Valor: 2
Valor: 3
Valor: 4
Valor: 5
```

---

### ğŸš€ **Ejemplo 2: Cuenta regresiva**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int contador = 10;

    while (contador >= 1) {  // Se ejecuta mientras contador sea mayor o igual a 1
        cout << "Cuenta regresiva: " << contador << endl;
        contador--;  // Se decrementa en 1
    }

    return 0;
}
```

ğŸ“Œ **Salida:**
```
Cuenta regresiva: 10
Cuenta regresiva: 9
...
Cuenta regresiva: 1
```

---

### ğŸš€ **Ejemplo 3: Leer hasta que el usuario ingrese un nÃºmero positivo**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numero;

    cout << "Ingresa un nÃºmero positivo: ";
    cin >> numero;

    while (numero <= 0) {  // Se repite mientras el nÃºmero sea negativo o cero
        cout << "El nÃºmero no es positivo. Intenta de nuevo: ";
        cin >> numero;
    }

    cout << "NÃºmero vÃ¡lido ingresado: " << numero << endl;
    return 0;
}
```

ğŸ“Œ **Ejemplo de entrada y salida:**  
```
Ingresa un nÃºmero positivo: -3
El nÃºmero no es positivo. Intenta de nuevo: 0
El nÃºmero no es positivo. Intenta de nuevo: 7
NÃºmero vÃ¡lido ingresado: 7
```

---

### ğŸš€ **Ejemplo 4: Sumar valores ingresados por el usuario**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int suma = 0, num;

    cout << "Ingresa nÃºmeros para sumar (0 para terminar): ";

    while (true) {  // Se repite hasta que el usuario ingrese 0
        cin >> num;
        if (num == 0) {
            break;  // Sale del bucle cuando el usuario ingresa 0
        }
        suma += num;
    }

    cout << "Suma total: " << suma << endl;
    return 0;
}
```

ğŸ“Œ **Ejemplo de entrada y salida:**  
```
Ingresa nÃºmeros para sumar (0 para terminar): 5
10
-2
3
0
Suma total: 16
```

---

### ğŸš€ **Ejemplo 5: Bucle infinito con `while`**  

```cpp
#include <iostream>
using namespace std;

int main() {
    while (true) {  // No hay condiciÃ³n de salida
        cout << "Esto es un bucle infinito!" << endl;
    }
    return 0;
}
```

ğŸ“Œ **Esto imprimirÃ¡ el mensaje infinitamente hasta que detengas el programa manualmente (`Ctrl + C` en consola).**  

---

## **El bucle `do-while`**  

Es similar al `while`, pero **siempre ejecuta al menos una vez** el bloque de cÃ³digo antes de evaluar la condiciÃ³n.

### Sintaxis: <!-- omit in toc -->

```cpp
do {
   // CÃ³digo a ejecutar en cada iteraciÃ³n
} while (condiciÃ³n);
```

ğŸ“Œ **ExplicaciÃ³n de cada parte:**  
1. **Bloque de cÃ³digo**: Se ejecuta **una vez antes de evaluar** la condiciÃ³n.  
2. **CondiciÃ³n**: Se evalÃºa despuÃ©s de la primera ejecuciÃ³n. Si es `true`, el bucle continÃºa; si es `false`, el bucle termina.  

---

### ğŸš€ **Ejemplo 1: Validar entrada de usuario (BÃ¡sico y Ãºtil)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numero;

    do {
        cout << "Ingresa un nÃºmero positivo: ";
        cin >> numero;

        if (numero <= 0) {
            cout << "Error: el nÃºmero debe ser positivo." << endl;
        }

    } while (numero <= 0);  // Repite mientras el nÃºmero no sea positivo

    cout << "NÃºmero vÃ¡lido ingresado: " << numero << endl;
    return 0;
}
```

ğŸ“Œ **Ejemplo de entrada y salida:**  
```
Ingresa un nÃºmero positivo: -4
Error: el nÃºmero debe ser positivo.
Ingresa un nÃºmero positivo: 0
Error: el nÃºmero debe ser positivo.
Ingresa un nÃºmero positivo: 7
NÃºmero vÃ¡lido ingresado: 7
```

> [!TIP]  
> Te estarÃ¡s preguntando cuÃ¡ndo se usa `do-while` o por quÃ© existe en primer lugar. La razÃ³n es que garantiza que el usuario vea el mensaje al menos una vez, sin importar la condiciÃ³n. AdemÃ¡s, si el usuario ingresa un valor correcto desde el inicio, el bucle solo se ejecuta una vez, evitando iteraciones innecesarias.

---

### ğŸš€ **Ejemplo 2: Simulador de menÃº interactivo**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int opcion;

    do {
        // Mostrar opciones
        cout << "\nMENÃš DE OPCIONES" << endl;
        cout << "1. Saludar" << endl;
        cout << "2. Mostrar fecha" << endl;
        cout << "3. Salir" << endl;
        cout << "Selecciona una opciÃ³n: ";
        cin >> opcion;

        // Ejecutar la opciÃ³n seleccionada
        switch (opcion) {
            case 1:
                cout << "Â¡Hola! Espero que estÃ©s teniendo un gran dÃ­a." << endl;
                break;
            case 2:
                cout << "Hoy es un gran dÃ­a para programar en C++." << endl;
                break;
            case 3:
                cout << "Saliendo del programa..." << endl;
                break;
            default:
                cout << "OpciÃ³n no vÃ¡lida, intenta de nuevo." << endl;
        }

    } while (opcion != 3);  // Repite mientras el usuario no seleccione "Salir"

    return 0;
}
```

ğŸ“Œ **Ejemplo de entrada y salida:**  
```
MENÃš DE OPCIONES
1. Saludar
2. Mostrar fecha
3. Salir
Selecciona una opciÃ³n: 1
Â¡Hola! Espero que estÃ©s teniendo un gran dÃ­a.

MENÃš DE OPCIONES
1. Saludar
2. Mostrar fecha
3. Salir
Selecciona una opciÃ³n: 2
Hoy es un gran dÃ­a para programar en C++.

MENÃš DE OPCIONES
1. Saludar
2. Mostrar fecha
3. Salir
Selecciona una opciÃ³n: 3
Saliendo del programa...
```

---

## ğŸ§© **Problemas de Bucles Propuestos en C++**  

---

### ğŸ… **Problema bucle01: Suma** | ğŸ›¡ï¸ **Novato** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Suma todos los nÃºmeros del `1` hasta `n`.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa un nÃºmero: 5
La suma es: 15
```  

> [!TIP]
> Usa un `for` para recorrer y acumular la suma.  

---

### ğŸ… **Problema bucle02: DÃ­gitos** | âš”ï¸ **Guerrero** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Cuenta cuÃ¡ntos dÃ­gitos tiene un nÃºmero entero.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa un nÃºmero: 12345
Tiene 5 dÃ­gitos.
```  

> [!TIP]
> Divide entre `10` en un `while` hasta que sea `0`.  

---

### ğŸ… **Problema bucle03: Adivina el NÃºmero** | âš”ï¸ **Guerrero** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Genera un nÃºmero aleatorio del `1` al `100`. El usuario debe adivinarlo con pistas.  

ğŸ“Œ **Ejemplo:**  
```
Adivina el nÃºmero (1-100): 50
Es mayor. Intenta de nuevo: 75
Es menor. Intenta de nuevo: 63
Â¡Correcto!
```  

> [!TIP]
> Usa `rand()` y un `do-while` para repetir intentos.  

---

### ğŸ… **Problema bucle04: PirÃ¡mide de NÃºmeros** | ğŸ”¥ **Experto** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Imprime una pirÃ¡mide de nÃºmeros con `n` filas.  

ğŸ“Œ **Ejemplo si `n = 5`:**  
```
    1
   121
  12321
 1234321
123454321
```  

> [!TIP]
> Usa `for` anidados para manejar espacios y nÃºmeros.  

---

### ğŸ… **Problema bucle05: NÃºmeros Primos** | ğŸ‘‘ **Leyenda** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Verifica si un nÃºmero es **primo** o **compuesto**.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa un nÃºmero: 17
Es primo.
```  

> [!TIP]
> Usa un `for` para contar divisores.  

---

## **Instrucciones `break` y `continue`**  

En C++, las instrucciones `break` y `continue` permiten **controlar el flujo de ejecuciÃ³n de un bucle** de manera mÃ¡s flexible.  

- **`break`**: Finaliza el bucle inmediatamente, sin importar si la condiciÃ³n del bucle sigue siendo verdadera.  
- **`continue`**: Salta el resto del cÃ³digo en la iteraciÃ³n actual y pasa directamente a la siguiente iteraciÃ³n.  

---

### ğŸš€ **Ejemplo 1: Uso de `break` (Sumar solo valores positivos)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    double suma = 0.0, valor;
    cout << "Ingresa valores uno por uno. Se sumaran mientras sean positivos." << endl;

    for (;;) { // Bucle infinito controlado con break
        cout << "Valor: ";
        cin >> valor;
        if (valor <= 0) break; // Sale del bucle si el valor es negativo o cero
        suma += valor;
    }

    cout << "Suma de los valores positivos ingresados: " << suma << endl;
    return 0;
}
```  

ğŸ“Œ **Salida:**  
```
Ingresa valores uno por uno. Se sumaran mientras sean positivos.
Valor: 5
Valor: 3.5
Valor: 10
Valor: -1
Suma de los valores positivos ingresados: 18.5
```  

---

### ğŸš€ **Ejemplo 2: Uso de `continue` (Imprimir valores del 1 al 10, omitiendo el 5)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 1; i <= 10; i++) {
        if (i == 5) continue; // Salta la impresiÃ³n del 5
        cout << "Valor: " << i << endl;
    }

    cout << "Se uso 'continue' para omitir la impresion del 5." << endl;
    return 0;
}
```  

ğŸ“Œ **Salida:**  
```
Valor: 1
Valor: 2
Valor: 3
Valor: 4
Valor: 6
Valor: 7
Valor: 8
Valor: 9
Valor: 10
Se uso 'continue' para omitir la impresion del 5.
```  

---

# 2. **Arreglos**  

Los **arreglos (arrays)** permiten **almacenar mÃºltiples valores** del mismo tipo en una sola estructura, proporcionando **acceso directo a cada elemento** mediante un Ã­ndice. Son Ãºtiles cuando se necesita manejar **grupos de datos homogÃ©neos**.  

---

## **DeclaraciÃ³n de un arreglo**  

### Sintaxis: <!-- omit in toc -->  

```cpp
tipo nombre_arreglo[tamaÃ±o];
```  

ğŸ“Œ **Ejemplo:** Declarar un **arreglo unidimensional de 5 elementos**.  

```cpp
#include <iostream>
using namespace std;

int main() {
    int i, a[5];

    // Leer 5 valores
    for (i = 0; i < 5; i++) {
        cout << "a[" << i + 1 << "]= ";
        cin >> a[i];
    }

    // Imprimir los valores en orden inverso
    cout << "Los nÃºmeros en orden inverso: ";
    for (i = 4; i >= 0; i--)
        cout << a[i] << " ";

    return 0;
}
```

ğŸ“Œ **Ejemplo de entrada y salida:**  
```
a[1]= 7  
a[2]= 2  
a[3]= 9  
a[4]= 4  
a[5]= 5  
Los nÃºmeros en orden inverso: 5 4 9 2 7  
```

---

## **InicializaciÃ³n de arreglos**  

### Sintaxis: <!-- omit in toc -->  

```cpp
tipo nombre_arreglo[fila][columna] = { {valores fila 1}, {valores fila 2}, ... };
```

ğŸ“Œ **Ejemplos:**  

```cpp
int a[2][3] = { {1,2,3}, {4,5,6} };  
int b[2][3] = { 1,2,3,4,5 };  // El Ãºltimo valor se llena con 0 automÃ¡ticamente  
int c[2][3] = { {1,2}, {4} }; // Los valores faltantes son 0  
```

ğŸ“Œ **Valores de los arreglos por fila:**  

- **Arreglo `a`**  
```
1 2 3  
4 5 6  
```

- **Arreglo `b`**  
```
1 2 3  
4 5 0  
```

- **Arreglo `c`**  
```
1 2 0  
4 0 0  
```

ğŸ“Œ **Ejemplo en cÃ³digo:**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int i, j;
    int a[2][3] = { {1,2,3}, {4,5,6} };
    int b[2][3] = { 1,2,3,4,5 };  
    int c[2][3] = { {1,2}, {4} };

    cout << "Arreglo a:" << endl;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            cout << a[i][j] << " ";
        cout << endl;
    }

    cout << "Arreglo b:" << endl;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            cout << b[i][j] << " ";
        cout << endl;
    }

    cout << "Arreglo c:" << endl;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            cout << c[i][j] << " ";
        cout << endl;
    }

    return 0;
}
```

ğŸ“Œ **Salida esperada:**  
```
Arreglo a:  
1 2 3  
4 5 6  

Arreglo b:  
1 2 3  
4 5 0  

Arreglo c:  
1 2 0  
4 0 0  
```

---

> [!IMPORTANT]
> Si necesitas una estructura mÃ¡s flexible, usa **`std::vector`** o **`std::array`** en lugar de arreglos tradicionales. Estas estructuras forman parte de la **STL (Standard Template Library)** y ofrecen mayor seguridad y funcionalidad. Para utilizarlas, es necesario incluir las librerÃ­as correspondientes: `#include <array>` para `std::array` y `#include <vector>` para `std::vector`.
>

---

### ğŸš€ **Ejemplo 1: Suma de dos matrices en C++** 

```cpp
#include <iostream>
using namespace std;

int main() {
    int filas, columnas;

    // Solicitar dimensiones de la matriz
    cout << "Ingresa el nÃºmero de filas: ";
    cin >> filas;
    cout << "Ingresa el nÃºmero de columnas: ";
    cin >> columnas;

    int matriz1[filas][columnas], matriz2[filas][columnas], resultado[filas][columnas];

    // Leer la primera matriz
    cout << "Ingresa los valores de la primera matriz:" << endl;
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            cout << "Matriz1[" << i << "][" << j << "]: ";
            cin >> matriz1[i][j];
        }
    }

    // Leer la segunda matriz
    cout << "Ingresa los valores de la segunda matriz:" << endl;
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            cout << "Matriz2[" << i << "][" << j << "]: ";
            cin >> matriz2[i][j];
        }
    }

    // Sumar ambas matrices
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            resultado[i][j] = matriz1[i][j] + matriz2[i][j];
        }
    }

    // Mostrar la matriz resultante
    cout << "Matriz resultante (suma de ambas matrices):" << endl;
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            cout << resultado[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
```

---

ğŸ“Œ **Salida:**  

```
Ingresa el nÃºmero de filas: 2  
Ingresa el nÃºmero de columnas: 2  

Ingresa los valores de la primera matriz:  
Matriz1[0][0]: 1  
Matriz1[0][1]: 2  
Matriz1[1][0]: 3  
Matriz1[1][1]: 4  

Ingresa los valores de la segunda matriz:  
Matriz2[0][0]: 5  
Matriz2[0][1]: 6  
Matriz2[1][0]: 7  
Matriz2[1][1]: 8  

Matriz resultante (suma de ambas matrices):  
6 8  
10 12  
```

## ğŸ§© **Problemas de Arreglos Propuestos en C++**  

---  

### ğŸ… **Problema arreglo01: Mayor y Menor** | ğŸ›¡ï¸ **Novato** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Lee `n` nÃºmeros y encuentra el **mayor** y el **menor** valor del arreglo.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de nÃºmeros: 5
NÃºmero 1: 8
NÃºmero 2: 3
NÃºmero 3: 15
NÃºmero 4: 7
NÃºmero 5: 10
Mayor: 15
Menor: 3
```  

> [!TIP]  
> Usa un `for` para recorrer el arreglo y comparar valores.  

---  

### ğŸ… **Problema arreglo02: Promedio de Calificaciones** | âš”ï¸ **Guerrero** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Dado un arreglo con `n` calificaciones, calcula el **promedio** y muestra cuÃ¡les estÃ¡n por encima y por debajo de la media.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de calificaciones: 4
CalificaciÃ³n 1: 80
CalificaciÃ³n 2: 90
CalificaciÃ³n 3: 75
CalificaciÃ³n 4: 85
Promedio: 82.5
Por encima del promedio: 90, 85
Por debajo del promedio: 80, 75
```  

> [!TIP]  
> Usa un `for` para sumar los valores y calcular el promedio. Luego, usa un segundo `for` para imprimir las calificaciones por encima del promedio y un tercer `for` para las calificaciones por debajo de la media.  

---  

### ğŸ… **Problema arreglo03: Matriz Transpuesta** | ğŸ”¥ **Experto** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Dada una matriz `n x m`, genera su **matriz transpuesta**, es decir, intercambia sus filas y columnas.  

ğŸ“Œ **Ejemplo:**  
```
Matriz original:
1  2  3  
4  5  6  

Matriz transpuesta:
1  4  
2  5  
3  6  
```  

> [!TIP]  
> Usa dos `for` anidados para intercambiar `matriz[i][j]` por `matriz[j][i]`.  

---  

### ğŸ… **Problema arreglo04: EliminaciÃ³n de Duplicados** | ğŸ‘‘ **Leyenda** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Dado un arreglo con `n` nÃºmeros, **elimina los duplicados** y muestra el resultado sin repetir elementos.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de nÃºmeros: 8
Ingresa los nÃºmeros:
2 5 3 2 8 5 3 10

Arreglo sin duplicados: 2 5 3 8 10
```  

> [!TIP]
> Tu puedes!
> 
---

# 3. **Punteros**

Variables que contienen una direcciÃ³n de memoria como su valor.

> [!IMPORTANT]  
> Los punteros en **C++** son una herramienta sumamente poderosa que permite **manipular directamente la memoria**. A diferencia de otros lenguajes de alto nivel, donde la gestiÃ³n de memoria es automÃ¡tica, en C++ **tienes control total** sobre la asignaciÃ³n y liberaciÃ³n de memoria. Sin embargo, como se menciona en la pelÃ­cula *Spider-Man* (2002): "[No lo olvides, un gran poder conlleva una gran responsabilidad](https://youtu.be/kfRIn8rlFgU?feature=shared&t=60)". 


Hay dos operadores importantes para los punteros:

- `&` (direcciÃ³n de): devuelve la direcciÃ³n del objeto dado como operando
- `*` (desreferenciar): devuelve el objeto que se encuentra en la direcciÃ³n dada por el operando

### **Ejemplo bÃ¡sico**

```cpp
#include <iostream>

using namespace std;

int main() {
    int i = 16;
    int *pi;
    pi = &i;
    cout << *pi << endl;
    return 0;
}
```

**Salida esperada:**
```
16
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

Este programa muestra cÃ³mo utilizar un puntero para acceder al valor de una variable en **C++**. A continuaciÃ³n, se explican los conceptos clave del cÃ³digo:

1. **DeclaraciÃ³n de la variable `i` y el puntero `pi`**:
   - `int i = 16;` declara una variable entera `i` con el valor `16`.
   - `int *pi;` declara un puntero `pi` que almacenarÃ¡ la direcciÃ³n de una variable de tipo `int`.

2. **AsignaciÃ³n de la direcciÃ³n de `i` al puntero `pi`**:
   - `pi = &i;` asigna a `pi` la direcciÃ³n de memoria de `i` utilizando el operador `&` (operador de direcciÃ³n). Ahora, `pi` apunta a la ubicaciÃ³n en memoria donde se encuentra `i`.

3. **DesreferenciaciÃ³n del puntero (`*pi`)**:
   - `cout << *pi << endl;` utiliza el operador `*` (operador de desreferenciaciÃ³n) para acceder al valor almacenado en la direcciÃ³n de memoria a la que apunta `pi`, en este caso, `16`.  
   - Es decir, `*pi` equivale a `i`, por lo que se imprime `16`.

4. **Flujo de ejecuciÃ³n**:
   - Se declara `i` y se le asigna `16`.
   - Se declara el puntero `pi`.
   - Se almacena la direcciÃ³n de `i` en `pi`.
   - Se imprime el valor almacenado en la direcciÃ³n apuntada por `pi`, que es `16`.

En resumen, este programa demuestra cÃ³mo los punteros pueden usarse para **acceder y manipular directamente la memoria** en C++, permitiendo un mayor control sobre los datos almacenados.

</details>  

## **AritmÃ©tica de punteros**

En C++, los punteros pueden usarse en expresiones aritmÃ©ticas.

Esta aritmÃ©tica no es solo suma o resta simple; tiene en cuenta el tamaÃ±o del tipo de dato al que apunta el puntero.

---

### **Operaciones bÃ¡sicas de aritmÃ©tica de punteros**  

```cpp
#include <iostream>

using namespace std;

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    int *ptr = arr;
    
    // Imprimir el arreglo antes de modificarlo
    cout << "Arreglo original: ";
    for (int i = 0; i < 5; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    ptr++; // Ahora ptr apunta a arr[1]
    
    cout << "El valor al que apunta ptr (arr[1]) es: " << *ptr << endl;

    // Acceder a otros elementos usando aritmÃ©tica de punteros
    cout << "El siguiente elemento es: " << *(ptr + 1) << endl; // Equivalente a arr[2]
    cout << "El elemento anterior es: " << *(ptr - 1) << endl; // Equivalente a arr[0]

    // Modificar un elemento usando el puntero
    *ptr = 10; // Cambia el valor de arr[1] a 10

    // Imprimir el arreglo modificado
    cout << "Arreglo modificado: ";
    for (int i = 0; i < 5; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
```

**Salida esperada:**
```
Arreglo original: 1 2 3 4 5 
El valor al que apunta ptr (arr[1]) es: 2
El siguiente elemento es: 3
El elemento anterior es: 1
Arreglo modificado: 1 10 3 4 5 
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

Este programa demuestra cÃ³mo realizar operaciones bÃ¡sicas con punteros y cÃ³mo modificar un arreglo mediante **aritmÃ©tica de punteros** en **C++**. A continuaciÃ³n, se explican los conceptos clave:

1. **InicializaciÃ³n del arreglo y del puntero**:
   - `int arr[5] = {1, 2, 3, 4, 5};` define un arreglo de cinco enteros.
   - `int *ptr = arr;` inicializa el puntero `ptr` apuntando al **primer elemento** del arreglo (`arr[0]`).  

2. **ImpresiÃ³n del arreglo original**:
   - Se recorre el arreglo con un `for` y se imprime cada elemento.  

3. **AritmÃ©tica de punteros: desplazamiento en memoria**:
   - `ptr++;` mueve el puntero una posiciÃ³n adelante, ahora apunta a `arr[1]` (el valor `2`).  
   - `cout << *ptr;` imprime el valor al que apunta `ptr`, que es `2`.  
   - `*(ptr + 1);` accede al siguiente elemento (`arr[2]`, que es `3`).  
   - `*(ptr - 1);` accede al elemento anterior (`arr[0]`, que es `1`).  

4. **ModificaciÃ³n del arreglo usando el puntero**:
   - `*ptr = 10;` cambia el valor de `arr[1]` de `2` a `10`.  
   - Como `ptr` apunta a `arr[1]`, la modificaciÃ³n se refleja directamente en el arreglo original.  

5. **ImpresiÃ³n del arreglo modificado**:
   - Se recorre nuevamente el arreglo y se imprime su contenido, mostrando el cambio en `arr[1]`.  

En resumen, este programa ilustra cÃ³mo los punteros permiten **navegar y modificar un arreglo sin necesidad de Ã­ndices**, simplemente desplazando el puntero en la memoria.  

</details>  

---

### **Otras operaciones con punteros**  

```cpp
#include <iostream>

using namespace std;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int *ptr = arr;

    // Mostrar la direcciÃ³n inicial y el valor al que apunta
    cout << "DirecciÃ³n inicial de ptr: " << ptr << " | Valor: " << *ptr << endl;

    // Incrementar un puntero
    ptr++;
    cout << "DespuÃ©s de incrementar, ptr apunta a: " << *ptr << " (DirecciÃ³n: " << ptr << ")" << endl;

    // Sumar un entero a un puntero
    ptr += 2; // Ahora apunta a arr[3]
    cout << "DespuÃ©s de sumar 2, ptr apunta a: " << *ptr << " (DirecciÃ³n: " << ptr << ")" << endl;

    // Restar un entero a un puntero
    ptr -= 1; // Ahora apunta a arr[2]
    cout << "DespuÃ©s de restar 1, ptr apunta a: " << *ptr << " (DirecciÃ³n: " << ptr << ")" << endl;

    // Restar dos punteros
    int *ptr1 = &arr[1];
    int *ptr2 = &arr[4];
    int difference = ptr2 - ptr1; // Diferencia en tÃ©rminos de elementos
    cout << "Diferencia entre ptr2 y ptr1: " << difference << " elementos" << endl;

    return 0;
}
```

**Salida esperada:**  
```
DirecciÃ³n inicial de ptr: 0x12345678 | Valor: 10
DespuÃ©s de incrementar, ptr apunta a: 20 (DirecciÃ³n: 0x1234567C)
DespuÃ©s de sumar 2, ptr apunta a: 40 (DirecciÃ³n: 0x12345684)
DespuÃ©s de restar 1, ptr apunta a: 30 (DirecciÃ³n: 0x12345680)
Diferencia entre ptr2 y ptr1: 3 elementos
```

> [!NOTE]
>   
> Las direcciones de memoria en la salida son solo un ejemplo, asÃ­ que no te preocupes si ves algo diferente al ejecutar el cÃ³digo. ğŸ˜‰  


<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

Este programa muestra **operaciones bÃ¡sicas con punteros** en C++, como desplazamientos y diferencias entre punteros.

1. **InicializaciÃ³n del puntero**  
   - `ptr` apunta al primer elemento del arreglo `arr[0]`.

2. **Incremento (`ptr++`)**  
   - Avanza una posiciÃ³n en el arreglo (`arr[1]` â†’ `20`).

3. **Suma (`ptr += 2`)**  
   - Mueve el puntero dos posiciones adelante (`arr[3]` â†’ `40`).

4. **Resta (`ptr -= 1`)**  
   - Retrocede una posiciÃ³n (`arr[2]` â†’ `30`).

5. **Diferencia entre punteros (`ptr2 - ptr1`)**  
   - Calcula cuÃ¡ntos **elementos** separan `arr[1]` y `arr[4]` (3 elementos).

</details>  

---

## ğŸ§© **Problemas de Punteros Propuestos en C++**  

---

### ğŸ… **Problema puntero01: Suma de Elementos con Punteros** | âš”ï¸ **Guerrero** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Dado un arreglo de `n` nÃºmeros, usa **punteros** para calcular la **suma total**.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de nÃºmeros: 4
NÃºmero 1: 3
NÃºmero 2: 7
NÃºmero 3: 2
NÃºmero 4: 5
Suma total: 17
```  

> [!TIP]  
> Usa un puntero para recorrer el arreglo y sumar los valores.  

---

### ğŸ… **Problema puntero02: InversiÃ³n de un Arreglo** | ğŸ”¥ **Experto** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Dado un arreglo, usa **punteros** para invertir su contenido.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de nÃºmeros: 5
NÃºmeros originales: 1 2 3 4 5
NÃºmeros invertidos: 5 4 3 2 1
```  

> [!TIP]  
> Usa dos punteros: uno al inicio y otro al final, intercambiando valores hasta la mitad del arreglo.  

---

### ğŸ… **Problema puntero03: BÃºsqueda en un Arreglo con Punteros** | ğŸ‘‘ **Leyenda** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Dado un arreglo y un nÃºmero a buscar, usa punteros para verificar si el nÃºmero estÃ¡ presente y en quÃ© posiciÃ³n.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de nÃºmeros: 6
Ingresa los nÃºmeros: 4 8 15 16 23 42
Ingresa el nÃºmero a buscar: 15
El nÃºmero 15 se encuentra en la posiciÃ³n 3.
```  

> [!TIP]  
> Usa un puntero para recorrer el arreglo y comparar cada elemento con el nÃºmero buscado.  

---

# 4. **Referencias**  

Las **referencias** en **C++** permiten crear un alias para una variable existente, lo que significa que cualquier operaciÃ³n sobre la referencia afecta directamente a la variable original.  

> [!NOTE]
>
> Las referencias son una caracterÃ­stica nueva en C++ y no existen en C. Fueron introducidas para facilitar la manipulaciÃ³n de variables sin necesidad de punteros, mejorando la legibilidad y seguridad del cÃ³digo.

ğŸ“Œ **Diferencia clave con los punteros:**  
- Una referencia **no puede ser `nullptr`**.  
- Una vez inicializada, **no puede cambiar de objeto** al que hace referencia.  
- Su sintaxis es mÃ¡s sencilla y directa que la de los punteros.  

---

### Sintaxis: <!-- omit in toc -->   

```cpp
tipo &nombreReferencia = variable;
```  

ğŸ“Œ **ExplicaciÃ³n:**  
- `tipo`: El tipo de dato de la referencia debe coincidir con el de la variable original.  
- `&nombreReferencia`: Declara una referencia.  
- `variable`: Es la variable a la que hace referencia.  

---

### ğŸš€ **Ejemplo 1: Referencia a una variable**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int valor = 10;
    int &ref = valor;  // 'ref' es una referencia a 'valor'

    cout << "Valor original: " << valor << endl;
    cout << "Referencia: " << ref << endl;

    ref = 20;  // Cambia el valor de 'valor' a travÃ©s de la referencia

    cout << "Nuevo valor: " << valor << endl;
    return 0;
}
```  

ğŸ“Œ **Salida:**  
```
Valor original: 10
Referencia: 10
Nuevo valor: 20
```  

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- `int &ref = valor;` â†’ `ref` se comporta como un alias de `valor`, por lo que cualquier operaciÃ³n sobre `ref` afecta directamente a `valor`.  
- Modificar `ref` **tambiÃ©n modifica `valor`**, ya que ambas representan la misma variable en memoria.  

</details>

---

## **Referencias constantes (`const &`)**  

Si no queremos modificar la variable original pero tampoco queremos hacer una copia, podemos usar **referencias constantes**.  

---

### ğŸš€ **Ejemplo 2: Uso de `const &`**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int valor = 50;
    const int &ref = valor;  // Referencia constante a 'valor'

    cout << "Valor original: " << valor << endl;
    cout << "Referencia constante: " << ref << endl;

    // ref = 100;  // Esto darÃ­a error porque 'ref' es constante

    valor = 75;  // Se puede modificar 'valor' directamente

    cout << "Nuevo valor de 'valor': " << valor << endl;
    cout << "La referencia constante refleja el cambio: " << ref << endl;

    return 0;
}
```

ğŸ“Œ **Salida esperada:**  
```
Valor original: 50
Referencia constante: 50
Nuevo valor de 'valor': 75
La referencia constante refleja el cambio: 75
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- `const int &ref = valor;` â†’ `ref` es una **referencia constante**, lo que significa que **no se puede modificar `valor` a travÃ©s de `ref`**.  
- **Sin embargo**, `valor` **sÃ­ puede cambiar**, y como `ref` es solo un alias de `valor`, reflejarÃ¡ el nuevo valor automÃ¡ticamente.  
- **Intentar hacer `ref = 100;` generarÃ­a un error de compilaciÃ³n**, ya que `ref` es constante.  

</details>

---

## **ComparaciÃ³n entre referencias y punteros**  

| CaracterÃ­stica | Referencias (`&`) | Punteros (`*`) |
|--------------|----------------|--------------|
| Puede ser `nullptr` | âŒ No | âœ… SÃ­ |
| Puede cambiar de objeto | âŒ No | âœ… SÃ­ |
| MÃ¡s seguro y fÃ¡cil de leer | âœ… SÃ­ | âŒ No |
| Necesita `*` para acceder al valor | âŒ No | âœ… SÃ­ |

# 5. **Funciones**

Las funciones permiten reutilizar cÃ³digo dentro de un programa. Una funciÃ³n en **C++** estÃ¡ compuesta por:  

- Tipo de retorno  
- Nombre de la funciÃ³n  
- Lista de parÃ¡metros  
- Cuerpo de la funciÃ³n  

```cpp
tipo_retorno nombre_funcion(param1, param2, ...) {
    ...
    cuerpo_de_la_funciÃ³n;
    ...
}
```

### **Ejemplo bÃ¡sico**  

```cpp
#include <iostream>

using namespace std;

// FunciÃ³n para sumar dos nÃºmeros
int sumar(int num1, int num2) {
    return num1 + num2;
}

int main() {
    int a = 5, b = 3;
    int resultado = sumar(a, b);
    cout << "La suma de " << a << " y " << b << " es: " << resultado << endl;
    return 0;
}
```

---

## **MÃ©todos de paso de argumentos**  

> [!NOTE]
> 
> En C++, un **parÃ¡metro** es la variable definida en la funciÃ³n para recibir un valor, mientras que un **argumento** es el valor real que se pasa cuando se llama a la funciÃ³n. Es comÃºn confundirlos, pero la diferencia clave es que los **parÃ¡metros** existen en la **definiciÃ³n** de la funciÃ³n, mientras que los **argumentos** aparecen en la **llamada**. ğŸš€

En **C++**, los parÃ¡metros de una funciÃ³n pueden pasarse de tres maneras:  

### **Paso por valor**  

Este es el mÃ©todo predeterminado. Se pasa una copia del valor del argumento a la funciÃ³n, por lo que **las modificaciones dentro de la funciÃ³n no afectan al argumento original**.  

#### Ejemplo: <!-- omit in toc -->  

```cpp
#include <iostream>

using namespace std;

void intercambiar(int x, int y) {
    int temp = x;
    x = y;
    y = temp;
}

int main() {
    int a = 4, b = 5;
    intercambiar(a, b);
    cout << "DespuÃ©s de la funciÃ³n:\na = " << a << "\nb = " << b << endl;
    return 0;
}
```

**Salida esperada:**  
```
DespuÃ©s de la funciÃ³n:
a = 4
b = 5
```

> [!NOTE]
> 
> Como `x` e `y` son copias, el intercambio **no afecta** a `a` y `b`.
>

---

### **Paso por referencia con punteros**  

AquÃ­ se pasa la direcciÃ³n de los argumentos a la funciÃ³n usando **punteros**. Esto permite modificar los valores originales.  

#### Ejemplo:  <!-- omit in toc -->  

```cpp
#include <iostream>

using namespace std;

void intercambiar(int* x, int* y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main() {
    int a = 4, b = 5;
    intercambiar(&a, &b);
    cout << "DespuÃ©s de la funciÃ³n:\na = " << a << "\nb = " << b << endl;
    return 0;
}
```

**Salida esperada:**  
```
DespuÃ©s de la funciÃ³n:
a = 5
b = 4
```

> [!NOTE]
> 
> AquÃ­ sÃ­ se intercambian los valores, ya que se estÃ¡n modificando directamente en memoria.
> 

---

### **Paso por referencia con referencias**  

Este mÃ©todo utiliza **referencias (`&`)** en lugar de punteros, lo que simplifica el cÃ³digo sin perder eficiencia.  

#### Ejemplo:  <!-- omit in toc -->  

```cpp
#include <iostream>

using namespace std;

void intercambiar(int &x, int &y) {
    int temp = x;
    x = y;
    y = temp;
}

int main() {
    int a = 4, b = 5;
    intercambiar(a, b);
    cout << "DespuÃ©s de la funciÃ³n:\na = " << a << "\nb = " << b << endl;
    return 0;
}
```

**Salida esperada:**  
```
DespuÃ©s de la funciÃ³n:
a = 5
b = 4
```
> [!NOTE]
> 
> Al pasar por referencia, `a` y `b` se modifican **sin necesidad de usar punteros**.

---

## ğŸ“Œ ConclusiÃ³n <!-- omit in toc -->

| MÃ©todo | Â¿Modifica el valor original? | Complejidad |
|--------|-----------------------------|------------|
| **Por valor (`int x`)** | âŒ No | Baja (se crea una copia) |
| **Por referencia con punteros (`int* x`)** | âœ… SÃ­ | Media (requiere `&` y `*`) |
| **Por referencia con referencias (`int &x`)** | âœ… SÃ­ | Baja (mÃ¡s intuitivo que punteros) |

> [!IMPORTANT]
> 
> Si necesitas proteger el valor original, usa **paso por valor**.  
> Si quieres modificarlo sin copias, usa **paso por referencia (con punteros o referencias)**.  

---
## ğŸ§© **Problemas de Funciones Propuestos en C++**  

---

### ğŸ… **Problema funciÃ³n01: ConversiÃ³n de Tiempo** | â³ **Novato** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Crea una funciÃ³n `convertirTiempo` que reciba una cantidad de **segundos** y devuelva su equivalente en **horas, minutos y segundos**.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa los segundos: 3661
Resultado: 1 horas, 1 minutos, 1 segundos
```  

ğŸ“Œ **Nombre de la funciÃ³n:** `convertirTiempo`  
ğŸ“Œ **Lista de parÃ¡metros:** `(int segundos, int &horas, int &minutos, int &segundos)`  

> [!TIP]  
> Desglosa el tiempo en partes: los **segundos totales** se pueden dividir para obtener las **horas** y el **resto de segundos**. Luego, haz lo mismo para calcular los **minutos** y los **segundos finales**. AsegÃºrate de que la funciÃ³n pueda manejar diferentes valores de entrada, incluyendo `0` segundos. ğŸš€  

---

### ğŸ… **Problema funciÃ³n02: Operaciones con Arreglos** | ğŸ“Š **Experto** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Crea una funciÃ³n `calcularOperaciones` que reciba un **arreglo de nÃºmeros** y devuelva la **suma**, el **promedio** y el **mayor nÃºmero**.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de nÃºmeros: 4
NÃºmeros: 10 20 30 40
Suma: 100
Promedio: 25
Mayor: 40
```  

ğŸ“Œ **Nombre de la funciÃ³n:** `calcularOperaciones`  
ğŸ“Œ **Lista de parÃ¡metros:** `(int arr[], int n, int &suma, float &promedio, int &mayor)`  

> [!TIP]  
> Usa un `for` para recorrer el arreglo y calcular los valores requeridos en una sola pasada. Ten en cuenta que el primer nÃºmero leÃ­do puede ser el **mayor** temporalmente hasta que encuentres uno mÃ¡s grande. TambiÃ©n, asegÃºrate de manejar casos donde el arreglo tenga solo un nÃºmero. ğŸš€  

---

### ğŸ… **Problema funciÃ³n03: CÃ¡lculo de InterÃ©s Compuesto** | ğŸ’° **Maestro** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Crea una funciÃ³n `calcularInteresCompuesto` que reciba el **capital inicial**, la **tasa de interÃ©s** y los **aÃ±os**, y calcule el **monto final** aplicando **interÃ©s compuesto**.  

ğŸ“Œ **Ejemplo:**  
```
Capital inicial: 1000
Tasa de interÃ©s anual: 5%
AÃ±os: 3
Monto total: 1157.63
```  

ğŸ“Œ **Nombre de la funciÃ³n:** `calcularInteresCompuesto`  
ğŸ“Œ **Lista de parÃ¡metros:** `(double capital, double tasa, int aÃ±os) -> retorna double`  

> [!TIP]  
> Usa la fÃ³rmula `M = C * (1 + r/100)^t` y la funciÃ³n `pow()` de `<cmath>`. ğŸš€  

---

### ğŸ… **Problema funciÃ³n04: CÃ¡lculo de Ãrea y PerÃ­metro de un RectÃ¡ngulo** | ğŸ“ **Leyenda** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Crea una funciÃ³n `calcularRectangulo` que reciba el **largo** y **ancho** de un rectÃ¡ngulo y devuelva su **Ã¡rea** y **perÃ­metro**.  

ğŸ“Œ **Ejemplo:**  
```
Largo: 5
Ancho: 3
Ãrea: 15
PerÃ­metro: 16
```  

ğŸ“Œ **Nombre de la funciÃ³n:** `calcularRectangulo`  
ğŸ“Œ **Lista de parÃ¡metros:** `(double largo, double ancho, double &area, double &perimetro)`  

> [!TIP]  
> Usa las fÃ³rmulas `Ã¡rea = largo * ancho` y `perÃ­metro = 2 * (largo + ancho)`. AsegÃºrate de probar la funciÃ³n con diferentes valores, incluyendo rectÃ¡ngulos con lados iguales. ğŸš€  

---

### ğŸ… **Problema funciÃ³n05: Cifrado CÃ©sar** | ğŸ” **Gran Maestro** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Crea una funciÃ³n `cifrarCesar` que reciba una **cadena** y un **desplazamiento `n`** y la cifre usando **Cifrado CÃ©sar**.  

ğŸ“Œ **Ejemplo:**  
```
Texto original: HOLA
Desplazamiento: 3
Texto cifrado: KROD
```  

ğŸ“Œ **Nombre de la funciÃ³n:** `cifrarCesar`  
ğŸ“Œ **Lista de parÃ¡metros:** `(string texto, int desplazamiento) -> retorna string`  

> [!TIP]  
> Usa `isalpha(c)` para verificar si un carÃ¡cter es una letra antes de cifrarlo. Ajusta los valores con `mod 26` para evitar desbordamientos y mantener el cifrado dentro del alfabeto. ğŸš€  

---

# 6. **AsignaciÃ³n dinÃ¡mica de memoria en C++**  

La **asignaciÃ³n dinÃ¡mica de memoria** ocurre cuando se reserva memoria en **tiempo de ejecuciÃ³n** usando una funciÃ³n de la biblioteca estÃ¡ndar. En **C++**, esto se logra con los operadores `new` y `delete`.  

---

## **AsignaciÃ³n de memoria dinÃ¡mica**  

Para crear objetos dinÃ¡micos en C++, se usa la palabra clave **`new`**.  

ğŸ“Œ **Ejemplo 1: Reservar memoria para un solo entero**  

```cpp
int *p = new int;
```

> [!NOTE]
> 
> Esto asigna **memoria sin nombre** para almacenar un valor de tipo `int` y devuelve la direcciÃ³n de esa memoria.  

ğŸ“Œ **Ejemplo 2: Reservar memoria para un array dinÃ¡mico**  

```cpp
int *q = new int[128];
```

Esta lÃ­nea reserva **memoria para un arreglo de 128 elementos de tipo `int`**.  

---

## **LiberaciÃ³n de memoria dinÃ¡mica**  

Para evitar **fugas de memoria**, es importante liberar la memoria asignada con `delete`.  

> [!NOTE]
> 
> Si no liberas la memoria asignada con `new`, seguirÃ¡ ocupando espacio incluso cuando ya no la necesites, causando **fugas de memoria**. Esto puede ralentizar el sistema y, en casos extremos, hacer que el programa **colapse**. Siempre que uses `new`, asegÃºrate de usar `delete` para liberar la memoria. ğŸš€


ğŸ“Œ **Ejemplo:**  

```cpp
delete p;      // Libera la memoria de un solo entero
delete[] q;    // Libera la memoria de un array dinÃ¡mico
```

---

## **Ejemplo completo: Promedios de estudiantes (Memoria dinÃ¡mica)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numEstudiantes;

    cout << "Ingrese el nÃºmero de estudiantes: ";
    cin >> numEstudiantes;

    // Reservar memoria para un array dinÃ¡mico de promedios
    float *promedios = new float[numEstudiantes];

    // Verificar si la asignaciÃ³n de memoria fue exitosa
    if (!promedios) {
        cerr << "Error: No se pudo asignar memoria.\n";
        return 1;
    }

    // Ingresar los promedios de los estudiantes
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Promedio del estudiante " << i + 1 << ": ";
        cin >> promedios[i];
    }

    // Imprimir los promedios
    cout << "\nPromedios de los estudiantes:\n";
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Estudiante " << i + 1 << ": " << promedios[i] << endl;
    }

    // Liberar la memoria asignada dinÃ¡micamente
    delete[] promedios;

    return 0;
}
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- Se usa `new float[numEstudiantes]` para **reservar memoria dinÃ¡mica** y almacenar `numEstudiantes` valores.  
- Se verifica si la asignaciÃ³n fue exitosa para evitar **errores en tiempo de ejecuciÃ³n**.  
- Se capturan e imprimen los promedios ingresados por el usuario.  
- Finalmente, se libera la memoria con `delete[] promedios` para **evitar fugas de memoria**, asegurando un uso eficiente de los recursos.  

</details>

---

## **VersiÃ³n estÃ¡tica (TamaÃ±o fijo del array)**  

```cpp
#include <iostream>
using namespace std;

#define MAX_ESTUDIANTES 100  // TamaÃ±o mÃ¡ximo del array

int main() {
    int numEstudiantes;
    float promedios[MAX_ESTUDIANTES];

    cout << "Ingrese el nÃºmero de estudiantes (mÃ¡ximo " << MAX_ESTUDIANTES << "): ";
    cin >> numEstudiantes;

    if (numEstudiantes > MAX_ESTUDIANTES) {
        cout << "El nÃºmero de estudiantes supera el lÃ­mite.\n";
        return 1;
    }

    // Ingresar los promedios de los estudiantes
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Promedio del estudiante " << i + 1 << ": ";
        cin >> promedios[i];
    }

    // Imprimir los promedios
    cout << "\nPromedios de los estudiantes:\n";
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Estudiante " << i + 1 << ": " << promedios[i] << endl;
    }

    return 0;
}
```

## **Diferencias clave entre memoria dinÃ¡mica y estÃ¡tica**  <!-- omit in toc -->

| CaracterÃ­stica | Memoria DinÃ¡mica (`new`) | Memoria EstÃ¡tica (Array fijo) |
|---------------|-------------------------|------------------------------|
| **TamaÃ±o ajustable en ejecuciÃ³n** | âœ… SÃ­ | âŒ No |
| **Eficiencia en uso de memoria** | âœ… Mejor | âŒ Puede desperdiciar espacio |
| **Riesgo de fuga de memoria** | âŒ SÃ­ (si no se usa `delete`) | âœ… No |
| **Velocidad de acceso** | ğŸ”„ Ligeramente mÃ¡s lenta | âš¡ MÃ¡s rÃ¡pida |

---

> [!IMPORTANT]
> 
> - Usa **memoria dinÃ¡mica (`new`)** cuando **no conoces el tamaÃ±o exacto** en tiempo de compilaciÃ³n.  
> - Usa **memoria estÃ¡tica (arrays normales)** si el tamaÃ±o es fijo y conocido.  
> - **Siempre** libera la memoria con `delete` para evitar **fugas de memoria**. ğŸš€

# **ğŸ§® Tarea 2 - Reto C++**

[![Unirse a la tarea](https://img.shields.io/badge/%F0%9F%91%89%20Unirse%20a%20la%20tarea%20en%20GitHub%20Classroom-blue?style=for-the-badge)](https://classroom.github.com/a/sHyJsgJf)


## **ğŸ“¢ğŸš¨ FECHA LÃMITE: Lunes 17 de febrero - 11:59 PM ğŸš¨ğŸ“¢** <!-- omit in toc -->

âš ï¸ **ENTREGAS FUERA DE TIEMPO NO SERÃN ACEPTADAS.**  
âœ… **Haz `commit` y `push` antes del plazo y verifica tu entrega en GitHub Classroom.**

---

## **ğŸ“– DescripciÃ³n de la Tarea** <!-- omit in toc -->

La tarea consta de **dos problemas** con distinta dificultad y puntaje asignado.

---

## **ğŸ“Œ Problema 1 (40 puntos)** <!-- omit in toc -->

### **DescripciÃ³n** <!-- omit in toc -->

ONE OK ROCK comenzÃ³ su carrera tocando en pequeÃ±os clubes y avanzÃ³ hasta presentarse en estadios internacionales. Imagina que cada concierto representa un nÃºmero en su trayectoria, desde el primero hasta el mÃ¡s reciente. Su crecimiento ha sido una historia de esfuerzo y perseverancia, enfrentando desafÃ­os y superando barreras culturales para llegar a audiencias de todo el mundo. Tu tarea es escribir un programa que reciba un nÃºmero entero positivo **N**, representando la cantidad de conciertos, e imprima en lÃ­neas separadas los nÃºmeros del **1** al **N**, simbolizando cada presentaciÃ³n de la banda. Este proceso reflejarÃ¡ la progresiÃ³n de ONE OK ROCK desde sus humildes inicios hasta sus grandes actuaciones en escenarios internacionales.

AdemÃ¡s, puedes imaginar que cada nÃºmero representa un hito importante en la carrera de la banda, como el lanzamiento de un Ã¡lbum exitoso, una colaboraciÃ³n destacada o una actuaciÃ³n inolvidable en un festival de renombre.

### **ğŸ“Œ Entrada** <!-- omit in toc -->

- Un solo nÃºmero entero **N** *(1 â‰¤ N â‰¤ 10000)*.

### **ğŸ“Œ Salida** <!-- omit in toc -->

- **N** lÃ­neas, cada una con un nÃºmero del **1** al **N**, representando cada concierto de ONE OK ROCK en su camino al Ã©xito.

### **Ejemplo de Entrada y Salida** <!-- omit in toc -->

### **Ejemplo 1** <!-- omit in toc -->

#### Entrada: <!-- omit in toc -->

```
3
```

#### Salida: <!-- omit in toc -->

```
1
2
3

```

### **Ejemplo 2** <!-- omit in toc -->

#### Entrada: <!-- omit in toc -->

```
7
```

#### Salida: <!-- omit in toc -->

```
1
2
3
4
5
6
7

```

### **ğŸ“œ CÃ³digo Base** <!-- omit in toc -->
El siguiente cÃ³digo base debe usarse para resolver este problema.  
âš ï¸ **No se debe cambiar el nombre del archivo, debe llamarse `punto1.cpp`.**  

```cpp
#include <iostream>

using namespace std;

int main() {
    int n; // Variable para alamacenar la entrada del usuario
    cin >> n; // Lectura de la entrada desde la consola

    // TODO: Implementar la soluciÃ³n para el problema correspondiente

    return 0; // Indica que el programa finalizÃ³ correctamente
}
```

---

## **ğŸ“Œ Problema 2 (60 puntos)**  <!-- omit in toc -->

### **ğŸ“– Historia**  <!-- omit in toc -->

En una remota academia de criptografÃ­a, los estudiantes han descubierto una secuencia numÃ©rica con propiedades desconocidas. Se dice que esta serie fue utilizada por una antigua civilizaciÃ³n para cifrar mensajes ocultos en textos religiosos y cientÃ­ficos. Sin embargo, los manuscritos solo revelan los primeros dos nÃºmeros y el nÃºmero total de tÃ©rminos necesarios.  

Tu misiÃ³n es recrear la secuencia y revelar el nÃºmero clave que usaban para verificar la autenticidad de los mensajes. Dependiendo de la estructura del mensaje, el nÃºmero clave podrÃ­a cambiar su interpretaciÃ³n.  

Los registros indican que esta civilizaciÃ³n estableciÃ³ un lÃ­mite en la cantidad de tÃ©rminos que podÃ­an generarse. **Solo se permitÃ­a calcular hasta N = 29**, ya que creÃ­an que los nÃºmeros primos eran esenciales en su sistema, y **29 es el mayor nÃºmero primo menor a 30**. Cualquier cÃ¡lculo fuera de este rango era considerado inexacto o incluso prohibido en su mÃ©todo de anÃ¡lisis.  

---

### **ğŸ“œ Reglas de la Serie**  <!-- omit in toc -->

1. Se reciben tres nÃºmeros enteros: **A, B, N**.  
   - **A** y **B** â†’ Son los dos primeros tÃ©rminos de la serie.  
   - **N** â†’ Indica cuÃ¡ntos tÃ©rminos debe generar el sistema.  
2. Cada tÃ©rmino de la serie se calcula como la **suma de los dos anteriores**.  
3. El resultado esperado es el **Ãºltimo dÃ­gito** del tÃ©rmino final.  

### **ğŸ¯ CondiciÃ³n Especial**  <!-- omit in toc -->

Las investigaciones sugieren que cuando **N** es un nÃºmero primo, los antiguos matemÃ¡ticos no utilizaban el Ãºltimo dÃ­gito, sino el **primer dÃ­gito** del tÃ©rmino final, ya que creÃ­an que los nÃºmeros primos tenÃ­an propiedades divinas y eran la clave de su cÃ³digo numÃ©rico.  

---

## **ğŸ“Œ Entrada**  <!-- omit in toc -->

El programa recibirÃ¡ **una Ãºnica lÃ­nea de entrada** con tres nÃºmeros enteros separados por un espacio:  

- **A** *(1 â‰¤ A â‰¤ 10,000)* â†’ Primer nÃºmero de la serie.  
- **B** *(1 â‰¤ B â‰¤ 10,000)* â†’ Segundo nÃºmero de la serie.  
- **N** *(1 â‰¤ N â‰¤ 29)* â†’ Cantidad de tÃ©rminos a generar (limitado por razones estructurales).  

---

## **ğŸ“Œ Salida**  <!-- omit in toc -->

El programa debe imprimir **un Ãºnico nÃºmero**:  

- El **Ãºltimo dÃ­gito** del tÃ©rmino final generado, salvo cuando **N** sea primo, en cuyo caso se imprimirÃ¡ el **primer dÃ­gito**.  

---

### **Ejemplos de Entrada y Salida**  <!-- omit in toc -->

#### **Ejemplo 1** (**N** no es primo)  <!-- omit in toc -->

##### Entrada:  <!-- omit in toc -->
```
1 1 12
```  

##### Salida:  <!-- omit in toc -->
```
4
```  

*(Serie generada: 1 1 2 3 5 8 13 21 34 55 89 144 â†’ Ãšltimo dÃ­gito: 4)*  

---

#### **Ejemplo 2** (**N** es primo) <!-- omit in toc -->  

##### Entrada:  <!-- omit in toc -->
```
130 5 13
```  

##### Salida:  <!-- omit in toc -->
```
1
```  

*(Serie generada: 130 5 135 140 275 415 690 1105 1795 2900 4695 7595 12290 â†’ Primer dÃ­gito: 1)*  

---

## **ğŸ“œ Notas Importantes**  <!-- omit in toc -->

- **El sistema debe manejar nÃºmeros grandes sin desbordarse.**  
- **Se debe optimizar la generaciÃ³n de la serie para evitar un uso excesivo de memoria.**  

---

### **ğŸ“œ CÃ³digo Base** <!-- omit in toc -->
El siguiente cÃ³digo base debe usarse para resolver este problema.  
âš ï¸ **No se debe cambiar el nombre del archivo, debe llamarse `punto2.cpp`.**  

```cpp
#include <iostream>

using namespace std;

// FunciÃ³n para determinar si un nÃºmero es primo
bool esPrimo(int n) {
    if (n < 2) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}

// FunciÃ³n para obtener el primer dÃ­gito de un nÃºmero
int primerDigito(int num) {
    // TODO: Implementar la extracciÃ³n del primer dÃ­gito del nÃºmero
    return 0;
}

// FunciÃ³n para calcular el Ãºltimo dÃ­gito del tÃ©rmino final de la serie
int calcularUltimoDigito(int a, int b, int n) {
    // TODO: Implementar la generaciÃ³n de la serie y extraer el dÃ­gito correspondiente
    return 0;
}

int main() {
    int a, b, n;
    cin >> a >> b >> n; // Lectura de los valores de entrada
    cout << calcularUltimoDigito(a, b, n) << endl; // CÃ¡lculo e impresiÃ³n del resultado
    return 0;
}
```

## **ğŸ“Œ Â¿CÃ³mo entregar la tarea en GitHub Classroom?** <!-- omit in toc -->

### **ğŸ“ Pasos para entregar tu cÃ³digo correctamente:** <!-- omit in toc -->

## 1ï¸âƒ£ Aceptar la tarea  <!-- omit in toc -->
1. **Accede al enlace de la tarea:** [https://classroom.github.com/a/sHyJsgJf](https://classroom.github.com/a/sHyJsgJf).
2. **Acepta la tarea** haciendo clic en el botÃ³n correspondiente.  
3. Una vez aceptada, **se habrÃ¡ creado automÃ¡ticamente un repositorio en GitHub** con la siguiente direcciÃ³n (reemplaza `TU_USUARIO` con tu nombre de usuario en GitHub):  
   ```
   https://github.com/profesorcito/tarea-2-TU_USUARIO
   ```
   Puedes verificarlo ingresando a tu cuenta de GitHub.  

## 2ï¸âƒ£ Descargar el repositorio a tu computadora <!-- omit in toc -->  
4. **Abre Git Bash** en tu computadora.  
5. **Navega a la carpeta donde guardarÃ¡s el proyecto** con el siguiente comando:  
   ```bash
   cd ~/Desktop/CLionProjects
   ```
6. **Clona tu repositorio** en tu computadora** con el siguiente comando (reemplaza `TU_USUARIO` con tu usuario en GitHub):  
   ```bash
   git clone https://github.com/profesorcito/tarea-2-TU_USUARIO.git
   ```

> [!NOTE]
>  
> Si tienes dudas sobre la direcciÃ³n exacta del repositorio, **puedes copiarla desde GitHub** haciendo clic en el botÃ³n verde que dice **"Code"**.
>  
   

## 3ï¸âƒ£ Abrir el repositorio en CLion <!-- omit in toc -->
7. **Abrir el proyecto en CLion**  
   - Presiona `Alt + F`.  
   - Selecciona **New** â†’ **Project**.  
   - En la parte izquierda, selecciona **C++ Executable**.  
   - Busca la carpeta donde quedÃ³ el repositorio dentro de `CLionProjects`.  
   - Debe llamarse:  
     ```
     tarea-2-TU_USUARIO
     ```
   - Haz clic en **Create**.  

> [!IMPORTANT]
>
> AparecerÃ¡ un mensaje preguntando si deseas crear el proyecto sobre los archivos existentes. **Debes aceptar.**  Si pregunta si quieres abrirlo en esta ventana, **tambiÃ©n acepta.**  
>

## 4ï¸âƒ£ Modificar y probar el cÃ³digo <!-- omit in toc --> 
8. **Editar y ejecutar `punto1.cpp`:**  
   - Busca `punto1.cpp` y Ã¡brelo.  
   - Escribe el cÃ³digo necesario para resolver el problema.  
   - Antes de compilar, en la parte superior, en el menÃº desplegable junto al botÃ³n **Build** (ğŸ”¨), **selecciona `punto1`**.  
   - Ejecuta el programa y verifica que la salida sea la esperada.  

9. **Editar y ejecutar `punto2.cpp`:**  
   - Busca `punto2.cpp` y Ã¡brelo.  
   - Escribe el cÃ³digo necesario para resolver el problema.  
   - Antes de compilar, en la parte superior, en el menÃº desplegable junto al botÃ³n **Build** (ğŸ”¨), **selecciona `punto2`**.  
   - Ejecuta el programa y verifica que la salida sea la esperada.  

## 5ï¸âƒ£ Subir los cambios a GitHub <!-- omit in toc -->
10. **Guarda los cambios y sÃºbelos a GitHub** con los siguientes comandos:  
   ```bash
   git add .
   git commit -m "Intento 1"
   git push origin master
   ```

## 6ï¸âƒ£ Verificar la tarea en GitHub Classroom <!-- omit in toc -->  
11. **Revisa en la pestaÃ±a "Actions"** de GitHub si tu tarea fue aceptada.  
   - Si tu tarea fue aceptada, **se mostrarÃ¡ en verde** âœ….  
   - Si hubo errores, **se mostrarÃ¡ en rojo** âŒ.  
12. Si haces clic en el Ãºltimo commit, puedes acceder a **"run-autograding-test"** para ver quÃ© pruebas no pasaste.  
13. **Corrige el cÃ³digo y sube los cambios nuevamente** usando `git push` hasta que tu evaluaciÃ³n estÃ© en verde.  

---
> [!IMPORTANT]  
>
>- **No cambies el nombre de los archivos (`punto1.cpp` y `punto2.cpp`).**  
>- **AsegÃºrate de hacer `commit` y `push` antes de la fecha lÃ­mite.**  
>- **Si encuentras errores en el autograder, revisa tu salida y ajÃºstala segÃºn los ejemplos dados.**  
>
---


