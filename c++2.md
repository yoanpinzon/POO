
---

# 💻 300CIS017 Programación Orientada a Objetos 2025-02  <!-- omit in toc -->
![Version](https://img.shields.io/badge/version-1.4-blue)
[![License: CC BY-NC-ND 4.0](https://img.shields.io/badge/License-CC%20BY--NC--ND%204.0-lightgrey.svg?color=#007ec6)](https://creativecommons.org/licenses/by-nc-nd/4.0/)

---

# 🌟 Tema 2: El lenguaje C++ - Parte 2<!-- omit in toc -->

---

### 🎥 Videos que inspiraron este tema:

<table style="border-collapse: collapse; width: 100%; border: none; margin: 10px 0;">
  <tr>
    <td style="text-align: center; padding: 5px; border: none;">
      <a href="https://www.youtube.com/watch?v=Hh9yZWeTmVM">
        <img src="img/vid4.png" alt="The Beginning - OOR" width="150">
      </a>
      <br>
      <span style="font-size: 12px; margin-top: 5px; display: inline-block;">The Beginning<br>OOR</span>
    </td>
    <td style="text-align: center; padding: 5px; border: none;">
      <a href="https://www.youtube.com/watch?v=Ibp_y21LHJY">
        <img src="img/vid5.png" alt="Push Back - OOR" width="150">
      </a>
      <br>
      <span style="font-size: 12px; margin-top: 5px; display: inline-block;">Push Back<br>OOR</span>
    </td>
  </tr>
</table>

---

### 💻 Creado por   

Profesorcito © 2025

---

### 🎶 Dedicado a 

[Takahiro Moriuchi](https://es.wikipedia.org/wiki/Takahiro_Moriuchi) (Taka) 🎤

---

En este capítulo, aprenderemos sobre **bucles (`for`, `while`, `do-while`)**, **arreglos**, **punteros**, **referencias**, **funciones** y **asignación dinámica de memoria**, conceptos clave para escribir código eficiente y estructurado. 🚀

---

### **Tabla de Contenido**

- [1. **Estructuras de Repetición**](#1-estructuras-de-repetición)
  - [**El bucle `for`**](#el-bucle-for)
    - [🚀 **Ejemplo 1: Imprimir números del 1 al 5**](#-ejemplo-1-imprimir-números-del-1-al-5)
    - [🚀 **Ejemplo 2: Contador en decremento**](#-ejemplo-2-contador-en-decremento)
    - [🚀 **Ejemplo 3: Recorrer un array**](#-ejemplo-3-recorrer-un-array)
    - [🚀 **Ejemplo 4: Tabla de multiplicar**](#-ejemplo-4-tabla-de-multiplicar)
    - [🚀 **Ejemplo 5: Bucle infinito con `for`**](#-ejemplo-5-bucle-infinito-con-for)
    - [🚀 **Ejemplo 6: Imprimir un triángulo de asteriscos con `for` anidados**](#-ejemplo-6-imprimir-un-triángulo-de-asteriscos-con-for-anidados)
  - [**El bucle `while`**](#el-bucle-while)
    - [🚀 **Ejemplo 1: Contador del 1 al 5**](#-ejemplo-1-contador-del-1-al-5)
    - [🚀 **Ejemplo 2: Cuenta regresiva**](#-ejemplo-2-cuenta-regresiva)
    - [🚀 **Ejemplo 3: Leer hasta que el usuario ingrese un número positivo**](#-ejemplo-3-leer-hasta-que-el-usuario-ingrese-un-número-positivo)
    - [🚀 **Ejemplo 4: Sumar valores ingresados por el usuario**](#-ejemplo-4-sumar-valores-ingresados-por-el-usuario)
    - [🚀 **Ejemplo 5: Bucle infinito con `while`**](#-ejemplo-5-bucle-infinito-con-while)
  - [**El bucle `do-while`**](#el-bucle-do-while)
    - [🚀 **Ejemplo 1: Validar entrada de usuario (Básico y útil)**](#-ejemplo-1-validar-entrada-de-usuario-básico-y-útil)
    - [🚀 **Ejemplo 2: Simulador de menú interactivo**](#-ejemplo-2-simulador-de-menú-interactivo)
  - [🧩 **Problemas de Bucles Propuestos en C++**](#-problemas-de-bucles-propuestos-en-c)
  - [**Instrucciones `break` y `continue`**](#instrucciones-break-y-continue)
    - [🚀 **Ejemplo 1: Uso de `break` (Sumar solo valores positivos)**](#-ejemplo-1-uso-de-break-sumar-solo-valores-positivos)
    - [🚀 **Ejemplo 2: Uso de `continue` (Imprimir valores del 1 al 10, omitiendo el 5)**](#-ejemplo-2-uso-de-continue-imprimir-valores-del-1-al-10-omitiendo-el-5)
- [2. **Arreglos**](#2-arreglos)
  - [**Declaración de un arreglo**](#declaración-de-un-arreglo)
  - [**Inicialización de arreglos**](#inicialización-de-arreglos)
    - [🚀 **Ejemplo 1: Suma de dos matrices en C++**](#-ejemplo-1-suma-de-dos-matrices-en-c)
  - [🧩 **Problemas de Arreglos Propuestos en C++**](#-problemas-de-arreglos-propuestos-en-c)
- [3. **Uso de `auto` para Inferencia de Tipos**](#3-uso-de-auto-para-inferencia-de-tipos)
- [4. **Punteros**](#4-punteros)
    - [**Ejemplo básico**](#ejemplo-básico)
  - [**Aritmética de punteros**](#aritmética-de-punteros)
    - [**Operaciones básicas de aritmética de punteros**](#operaciones-básicas-de-aritmética-de-punteros)
    - [**Otras operaciones con punteros**](#otras-operaciones-con-punteros)
  - [🧩 **Problemas de Punteros Propuestos en C++**](#-problemas-de-punteros-propuestos-en-c)
- [5. **Referencias**](#5-referencias)
    - [🚀 **Ejemplo 1: Referencia a una variable**](#-ejemplo-1-referencia-a-una-variable)
    - [🚀 **Ejemplo 2: Uso de `const &`**](#-ejemplo-2-uso-de-const-)
  - [**Comparación entre referencias y punteros**](#comparación-entre-referencias-y-punteros)
- [6. **Funciones**](#6-funciones)
  - [**Métodos de paso de argumentos**](#métodos-de-paso-de-argumentos)
    - [**Paso por valor**](#paso-por-valor)
    - [**Paso por referencia con punteros**](#paso-por-referencia-con-punteros)
    - [**Paso por referencia con referencias**](#paso-por-referencia-con-referencias)
  - [🧩 **Problemas de Funciones Propuestos en C++**](#-problemas-de-funciones-propuestos-en-c)
- [7. **Asignación dinámica de memoria en C++**](#7-asignación-dinámica-de-memoria-en-c)
  - [**Asignación de memoria dinámica**](#asignación-de-memoria-dinámica)
  - [**Liberación de memoria dinámica**](#liberación-de-memoria-dinámica)
  - [**Aplicación práctica: Memoria estática vs dinámica en C++**](#aplicación-práctica-memoria-estática-vs-dinámica-en-c)
    - [**Versión dinámica**](#versión-dinámica)
    - [**Versión estática**](#versión-estática)
- [8. **Templates**](#8-templates)
    - [🚀 **Ejemplo 1: Función genérica para encontrar el máximo**](#-ejemplo-1-función-genérica-para-encontrar-el-máximo)
    - [🚀 **Ejemplo 2: Función genérica para intercambiar valores**](#-ejemplo-2-función-genérica-para-intercambiar-valores)
- [9. **Inline Expansion**](#9-inline-expansion)
- [10. **Overloading**](#10-overloading)
- [11. **Manejo de Excepciones**](#11-manejo-de-excepciones)
    - [🚀 **Ejemplo 1: Manejo de División por Cero**](#-ejemplo-1-manejo-de-división-por-cero)
    - [🚀 **Ejemplo 2: Validación de Rango en Entrada de Usuario**](#-ejemplo-2-validación-de-rango-en-entrada-de-usuario)
    - [🚀 **Ejemplo 3: Manejo de Múltiples Excepciones**](#-ejemplo-3-manejo-de-múltiples-excepciones)
  - [**Excepciones Adicionales en \<stdexcept\>**](#excepciones-adicionales-en-stdexcept)
- [12. **Estructuras**](#12-estructuras)
    - [🚀 **Ejemplo 1: Definiendo un Nuevo Tipo de Dato - Punto**](#-ejemplo-1-definiendo-un-nuevo-tipo-de-dato---punto)
    - [🚀 **Ejemplo 2: Definiendo un Nuevo Tipo de Dato - Gato**](#-ejemplo-2-definiendo-un-nuevo-tipo-de-dato---gato)

---

# 1. **Estructuras de Repetición**  

En programación, los **bucles** 🔄 permiten repetir instrucciones sin escribirlas múltiples veces. En C++, existen **tres tipos de bucles** fundamentales:  

## **El bucle `for`**  

Se usa cuando **se conoce de antemano** cuántas veces debe repetirse la ejecución del bloque de código.  

### Sintaxis: <!-- omit in toc -->  

```cpp
for (inicialización; condición; actualización) {
    // Bloque de código que se ejecuta en cada iteración
}
```  

📌 **Explicación de cada parte:**  
1. **Inicialización**: Se ejecuta una sola vez al inicio del bucle. Se usa para definir y asignar un valor inicial a una variable de control.  
2. **Condición**: Se evalúa antes de cada iteración. Si es `true`, el bloque de código se ejecuta; si es `false`, el bucle termina.  
3. **Actualización**: Se ejecuta al final de cada iteración y suele modificar la variable de control.  

---

### 🚀 **Ejemplo 1: Imprimir números del 1 al 5**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 1; i <= 5; i++) {  // i inicia en 1, se detiene cuando i > 5, y se incrementa en 1
        cout << "Valor: " << i << endl;
    }
    return 0;
}
```  

📌 **Salida:**  
```
Valor: 1
Valor: 2
Valor: 3
Valor: 4
Valor: 5
```  

---

### 🚀 **Ejemplo 2: Contador en decremento**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 10; i >= 1; i--) {  // i inicia en 10 y va decreciendo hasta 1
        cout << "Cuenta regresiva: " << i << endl;
    }
    return 0;
}
```  

📌 **Salida:**  
```
Cuenta regresiva: 10
Cuenta regresiva: 9
Cuenta regresiva: 8
Cuenta regresiva: 7
Cuenta regresiva: 6
Cuenta regresiva: 5
Cuenta regresiva: 4
Cuenta regresiva: 3
Cuenta regresiva: 2
Cuenta regresiva: 1
```  

---

### 🚀 **Ejemplo 3: Recorrer un array**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numeros[] = {3, 7, 1, 9, 5};
    int tamaño = sizeof(numeros) / sizeof(numeros[0]); // Calcula el tamaño del array

    for (int i = 0; i < tamaño; i++) {  // Recorre el array usando su tamaño
        cout << "Elemento " << i << ": " << numeros[i] << endl;
    }
    return 0;
}
```  

📌 **Salida:**  
```
Elemento 0: 3
Elemento 1: 7
Elemento 2: 1
Elemento 3: 9
Elemento 4: 5
```  

---

### 🚀 **Ejemplo 4: Tabla de multiplicar**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Introduce un número: ";
    cin >> n;

    for (int i = 1; i <= 10; i++) {
        cout << n << " x " << i << " = " << (n * i) << endl;
    }

    return 0;
}
```  

📌 **Salida si el usuario ingresa `7`:**  
```
7 x 1 = 7
7 x 2 = 14
7 x 3 = 21
7 x 4 = 28
7 x 5 = 35
7 x 6 = 42
7 x 7 = 49
7 x 8 = 56
7 x 9 = 63
7 x 10 = 70
```  

---

### 🚀 **Ejemplo 5: Bucle infinito con `for`**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (;;) {  // No hay inicialización, condición ni actualización
        cout << "Esto es un bucle infinito!" << endl;
    }
    return 0;
}
```  

📌 **Esto imprimirá el mensaje infinitamente hasta que detengas el programa manualmente (`Ctrl + C` en consola).**  

---

### 🚀 **Ejemplo 6: Imprimir un triángulo de asteriscos con `for` anidados**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int filas;

    cout << "Introduce el número de filas: ";
    cin >> filas;

    for (int i = 1; i <= filas; i++) {  // Controla las filas
        for (int j = 1; j <= i; j++) {  // Controla la cantidad de asteriscos por fila
            cout << "* ";
        }
        cout << endl;  // Salto de línea para la siguiente fila
    }

    return 0;
}
```  

📌 **Salida si el usuario ingresa `5`:**  
```
* 
* * 
* * * 
* * * * 
* * * * * 
```  

---

## **El bucle `while`**  

Se usa cuando **no se conoce de antemano** cuántas veces debe repetirse la ejecución del bloque de código. El bucle continuará ejecutándose **mientras una condición sea verdadera**.

### Sintaxis: <!-- omit in toc -->

```cpp
while (condición) {
    // Bloque de código que se ejecuta en cada iteración
}
```

📌 **Explicación de cada parte:**  
1. **Condición**: Se evalúa antes de cada iteración. Si es `true`, el bloque de código se ejecuta; si es `false`, el bucle termina.  
2. **Bloque de código**: Se ejecuta una y otra vez mientras la condición siga siendo verdadera.  
3. **Cambio de estado**: Es necesario modificar alguna variable dentro del bucle para que eventualmente la condición sea `false`, evitando un bucle infinito.  

---

### 🚀 **Ejemplo 1: Contador del 1 al 5**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int contador = 1;  // Se inicia el contador en 1

    while (contador <= 5) {  // Se ejecuta mientras contador sea menor o igual a 5
        cout << "Valor: " << contador << endl;
        contador++;  // Se incrementa el contador en 1
    }

    return 0;
}
```

📌 **Salida:**
```
Valor: 1
Valor: 2
Valor: 3
Valor: 4
Valor: 5
```

---

### 🚀 **Ejemplo 2: Cuenta regresiva**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int contador = 10;

    while (contador >= 1) {  // Se ejecuta mientras contador sea mayor o igual a 1
        cout << "Cuenta regresiva: " << contador << endl;
        contador--;  // Se decrementa en 1
    }

    return 0;
}
```

📌 **Salida:**
```
Cuenta regresiva: 10
Cuenta regresiva: 9
...
Cuenta regresiva: 1
```

---

### 🚀 **Ejemplo 3: Leer hasta que el usuario ingrese un número positivo**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numero;

    cout << "Ingresa un número positivo: ";
    cin >> numero;

    while (numero <= 0) {  // Se repite mientras el número sea negativo o cero
        cout << "El número no es positivo. Intenta de nuevo: ";
        cin >> numero;
    }

    cout << "Número válido ingresado: " << numero << endl;
    return 0;
}
```

📌 **Ejemplo de entrada y salida:**  
```
Ingresa un número positivo: -3
El número no es positivo. Intenta de nuevo: 0
El número no es positivo. Intenta de nuevo: 7
Número válido ingresado: 7
```

---

### 🚀 **Ejemplo 4: Sumar valores ingresados por el usuario**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int suma = 0, num;

    cout << "Ingresa números para sumar (0 para terminar): ";

    while (true) {  // Se repite hasta que el usuario ingrese 0
        cin >> num;
        if (num == 0) {
            break;  // Sale del bucle cuando el usuario ingresa 0
        }
        suma += num;
    }

    cout << "Suma total: " << suma << endl;
    return 0;
}
```

📌 **Ejemplo de entrada y salida:**  
```
Ingresa números para sumar (0 para terminar): 5
10
-2
3
0
Suma total: 16
```

---

### 🚀 **Ejemplo 5: Bucle infinito con `while`**  

```cpp
#include <iostream>
using namespace std;

int main() {
    while (true) {  // No hay condición de salida
        cout << "Esto es un bucle infinito!" << endl;
    }
    return 0;
}
```

📌 **Esto imprimirá el mensaje infinitamente hasta que detengas el programa manualmente (`Ctrl + C` en consola).**  

---

## **El bucle `do-while`**  

Es similar al `while`, pero **siempre ejecuta al menos una vez** el bloque de código antes de evaluar la condición.

### Sintaxis: <!-- omit in toc -->

```cpp
do {
   // Código a ejecutar en cada iteración
} while (condición);
```

📌 **Explicación de cada parte:**  
1. **Bloque de código**: Se ejecuta **una vez antes de evaluar** la condición.  
2. **Condición**: Se evalúa después de la primera ejecución. Si es `true`, el bucle continúa; si es `false`, el bucle termina.  

---

### 🚀 **Ejemplo 1: Validar entrada de usuario (Básico y útil)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numero;

    do {
        cout << "Ingresa un número positivo: ";
        cin >> numero;

        if (numero <= 0) {
            cout << "Error: el número debe ser positivo." << endl;
        }

    } while (numero <= 0);  // Repite mientras el número no sea positivo

    cout << "Número válido ingresado: " << numero << endl;
    return 0;
}
```

📌 **Ejemplo de entrada y salida:**  
```
Ingresa un número positivo: -4
Error: el número debe ser positivo.
Ingresa un número positivo: 0
Error: el número debe ser positivo.
Ingresa un número positivo: 7
Número válido ingresado: 7
```

> [!TIP]  
> Te estarás preguntando cuándo se usa `do-while` o por qué existe en primer lugar. La razón es que garantiza que el usuario vea el mensaje al menos una vez, sin importar la condición. Además, si el usuario ingresa un valor correcto desde el inicio, el bucle solo se ejecuta una vez, evitando iteraciones innecesarias.

---

### 🚀 **Ejemplo 2: Simulador de menú interactivo**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int opcion;

    do {
        // Mostrar opciones
        cout << "\nMENÚ DE OPCIONES" << endl;
        cout << "1. Saludar" << endl;
        cout << "2. Mostrar fecha" << endl;
        cout << "3. Salir" << endl;
        cout << "Selecciona una opción: ";
        cin >> opcion;

        // Ejecutar la opción seleccionada
        switch (opcion) {
            case 1:
                cout << "¡Hola! Espero que estés teniendo un gran día." << endl;
                break;
            case 2:
                cout << "Hoy es un gran día para programar en C++." << endl;
                break;
            case 3:
                cout << "Saliendo del programa..." << endl;
                break;
            default:
                cout << "Opción no válida, intenta de nuevo." << endl;
        }

    } while (opcion != 3);  // Repite mientras el usuario no seleccione "Salir"

    return 0;
}
```

📌 **Ejemplo de entrada y salida:**  
```
MENÚ DE OPCIONES
1. Saludar
2. Mostrar fecha
3. Salir
Selecciona una opción: 1
¡Hola! Espero que estés teniendo un gran día.

MENÚ DE OPCIONES
1. Saludar
2. Mostrar fecha
3. Salir
Selecciona una opción: 2
Hoy es un gran día para programar en C++.

MENÚ DE OPCIONES
1. Saludar
2. Mostrar fecha
3. Salir
Selecciona una opción: 3
Saliendo del programa...
```

---

## 🧩 **Problemas de Bucles Propuestos en C++**  

---

### 🏅 **Problema bucle01: Suma** | 🛡️ **Novato** <!-- omit in toc -->  

🔹 **Descripción:** Suma todos los números del `1` hasta `n`.  

📌 **Ejemplo:**  
```
Ingresa un número: 5
La suma es: 15
```  

> [!TIP]
> Usa un `for` para recorrer y acumular la suma.  

---

### 🏅 **Problema bucle02: Dígitos** | ⚔️ **Guerrero** <!-- omit in toc -->  

🔹 **Descripción:** Cuenta cuántos dígitos tiene un número entero.  

📌 **Ejemplo:**  
```
Ingresa un número: 12345
Tiene 5 dígitos.
```  

> [!TIP]
> Divide entre `10` en un `while` hasta que sea `0`.  

---

### 🏅 **Problema bucle03: Adivina el Número** | ⚔️ **Guerrero** <!-- omit in toc -->  

🔹 **Descripción:** Genera un número aleatorio del `1` al `100`. El usuario debe adivinarlo con pistas.  

📌 **Ejemplo:**  
```
Adivina el número (1-100): 50
Es mayor. Intenta de nuevo: 75
Es menor. Intenta de nuevo: 63
¡Correcto!
```  

> [!TIP]
> Usa `rand()` y un `do-while` para repetir intentos.  

---

### 🏅 **Problema bucle04: Pirámide de Números** | 🔥 **Experto** <!-- omit in toc -->  

🔹 **Descripción:** Imprime una pirámide de números con `n` filas.  

📌 **Ejemplo si `n = 5`:**  
```
    1
   121
  12321
 1234321
123454321
```  

> [!TIP]
> Usa `for` anidados para manejar espacios y números.  

---

### 🏅 **Problema bucle05: Números Primos** | 👑 **Leyenda** <!-- omit in toc -->  

🔹 **Descripción:** Verifica si un número es **primo** o **compuesto**.  

📌 **Ejemplo:**  
```
Ingresa un número: 17
Es primo.
```  

> [!TIP]
> Usa un `for` para contar divisores.  

---

## **Instrucciones `break` y `continue`**  

En C++, las instrucciones `break` y `continue` permiten **controlar el flujo de ejecución de un bucle** de manera más flexible.  

- **`break`**: Finaliza el bucle inmediatamente, sin importar si la condición del bucle sigue siendo verdadera.  
- **`continue`**: Salta el resto del código en la iteración actual y pasa directamente a la siguiente iteración.  

---

### 🚀 **Ejemplo 1: Uso de `break` (Sumar solo valores positivos)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    double suma = 0.0, valor;
    cout << "Ingresa valores uno por uno. Se sumaran mientras sean positivos." << endl;

    for (;;) { // Bucle infinito controlado con break
        cout << "Valor: ";
        cin >> valor;
        if (valor <= 0) break; // Sale del bucle si el valor es negativo o cero
        suma += valor;
    }

    cout << "Suma de los valores positivos ingresados: " << suma << endl;
    return 0;
}
```  

📌 **Salida:**  
```
Ingresa valores uno por uno. Se sumaran mientras sean positivos.
Valor: 5
Valor: 3.5
Valor: 10
Valor: -1
Suma de los valores positivos ingresados: 18.5
```  

---

### 🚀 **Ejemplo 2: Uso de `continue` (Imprimir valores del 1 al 10, omitiendo el 5)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 1; i <= 10; i++) {
        if (i == 5) continue; // Salta la impresión del 5
        cout << "Valor: " << i << endl;
    }

    cout << "Se uso 'continue' para omitir la impresion del 5." << endl;
    return 0;
}
```  

📌 **Salida:**  
```
Valor: 1
Valor: 2
Valor: 3
Valor: 4
Valor: 6
Valor: 7
Valor: 8
Valor: 9
Valor: 10
Se uso 'continue' para omitir la impresion del 5.
```  

---

# 2. **Arreglos**  

Los **arreglos (arrays)** permiten **almacenar múltiples valores** del mismo tipo en una sola estructura, proporcionando **acceso directo a cada elemento** mediante un índice. Son útiles cuando se necesita manejar **grupos de datos homogéneos**.  

---

## **Declaración de un arreglo**  

### Sintaxis: <!-- omit in toc -->  

```cpp
tipo nombre_arreglo[tamaño];
```  

📌 **Ejemplo:** Declarar un **arreglo unidimensional de 5 elementos**.  

```cpp
#include <iostream>
using namespace std;

int main() {
    int i, a[5];

    // Leer 5 valores
    for (i = 0; i < 5; i++) {
        cout << "a[" << i + 1 << "]= ";
        cin >> a[i];
    }

    // Imprimir los valores en orden inverso
    cout << "Los números en orden inverso: ";
    for (i = 4; i >= 0; i--)
        cout << a[i] << " ";

    return 0;
}
```

📌 **Ejemplo de entrada y salida:**  
```
a[1]= 7  
a[2]= 2  
a[3]= 9  
a[4]= 4  
a[5]= 5  
Los números en orden inverso: 5 4 9 2 7  
```

---

## **Inicialización de arreglos**  

### Sintaxis: <!-- omit in toc -->  

```cpp
tipo nombre_arreglo[fila][columna] = { {valores fila 1}, {valores fila 2}, ... };
```

📌 **Ejemplos:**  

```cpp
int a[2][3] = { {1,2,3}, {4,5,6} };  
int b[2][3] = { 1,2,3,4,5 };  // El último valor se llena con 0 automáticamente  
int c[2][3] = { {1,2}, {4} }; // Los valores faltantes son 0  
```

📌 **Valores de los arreglos por fila:**  

- **Arreglo `a`**  
```
1 2 3  
4 5 6  
```

- **Arreglo `b`**  
```
1 2 3  
4 5 0  
```

- **Arreglo `c`**  
```
1 2 0  
4 0 0  
```

📌 **Ejemplo en código:**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int i, j;
    int a[2][3] = { {1,2,3}, {4,5,6} };
    int b[2][3] = { 1,2,3,4,5 };  
    int c[2][3] = { {1,2}, {4} };

    cout << "Arreglo a:" << endl;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            cout << a[i][j] << " ";
        cout << endl;
    }

    cout << "Arreglo b:" << endl;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            cout << b[i][j] << " ";
        cout << endl;
    }

    cout << "Arreglo c:" << endl;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            cout << c[i][j] << " ";
        cout << endl;
    }

    return 0;
}
```

📌 **Salida esperada:**  
```
Arreglo a:  
1 2 3  
4 5 6  

Arreglo b:  
1 2 3  
4 5 0  

Arreglo c:  
1 2 0  
4 0 0  
```

---

> [!IMPORTANT]
> Si necesitas una estructura más flexible, usa **`std::vector`** o **`std::array`** en lugar de arreglos tradicionales. Estas estructuras forman parte de la **STL (Standard Template Library)** y ofrecen mayor seguridad y funcionalidad. Para utilizarlas, es necesario incluir las librerías correspondientes: `#include <array>` para `std::array` y `#include <vector>` para `std::vector`.
>

---

### 🚀 **Ejemplo 1: Suma de dos matrices en C++** 

```cpp
#include <iostream>
using namespace std;

int main() {
    int filas, columnas;

    // Solicitar dimensiones de la matriz
    cout << "Ingresa el número de filas: ";
    cin >> filas;
    cout << "Ingresa el número de columnas: ";
    cin >> columnas;

    int matriz1[filas][columnas], matriz2[filas][columnas], resultado[filas][columnas];

    // Leer la primera matriz
    cout << "Ingresa los valores de la primera matriz:" << endl;
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            cout << "Matriz1[" << i << "][" << j << "]: ";
            cin >> matriz1[i][j];
        }
    }

    // Leer la segunda matriz
    cout << "Ingresa los valores de la segunda matriz:" << endl;
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            cout << "Matriz2[" << i << "][" << j << "]: ";
            cin >> matriz2[i][j];
        }
    }

    // Sumar ambas matrices
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            resultado[i][j] = matriz1[i][j] + matriz2[i][j];
        }
    }

    // Mostrar la matriz resultante
    cout << "Matriz resultante (suma de ambas matrices):" << endl;
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            cout << resultado[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
```

---

📌 **Salida:**  

```
Ingresa el número de filas: 2  
Ingresa el número de columnas: 2  

Ingresa los valores de la primera matriz:  
Matriz1[0][0]: 1  
Matriz1[0][1]: 2  
Matriz1[1][0]: 3  
Matriz1[1][1]: 4  

Ingresa los valores de la segunda matriz:  
Matriz2[0][0]: 5  
Matriz2[0][1]: 6  
Matriz2[1][0]: 7  
Matriz2[1][1]: 8  

Matriz resultante (suma de ambas matrices):  
6 8  
10 12  
```

---

## 🧩 **Problemas de Arreglos Propuestos en C++**  

---  

### 🏅 **Problema arreglo01: Mayor y Menor** | 🛡️ **Novato** <!-- omit in toc -->  

🔹 **Descripción:** Lee `n` números y encuentra el **mayor** y el **menor** valor del arreglo.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de números: 5
Número 1: 8
Número 2: 3
Número 3: 15
Número 4: 7
Número 5: 10
Mayor: 15
Menor: 3
```  

> [!TIP]  
> Usa un `for` para recorrer el arreglo y comparar valores.  

---  

### 🏅 **Problema arreglo02: Promedio de Calificaciones** | ⚔️ **Guerrero** <!-- omit in toc -->  

🔹 **Descripción:** Dado un arreglo con `n` calificaciones, calcula el **promedio** y muestra cuáles están por encima y por debajo de la media.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de calificaciones: 4
Calificación 1: 80
Calificación 2: 90
Calificación 3: 75
Calificación 4: 85
Promedio: 82.5
Por encima del promedio: 90, 85
Por debajo del promedio: 80, 75
```  

> [!TIP]  
> Usa un `for` para sumar los valores y calcular el promedio. Luego, usa un segundo `for` para imprimir las calificaciones por encima del promedio y un tercer `for` para las calificaciones por debajo de la media.  

---  

### 🏅 **Problema arreglo03: Matriz Transpuesta** | 🔥 **Experto** <!-- omit in toc -->  

🔹 **Descripción:** Dada una matriz `n x m`, genera su **matriz transpuesta**, es decir, intercambia sus filas y columnas.  

📌 **Ejemplo:**  
```
Matriz original:
1  2  3  
4  5  6  

Matriz transpuesta:
1  4  
2  5  
3  6  
```  

> [!TIP]  
> Usa dos `for` anidados para intercambiar `matriz[i][j]` por `matriz[j][i]`.  

---  

### 🏅 **Problema arreglo04: Eliminación de Duplicados** | 👑 **Leyenda** <!-- omit in toc -->  

🔹 **Descripción:** Dado un arreglo con `n` números, **elimina los duplicados** y muestra el resultado sin repetir elementos.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de números: 8
Ingresa los números:
2 5 3 2 8 5 3 10

Arreglo sin duplicados: 2 5 3 8 10
```  

> [!TIP]
> Tu puedes!
> 
---

# 3. **Uso de `auto` para Inferencia de Tipos**

La palabra clave **`auto`** en C++ permite que el compilador **deduzca automáticamente** el tipo de una variable en función de su valor inicial. Esto hace que el código sea más limpio y fácil de mantener, especialmente cuando se trabaja con tipos complejos o al iterar sobre contenedores como arreglos o cadenas.

📌 **Ejemplo:** 

```cpp
#include <iostream>

using namespace std;

int main() {
    int a[] = {1, 5, 7, 8, 12, 33};  // Arreglo de enteros
    string pedro = R"(Mi
nombre
es
pedro)";  // Cadena multilínea
    
    cout << pedro << endl;
    
    // Uso de 'auto' para iterar sobre los elementos del arreglo
    for (auto i : a) {
        cout << i << endl;  // 'i' es deducido como int
    }
    
    // Uso de 'auto' para iterar sobre los caracteres de la cadena
    for (auto i : pedro) {
        cout << (int)i << " " << i << endl;  // 'i' es deducido como char
    }
    
    return 0;
}
```

📌 **Salida:** 

```
Mi
nombre
es
pedro
1
5
7
8
12
33
77 M
105 i
10

110 n
111 o
109 m
98 b
114 r
101 e
10

101 e
115 s
10

112 p
101 e
100 d
114 r
111 o
```

<details><summary>👨‍🏫 Explicación</summary>

- Declara un arreglo `a[]` con enteros `{1, 5, 7, 8, 12, 33}`.  
- Declara una cadena multilínea `pedro` usando `R"(...)"`.  
- Imprime la cadena `pedro` tal como está.  
- Itera sobre el arreglo `a[]` usando `auto`, lo que permite que el compilador infiera que `i` es un `int`, e imprime cada número.  
- Itera sobre la cadena `pedro` usando `auto`, que en este caso infiere `i` como `char`, e imprime el valor ASCII y el carácter de cada letra.  

</details>

---

# 4. **Punteros**

Variables que contienen una dirección de memoria como su valor.

> [!IMPORTANT]  
> Los punteros en **C++** son una herramienta sumamente poderosa que permite **manipular directamente la memoria**. A diferencia de otros lenguajes de alto nivel, donde la gestión de memoria es automática, en C++ **tienes control total** sobre la asignación y liberación de memoria. Sin embargo, como se menciona en la película *Spider-Man* (2002): "[No lo olvides, un gran poder conlleva una gran responsabilidad](https://youtu.be/kfRIn8rlFgU?feature=shared&t=60)". 


Hay dos operadores importantes para los punteros:

- `&` (dirección de): devuelve la dirección del objeto dado como operando
- `*` (desreferenciar): devuelve el objeto que se encuentra en la dirección dada por el operando

### **Ejemplo básico**

```cpp
#include <iostream>

using namespace std;

int main() {
    int i = 16;
    int *pi;
    pi = &i;
    cout << *pi << endl;
    return 0;
}
```

**Salida esperada:**
```
16
```

<details><summary>👨‍🏫 Explicación</summary>

Este programa muestra cómo utilizar un puntero para acceder al valor de una variable en **C++**. A continuación, se explican los conceptos clave del código:

1. **Declaración de la variable `i` y el puntero `pi`**:
   - `int i = 16;` declara una variable entera `i` con el valor `16`.
   - `int *pi;` declara un puntero `pi` que almacenará la dirección de una variable de tipo `int`.

2. **Asignación de la dirección de `i` al puntero `pi`**:
   - `pi = &i;` asigna a `pi` la dirección de memoria de `i` utilizando el operador `&` (operador de dirección). Ahora, `pi` apunta a la ubicación en memoria donde se encuentra `i`.

3. **Desreferenciación del puntero (`*pi`)**:
   - `cout << *pi << endl;` utiliza el operador `*` (operador de desreferenciación) para acceder al valor almacenado en la dirección de memoria a la que apunta `pi`, en este caso, `16`.  
   - Es decir, `*pi` equivale a `i`, por lo que se imprime `16`.

4. **Flujo de ejecución**:
   - Se declara `i` y se le asigna `16`.
   - Se declara el puntero `pi`.
   - Se almacena la dirección de `i` en `pi`.
   - Se imprime el valor almacenado en la dirección apuntada por `pi`, que es `16`.

En resumen, este programa demuestra cómo los punteros pueden usarse para **acceder y manipular directamente la memoria** en C++, permitiendo un mayor control sobre los datos almacenados.

</details>  

## **Aritmética de punteros**

En C++, los punteros pueden usarse en expresiones aritméticas.

Esta aritmética no es solo suma o resta simple; tiene en cuenta el tamaño del tipo de dato al que apunta el puntero.

---

### **Operaciones básicas de aritmética de punteros**  

```cpp
#include <iostream>

using namespace std;

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    int *ptr = arr;
    
    // Imprimir el arreglo antes de modificarlo
    cout << "Arreglo original: ";
    for (int i = 0; i < 5; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    ptr++; // Ahora ptr apunta a arr[1]
    
    cout << "El valor al que apunta ptr (arr[1]) es: " << *ptr << endl;

    // Acceder a otros elementos usando aritmética de punteros
    cout << "El siguiente elemento es: " << *(ptr + 1) << endl; // Equivalente a arr[2]
    cout << "El elemento anterior es: " << *(ptr - 1) << endl; // Equivalente a arr[0]

    // Modificar un elemento usando el puntero
    *ptr = 10; // Cambia el valor de arr[1] a 10

    // Imprimir el arreglo modificado
    cout << "Arreglo modificado: ";
    for (int i = 0; i < 5; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
```

**Salida esperada:**
```
Arreglo original: 1 2 3 4 5 
El valor al que apunta ptr (arr[1]) es: 2
El siguiente elemento es: 3
El elemento anterior es: 1
Arreglo modificado: 1 10 3 4 5 
```

<details><summary>👨‍🏫 Explicación</summary>

Este programa demuestra cómo realizar operaciones básicas con punteros y cómo modificar un arreglo mediante **aritmética de punteros** en **C++**. A continuación, se explican los conceptos clave:

1. **Inicialización del arreglo y del puntero**:
   - `int arr[5] = {1, 2, 3, 4, 5};` define un arreglo de cinco enteros.
   - `int *ptr = arr;` inicializa el puntero `ptr` apuntando al **primer elemento** del arreglo (`arr[0]`).  

2. **Impresión del arreglo original**:
   - Se recorre el arreglo con un `for` y se imprime cada elemento.  

3. **Aritmética de punteros: desplazamiento en memoria**:
   - `ptr++;` mueve el puntero una posición adelante, ahora apunta a `arr[1]` (el valor `2`).  
   - `cout << *ptr;` imprime el valor al que apunta `ptr`, que es `2`.  
   - `*(ptr + 1);` accede al siguiente elemento (`arr[2]`, que es `3`).  
   - `*(ptr - 1);` accede al elemento anterior (`arr[0]`, que es `1`).  

4. **Modificación del arreglo usando el puntero**:
   - `*ptr = 10;` cambia el valor de `arr[1]` de `2` a `10`.  
   - Como `ptr` apunta a `arr[1]`, la modificación se refleja directamente en el arreglo original.  

5. **Impresión del arreglo modificado**:
   - Se recorre nuevamente el arreglo y se imprime su contenido, mostrando el cambio en `arr[1]`.  

En resumen, este programa ilustra cómo los punteros permiten **navegar y modificar un arreglo sin necesidad de índices**, simplemente desplazando el puntero en la memoria.  

</details>  

---

### **Otras operaciones con punteros**  

```cpp
#include <iostream>

using namespace std;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int *ptr = arr;

    // Mostrar la dirección inicial y el valor al que apunta
    cout << "Dirección inicial de ptr: " << ptr << " | Valor: " << *ptr << endl;

    // Incrementar un puntero
    ptr++;
    cout << "Después de incrementar, ptr apunta a: " << *ptr << " (Dirección: " << ptr << ")" << endl;

    // Sumar un entero a un puntero
    ptr += 2; // Ahora apunta a arr[3]
    cout << "Después de sumar 2, ptr apunta a: " << *ptr << " (Dirección: " << ptr << ")" << endl;

    // Restar un entero a un puntero
    ptr -= 1; // Ahora apunta a arr[2]
    cout << "Después de restar 1, ptr apunta a: " << *ptr << " (Dirección: " << ptr << ")" << endl;

    // Restar dos punteros
    int *ptr1 = &arr[1];
    int *ptr2 = &arr[4];
    int difference = ptr2 - ptr1; // Diferencia en términos de elementos
    cout << "Diferencia entre ptr2 y ptr1: " << difference << " elementos" << endl;

    return 0;
}
```

**Salida esperada:**  
```
Dirección inicial de ptr: 0x12345678 | Valor: 10
Después de incrementar, ptr apunta a: 20 (Dirección: 0x1234567C)
Después de sumar 2, ptr apunta a: 40 (Dirección: 0x12345684)
Después de restar 1, ptr apunta a: 30 (Dirección: 0x12345680)
Diferencia entre ptr2 y ptr1: 3 elementos
```

> [!NOTE]
>   
> Las direcciones de memoria en la salida son solo un ejemplo, así que no te preocupes si ves algo diferente al ejecutar el código. 😉  


<details><summary>👨‍🏫 Explicación</summary>

Este programa muestra **operaciones básicas con punteros** en C++, como desplazamientos y diferencias entre punteros.

1. **Inicialización del puntero**  
   - `ptr` apunta al primer elemento del arreglo `arr[0]`.

2. **Incremento (`ptr++`)**  
   - Avanza una posición en el arreglo (`arr[1]` → `20`).

3. **Suma (`ptr += 2`)**  
   - Mueve el puntero dos posiciones adelante (`arr[3]` → `40`).

4. **Resta (`ptr -= 1`)**  
   - Retrocede una posición (`arr[2]` → `30`).

5. **Diferencia entre punteros (`ptr2 - ptr1`)**  
   - Calcula cuántos **elementos** separan `arr[1]` y `arr[4]` (3 elementos).

</details>  

---

## 🧩 **Problemas de Punteros Propuestos en C++**  

---

### 🏅 **Problema puntero01: Suma de Elementos con Punteros** | ⚔️ **Guerrero** <!-- omit in toc -->  

🔹 **Descripción:** Dado un arreglo de `n` números, usa **punteros** para calcular la **suma total**.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de números: 4
Número 1: 3
Número 2: 7
Número 3: 2
Número 4: 5
Suma total: 17
```  

> [!TIP]  
> Usa un puntero para recorrer el arreglo y sumar los valores.  

---

### 🏅 **Problema puntero02: Inversión de un Arreglo** | 🔥 **Experto** <!-- omit in toc -->  

🔹 **Descripción:** Dado un arreglo, usa **punteros** para invertir su contenido.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de números: 5
Números originales: 1 2 3 4 5
Números invertidos: 5 4 3 2 1
```  

> [!TIP]  
> Usa dos punteros: uno al inicio y otro al final, intercambiando valores hasta la mitad del arreglo.  

---

### 🏅 **Problema puntero03: Búsqueda en un Arreglo con Punteros** | 👑 **Leyenda** <!-- omit in toc -->  

🔹 **Descripción:** Dado un arreglo y un número a buscar, usa punteros para verificar si el número está presente y en qué posición.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de números: 6
Ingresa los números: 4 8 15 16 23 42
Ingresa el número a buscar: 15
El número 15 se encuentra en la posición 3.
```  

> [!TIP]  
> Usa un puntero para recorrer el arreglo y comparar cada elemento con el número buscado.  

---

# 5. **Referencias**  

Las **referencias** en **C++** permiten crear un alias para una variable existente, lo que significa que cualquier operación sobre la referencia afecta directamente a la variable original.  

> [!NOTE]
>
> Las referencias son una característica nueva en C++ y no existen en C. Fueron introducidas para facilitar la manipulación de variables sin necesidad de punteros, mejorando la legibilidad y seguridad del código.

📌 **Diferencia clave con los punteros:**  
- Una referencia **no puede ser `nullptr`**.  
- Una vez inicializada, **no puede cambiar de objeto** al que hace referencia.  
- Su sintaxis es más sencilla y directa que la de los punteros.  

---

### Sintaxis: <!-- omit in toc -->   

```cpp
tipo &nombreReferencia = variable;
```  

📌 **Explicación:**  
- `tipo`: El tipo de dato de la referencia debe coincidir con el de la variable original.  
- `&nombreReferencia`: Declara una referencia.  
- `variable`: Es la variable a la que hace referencia.  

---

### 🚀 **Ejemplo 1: Referencia a una variable**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int valor = 10;
    int &ref = valor;  // 'ref' es una referencia a 'valor'

    cout << "Valor original: " << valor << endl;
    cout << "Referencia: " << ref << endl;

    ref = 20;  // Cambia el valor de 'valor' a través de la referencia

    cout << "Nuevo valor: " << valor << endl;
    return 0;
}
```  

📌 **Salida:**  
```
Valor original: 10
Referencia: 10
Nuevo valor: 20
```  

<details><summary>👨‍🏫 Explicación</summary>

- `int &ref = valor;` → `ref` se comporta como un alias de `valor`, por lo que cualquier operación sobre `ref` afecta directamente a `valor`.  
- Modificar `ref` **también modifica `valor`**, ya que ambas representan la misma variable en memoria.  

</details>

---

## **Referencias constantes (`const &`)**  <!-- omit in toc -->

Si no queremos modificar la variable original pero tampoco queremos hacer una copia, podemos usar **referencias constantes**.  

---

### 🚀 **Ejemplo 2: Uso de `const &`**  


```cpp
#include <iostream>
using namespace std;

int main() {
    int valor = 50;
    const int &ref = valor;  // Referencia constante a 'valor'

    cout << "Valor original: " << valor << endl;
    cout << "Referencia constante: " << ref << endl;

    // ref = 100;  // Esto daría error porque 'ref' es constante

    valor = 75;  // Se puede modificar 'valor' directamente

    cout << "Nuevo valor de 'valor': " << valor << endl;
    cout << "La referencia constante refleja el cambio: " << ref << endl;

    return 0;
}
```

📌 **Salida esperada:**  
```
Valor original: 50
Referencia constante: 50
Nuevo valor de 'valor': 75
La referencia constante refleja el cambio: 75
```

<details><summary>👨‍🏫 Explicación</summary>

- `const int &ref = valor;` → `ref` es una **referencia constante**, lo que significa que **no se puede modificar `valor` a través de `ref`**.  
- **Sin embargo**, `valor` **sí puede cambiar**, y como `ref` es solo un alias de `valor`, reflejará el nuevo valor automáticamente.  
- **Intentar hacer `ref = 100;` generaría un error de compilación**, ya que `ref` es constante.  

</details>

---

## **Comparación entre referencias y punteros**  

| Característica | Referencias (`&`) | Punteros (`*`) |
|--------------|----------------|--------------|
| Puede ser `nullptr` | ❌ No | ✅ Sí |
| Puede cambiar de objeto | ❌ No | ✅ Sí |
| Más seguro y fácil de leer | ✅ Sí | ❌ No |
| Necesita `*` para acceder al valor | ❌ No | ✅ Sí |

# 6. **Funciones**

Las funciones permiten reutilizar código dentro de un programa. Una función en **C++** está compuesta por:  

- Tipo de retorno  
- Nombre de la función  
- Lista de parámetros  
- Cuerpo de la función  

```cpp
tipo_retorno nombre_funcion(param1, param2, ...) {
    ...
    cuerpo_de_la_función;
    ...
}
```

### **Ejemplo:**  <!-- omit in toc -->

```cpp
#include <iostream>

using namespace std;

// Función para sumar dos números
int sumar(int num1, int num2) {
    return num1 + num2;
}

int main() {
    int a = 5, b = 3;
    cout << "La suma de " << a << " y " << b << " es: " << sumar(a, b) << endl;

    int c = 10, d = 7;
    cout << "La suma de " << c << " y " << d << " es: " << sumar(c, d) << endl;

    cout << "La suma de 20 y 15 es: " << sumar(20, 15) << endl;
    cout << "La suma de -5 y 8 es: " << sumar(-5, 8) << endl;
    cout << "La suma de 0 y 0 es: " << sumar(0, 0) << endl;

    return 0;
}
```

> [!IMPORTANT]
>
> Es fundamental comprender la diferencia entre un *parámetro* y un *argumento* para evitar confusiones:
> 
> - **Parámetros**: Son las variables que aparecen en la definición de la función. En este código, `num1` y `num2` en `sumar(int num1, int num2)` son parámetros.
> - **Argumentos**: Son los valores reales que se pasan a la función cuando esta es invocada. En este código, `a`, `b`, `c`, `d`, `20, 15`, `-5, 8`, etc., son argumentos porque representan los datos específicos que se envían a la función al momento de su llamada.
>
> Es común confundirlos, pero la diferencia clave es que los **parámetros** existen en la **definición** de la función, mientras que los **argumentos** aparecen en la **llamada**.

> [!NOTE]
> 
> Cuando te hablen de la **firma** (*signature*) de una función, recuerda que simplemente se refiere a su nombre y la cantidad, tipo y orden de sus parámetros. No incluye el tipo de retorno.  
> 
> En el ejemplo anterior, la firma de la función `sumar` es `sumar(int, int)`, lo que significa que recibe dos enteros como parámetros.

---

## **Métodos de paso de argumentos**  

En **C++**, los parámetros de una función pueden pasarse de tres maneras:  

### **Paso por valor**  

Este es el método predeterminado. Se pasa una copia del valor del argumento a la función, por lo que **las modificaciones dentro de la función no afectan al argumento original**.  

#### Ejemplo: <!-- omit in toc -->  

```cpp
#include <iostream>

using namespace std;

void intercambiar(int x, int y) {
    int temp = x;
    x = y;
    y = temp;
}

int main() {
    int a = 4, b = 5;
    intercambiar(a, b);
    cout << "Después de la función:\na = " << a << "\nb = " << b << endl;
    return 0;
}
```

**Salida esperada:**  
```
Después de la función:
a = 4
b = 5
```

> [!NOTE]
> 
> Como `x` e `y` son copias, el intercambio **no afecta** a `a` y `b`.
>

---

### **Paso por referencia con punteros**  

Aquí se pasa la dirección de los argumentos a la función usando **punteros**. Esto permite modificar los valores originales.  

#### Ejemplo:  <!-- omit in toc -->  

```cpp
#include <iostream>

using namespace std;

void intercambiar(int* x, int* y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main() {
    int a = 4, b = 5;
    intercambiar(&a, &b);
    cout << "Después de la función:\na = " << a << "\nb = " << b << endl;
    return 0;
}
```

**Salida esperada:**  
```
Después de la función:
a = 5
b = 4
```

> [!NOTE]
> 
> Aquí sí se intercambian los valores, ya que se están modificando directamente en memoria.
> 

---

### **Paso por referencia con referencias**  

Este método utiliza **referencias (`&`)** en lugar de punteros, lo que simplifica el código sin perder eficiencia.  

#### Ejemplo:  <!-- omit in toc -->  

```cpp
#include <iostream>

using namespace std;

void intercambiar(int &x, int &y) {
    int temp = x;
    x = y;
    y = temp;
}

int main() {
    int a = 4, b = 5;
    intercambiar(a, b);
    cout << "Después de la función:\na = " << a << "\nb = " << b << endl;
    return 0;
}
```

**Salida esperada:**  
```
Después de la función:
a = 5
b = 4
```
> [!NOTE]
> 
> Al pasar por referencia, `a` y `b` se modifican **sin necesidad de usar punteros**.

---

## 📌 Conclusión <!-- omit in toc -->

| Método | ¿Modifica el valor original? | Complejidad |
|--------|-----------------------------|------------|
| **Por valor (`int x`)** | ❌ No | Baja (se crea una copia) |
| **Por referencia con punteros (`int* x`)** | ✅ Sí | Media (requiere `&` y `*`) |
| **Por referencia con referencias (`int &x`)** | ✅ Sí | Baja (más intuitivo que punteros) |

> [!IMPORTANT]
> 
> Si necesitas proteger el valor original, usa **paso por valor**.  
> Si quieres modificarlo sin copias, usa **paso por referencia (con punteros o referencias)**.  

---
## 🧩 **Problemas de Funciones Propuestos en C++**  

---

### 🏅 **Problema función01: Conversión de Tiempo** | ⏳ **Novato** <!-- omit in toc -->  

🔹 **Descripción:** Crea una función `convertirTiempo` que reciba una cantidad de **segundos** y devuelva su equivalente en **horas, minutos y segundos**.  

📌 **Ejemplo:**  
```
Ingresa los segundos: 3661
Resultado: 1 horas, 1 minutos, 1 segundos
```  

📌 **Nombre de la función:** `convertirTiempo`  
📌 **Lista de parámetros:** `(int segundos, int &horas, int &minutos, int &segundos)`  

> [!TIP]  
> Desglosa el tiempo en partes: los **segundos totales** se pueden dividir para obtener las **horas** y el **resto de segundos**. Luego, haz lo mismo para calcular los **minutos** y los **segundos finales**. Asegúrate de que la función pueda manejar diferentes valores de entrada, incluyendo `0` segundos. 🚀  

---

### 🏅 **Problema función02: Operaciones con Arreglos** | 📊 **Experto** <!-- omit in toc -->  

🔹 **Descripción:** Crea una función `calcularOperaciones` que reciba un **arreglo de números** y devuelva la **suma**, el **promedio** y el **mayor número**.  

📌 **Ejemplo:**  
```
Ingresa la cantidad de números: 4
Números: 10 20 30 40
Suma: 100
Promedio: 25
Mayor: 40
```  

📌 **Nombre de la función:** `calcularOperaciones`  
📌 **Lista de parámetros:** `(int arr[], int n, int &suma, float &promedio, int &mayor)`  

> [!TIP]  
> Usa un `for` para recorrer el arreglo y calcular los valores requeridos en una sola pasada. Ten en cuenta que el primer número leído puede ser el **mayor** temporalmente hasta que encuentres uno más grande. También, asegúrate de manejar casos donde el arreglo tenga solo un número. 🚀  

---

### 🏅 **Problema función03: Cálculo de Interés Compuesto** | 💰 **Maestro** <!-- omit in toc -->  

🔹 **Descripción:** Crea una función `calcularInteresCompuesto` que reciba el **capital inicial**, la **tasa de interés** y los **años**, y calcule el **monto final** aplicando **interés compuesto**.  

📌 **Ejemplo:**  
```
Capital inicial: 1000
Tasa de interés anual: 5%
Años: 3
Monto total: 1157.63
```  

📌 **Nombre de la función:** `calcularInteresCompuesto`  
📌 **Lista de parámetros:** `(double capital, double tasa, int años) -> retorna double`  

> [!TIP]  
> Usa la fórmula `M = C * (1 + r/100)^t` y la función `pow()` de `<cmath>`. 🚀  

---

### 🏅 **Problema función04: Cálculo de Área y Perímetro de un Rectángulo** | 📏 **Leyenda** <!-- omit in toc -->  

🔹 **Descripción:** Crea una función `calcularRectangulo` que reciba el **largo** y **ancho** de un rectángulo y devuelva su **área** y **perímetro**.  

📌 **Ejemplo:**  
```
Largo: 5
Ancho: 3
Área: 15
Perímetro: 16
```  

📌 **Nombre de la función:** `calcularRectangulo`  
📌 **Lista de parámetros:** `(double largo, double ancho, double &area, double &perimetro)`  

> [!TIP]  
> Usa las fórmulas `área = largo * ancho` y `perímetro = 2 * (largo + ancho)`. Asegúrate de probar la función con diferentes valores, incluyendo rectángulos con lados iguales. 🚀  

---

### 🏅 **Problema función05: Cifrado César** | 🔐 **Gran Maestro** <!-- omit in toc -->  

🔹 **Descripción:** Crea una función `cifrarCesar` que reciba una **cadena** y un **desplazamiento `n`** y la cifre usando **Cifrado César**.  

📌 **Ejemplo:**  
```
Texto original: HOLA
Desplazamiento: 3
Texto cifrado: KROD
```  

📌 **Nombre de la función:** `cifrarCesar`  
📌 **Lista de parámetros:** `(string texto, int desplazamiento) -> retorna string`  

> [!TIP]  
> Usa `isalpha(c)` para verificar si un carácter es una letra antes de cifrarlo. Ajusta los valores con `mod 26` para evitar desbordamientos y mantener el cifrado dentro del alfabeto. 🚀  

---

# 7. **Asignación dinámica de memoria en C++**  

La **asignación dinámica de memoria** ocurre cuando se reserva memoria en **tiempo de ejecución** usando una función de la biblioteca estándar. En **C++**, esto se logra con los operadores `new` y `delete`.  

---

## **Asignación de memoria dinámica**  

Para crear objetos dinámicos en C++, se usa la palabra clave **`new`**.  

📌 **Ejemplo 1: Reservar memoria para un solo entero**  

```cpp
int *p = new int;
```

> [!NOTE]
> 
> Esto asigna **memoria sin nombre** para almacenar un valor de tipo `int` y devuelve la dirección de esa memoria.  

📌 **Ejemplo 2: Reservar memoria para un array dinámico**  

```cpp
int *q = new int[128];
```

Esta línea reserva **memoria para un arreglo de 128 elementos de tipo `int`**.  

---

## **Liberación de memoria dinámica**  

Para evitar **fugas de memoria**, es importante liberar la memoria asignada con `delete`.  

> [!NOTE]
> 
> Si no liberas la memoria asignada con `new`, seguirá ocupando espacio incluso cuando ya no la necesites, causando **fugas de memoria**. Esto puede ralentizar el sistema y, en casos extremos, hacer que el programa **colapse**. Siempre que uses `new`, asegúrate de usar `delete` para liberar la memoria. 🚀


📌 **Ejemplo:**  

```cpp
delete p;      // Libera la memoria de un solo entero
delete[] q;    // Libera la memoria de un array dinámico
```

---

## **Aplicación práctica: Memoria estática vs dinámica en C++**  

En esta práctica, comparamos el uso de **memoria dinámica** y **memoria estática** en C++ para almacenar los promedios de un grupo de estudiantes. Ambas versiones del programa permiten ingresar y visualizar los promedios, pero difieren en cómo gestionan la memoria.  

---

### **Versión dinámica**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numEstudiantes;

    cout << "Ingrese el número de estudiantes: ";
    cin >> numEstudiantes;

    // Reservar memoria para un array dinámico de promedios
    float *promedios = new float[numEstudiantes];

    // Verificar si la asignación de memoria fue exitosa
    if (!promedios) {
        cerr << "Error: No se pudo asignar memoria.\n";
        return 1;
    }

    // Ingresar los promedios de los estudiantes
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Promedio del estudiante " << i + 1 << ": ";
        cin >> promedios[i];
    }

    // Imprimir los promedios
    cout << "\nPromedios de los estudiantes:\n";
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Estudiante " << i + 1 << ": " << promedios[i] << endl;
    }

    // Liberar la memoria asignada dinámicamente
    delete[] promedios;

    return 0;
}
```

<details><summary>👨‍🏫 Explicación</summary>

- Se usa `new float[numEstudiantes]` para **reservar memoria dinámica**, permitiendo definir el tamaño del arreglo en tiempo de ejecución.  
- Se verifica si la asignación de memoria fue exitosa para evitar **errores en tiempo de ejecución**.  
- Se capturan e imprimen los promedios ingresados por el usuario.  
- Finalmente, se libera la memoria con `delete[] promedios` para **evitar fugas de memoria**, asegurando un uso eficiente de los recursos.  

</details>

---

### **Versión estática**  

En esta versión, usamos memoria estática para almacenar los promedios de los estudiantes, como lo hacíamos convencionalmente. A diferencia de la memoria dinámica, el tamaño del arreglo es fijo y, una vez creado, no puede modificarse ni liberarse para devolver la memoria al sistema.

```cpp
#include <iostream>
using namespace std;

#define MAX_ESTUDIANTES 100  // Tamaño máximo del array

int main() {
    int numEstudiantes;
    float promedios[MAX_ESTUDIANTES];

    cout << "Ingrese el número de estudiantes (máximo " << MAX_ESTUDIANTES << "): ";
    cin >> numEstudiantes;

    if (numEstudiantes > MAX_ESTUDIANTES) {
        cout << "El número de estudiantes supera el límite.\n";
        return 1;
    }

    // Ingresar los promedios de los estudiantes
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Promedio del estudiante " << i + 1 << ": ";
        cin >> promedios[i];
    }

    // Imprimir los promedios
    cout << "\nPromedios de los estudiantes:\n";
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Estudiante " << i + 1 << ": " << promedios[i] << endl;
    }

    return 0;
}
```

<details><summary>👨‍🏫 Explicación</summary>

- Se declara un **arreglo estático** con un tamaño máximo definido (`MAX_ESTUDIANTES = 100`).  
- El usuario ingresa la cantidad de estudiantes, pero **no se puede superar el límite predefinido**.  
- Se capturan e imprimen los promedios de los estudiantes, igual que en la versión dinámica.  
- **No es necesario liberar memoria manualmente**, ya que el arreglo se destruye automáticamente cuando el programa finaliza.  

</details>

---

## **Diferencias clave entre memoria dinámica y estática**  <!-- omit in toc -->

| Característica | Memoria Dinámica (`new`) | Memoria Estática (Array fijo) |
|---------------|-------------------------|------------------------------|
| **Tamaño ajustable en ejecución** | ✅ Sí | ❌ No |
| **Eficiencia en uso de memoria** | ✅ Mejor | ❌ Puede desperdiciar espacio |
| **Riesgo de fuga de memoria** | ❌ Sí (si no se usa `delete`) | ✅ No |
| **Velocidad de acceso** | 🔄 Ligeramente más lenta | ⚡ Más rápida |

---

> [!IMPORTANT]
> 
> - Usa **memoria dinámica (`new`)** cuando **no conoces el tamaño exacto** en tiempo de compilación.  
> - Usa **memoria estática (arrays normales)** si el tamaño es fijo y conocido.  
> - **Siempre** libera la memoria con `delete` para evitar **fugas de memoria**. 🚀

# 8. **Templates**  

Los **templates** en **C++** permiten parametrizar funciones o clases para trabajar con diferentes tipos de datos sin duplicar código.  

> [!NOTE]
> 
> Los templates proporcionan flexibilidad y reutilización, permitiendo definir algoritmos genéricos sin especificar un tipo de dato concreto.  

---

### 🚀 **Ejemplo 1: Función genérica para encontrar el máximo**  

```cpp
#include <iostream>
#include <string>

using namespace std;

template <typename T>
T maximum(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    string x{"Hello"};
    string y{"World"};
    auto result = maximum(x, y);

    cout << "Entre \"" << x << "\" y \"" << y << "\", el resultado es: " << result << endl;

    // Pruebas con otros tipos
    int a = 10, b = 25;
    double d1 = 3.5, d2 = 7.8;
    char c1 = 'A', c2 = 'Z';

    cout << "Entre " << a << " y " << b << ", el resultado es: " << maximum(a, b) << endl;
    cout << "Entre " << d1 << " y " << d2 << ", el resultado es: " << maximum(d1, d2) << endl;
    cout << "Entre '" << c1 << "' y '" << c2 << "', el resultado es: " << maximum(c1, c2) << endl;

    return 0;
}
```

<details><summary>👨‍🏫 Explicación</summary>

- `template <typename T>` permite definir una función genérica que puede trabajar con distintos tipos de datos.  
- La función `maximum(T a, T b)` compara dos valores del mismo tipo y devuelve el mayor.  
- `auto` se usa para deducir automáticamente el tipo de `result` en `main()`.  
- Se demuestra su uso con **`int`**, **`double`**, **`char`** y **`string`**, mostrando que funciona de forma genérica sin necesidad de sobrecargas manuales.  

</details>

📌 **Salida:**  
```
Entre "Hello" y "World", el resultado es: World
Entre 10 y 25, el resultado es: 25
Entre 3.5 y 7.8, el resultado es: 7.8
Entre 'A' y 'Z', el resultado es: Z
```

---

### 🚀 **Ejemplo 2: Función genérica para intercambiar valores**  

```cpp
#include <iostream>
using namespace std;

template <class T>
void mySwap(T &x, T &y) {  
    T t = x; x = y; y = t;
}

int main() {
    int a = 10, b = 20;
    double d = 10.0, e = 20.0;
    char c = 'a', s = 'b';

    mySwap(a, b); mySwap(d, e); mySwap(c, s);

    cout << "a = " << a << "   b = " << b << endl;
    cout << "d = " << d << "   e = " << e << endl;
    cout << "c = " << c << "   s = " << s << endl;

    return 0;
}
```

📌 **Salida:**  
```
a = 20   b = 10
d = 20   e = 10
c = b   s = a
```

<details><summary>👨‍🏫 Explicación</summary>

- `template <class T>` permite definir una función genérica que puede intercambiar valores de cualquier tipo de dato.  
- La función `mySwap(T &x, T &y)` intercambia dos variables sin necesidad de sobrecargar la función para cada tipo específico.  
- Se prueba con **`int`**, **`double`** y **`char`**, demostrando su flexibilidad y reutilización.  
- La salida muestra que los valores han sido correctamente intercambiados, manteniendo la estructura del código limpia y eficiente.  

</details>

---

# 9. **Inline Expansion**  

Algunas funciones son tan pequeñas que la sobrecarga de invocarlas puede ser mayor que su ejecución. **C++** permite definir funciones **inline** para que el compilador reemplace la llamada a la función con el código en sí.  


> [!WARNING]  
> Un uso excesivo de la **expansión en línea** (*inline expansion*) puede aumentar el tamaño del código binario (*code bloat*), reduciendo la eficiencia y afectando la optimización del compilador.  

---

### 🚀 **Ejemplo 1: Función inline**  <!-- omit in toc -->

```cpp
inline int max(int x, int y) {
    return (x > y ? x : y);
}
```

<details><summary>👨‍🏫 Explicación</summary>

- `inline` sugiere al compilador que expanda la función en lugar de llamarla.  
- Se usa para funciones cortas que se ejecutan con frecuencia.  

</details>

---

### 🚀 **Ejemplo 2: Template inline**  <!-- omit in toc -->

```cpp
template<class T> inline
T square(T x) {
    return x * x;
}
```

<details><summary>👨‍🏫 Explicación</summary>

- `inline` mejora el rendimiento eliminando la sobrecarga de la llamada.  
- `template<class T>` permite usar cualquier tipo de dato para `square()`.  

</details>

---

# 10. **Overloading**  

La **sobrecarga de funciones** en **C++** permite definir múltiples versiones de una misma función con diferentes tipos o cantidades de parámetros.  
El compilador elige automáticamente la versión correcta en función de los argumentos proporcionados.  

Esta técnica mejora la **reutilización de código** y **la legibilidad**, evitando la necesidad de nombres de función distintos para cada tipo de dato.  

El compilador selecciona la versión correcta en función del número y tipo de argumentos.  

---

### 🚀 **Ejemplo:**  <!-- omit in toc -->

```cpp
#include <iostream>

using namespace std;

// Notificación básica
void sendNotification(const string& message) {
    cout << "[NOTIFICACIÓN] " << message << endl;
}

// Notificación con nivel de prioridad
void sendNotification(const string& message, int priority) {
    cout << "[PRIORIDAD " << priority << "] " << message << endl;
}

// Notificación con destinatario y prioridad
void sendNotification(const string& message, const string& recipient, int priority) {
    cout << "[Para: " << recipient << "] [PRIORIDAD " << priority << "] " << message << endl;
}

int main() {
    sendNotification("El sistema se ha actualizado.");                       // Notificación básica
    sendNotification("Carga de CPU alta", 2);                                // Notificación con prioridad
    sendNotification("Actualización de seguridad disponible", "Admin", 1);   // Notificación con destinatario y prioridad

    return 0;
}
```

📌 **Salida:**  
```
[NOTIFICACIÓN] El sistema se ha actualizado.
[PRIORIDAD 2] Carga de CPU alta
[Para: Admin] [PRIORIDAD 1] Actualización de seguridad disponible
```

<details><summary>👨‍🏫 Explicación</summary>

1. **Definición de `sendNotification()`**:  
   - La versión simple muestra un mensaje: `void sendNotification(const string& message)`.  
   - La versión con prioridad agrega un parámetro `priority`: `void sendNotification(const string& message, int priority)`.  
   - La versión con destinatario y prioridad: `void sendNotification(const string& message, const string& recipient, int priority)`.

2. **Uso en `main()`**:  
   - Se llaman las diferentes versiones de `sendNotification()` según los parámetros.

3. **Selección automática**:  
   - El compilador elige la versión adecuada según los argumentos.

4. **Beneficio**:  
   - El código es más claro y reutilizable sin necesidad de nombres de función adicionales.
</details>

> [!NOTE]
>
> Es importante resaltar que existen otros tipos de sobrecarga que veremos más adelante, como:
>
>- **Sobrecarga de operadores**: Permite redefinir el comportamiento de los operadores (como `+`, `-`, etc.) para tipos definidos por el usuario.
>- **Sobrecarga de constructores**: Permite definir múltiples constructores para una clase, con diferentes parámetros, para crear objetos de diversas formas.
>

---

# 11. **Manejo de Excepciones**  

El **manejo de excepciones** en **C++** permite capturar errores en tiempo de ejecución sin detener bruscamente el programa.  

> [!NOTE]  
>  
> `try` encapsula el código propenso a errores, mientras que `catch` maneja las excepciones cuando ocurren.  
>  

---

### 🚀 **Ejemplo 1: Manejo de División por Cero**  

```cpp
#include <iostream>

using namespace std;

double dividir(double a, double b) {
    if (b == 0) throw runtime_error("Error: División por cero");
    return a / b;
}

int main() {
    try {
        double resultado = dividir(10, 0);  // Error: División por cero
        cout << "Resultado: " << resultado << endl;
    } 
    catch (const runtime_error& e) { 
        cout << "Excepción capturada: " << e.what() << endl;
    }

    return 0;
}
```

📌 **Salida:**  
```
Excepción capturada: Error: División por cero
```

<details><summary>👨‍🏫 Explicación</summary>

- `throw runtime_error("Error: División por cero")` lanza una excepción cuando `b == 0`.  
- `try` intenta ejecutar `dividir(10, 0)`, pero esto genera una excepción.  
- `catch (const runtime_error& e)` captura la excepción específica y muestra el mensaje.  
- `e.what()` devuelve el mensaje del error.  

</details>

---

### 🚀 **Ejemplo 2: Validación de Rango en Entrada de Usuario** 

```cpp
#include <iostream>
#include <stdexcept> // Necesario para usar out_of_range

using namespace std;

void validarNumero(int num) {
    if (num < 1 || num > 10) {
        throw out_of_range("Número fuera de rango permitido (1-10)");
    }
}

int main() {
    int numero;

    try {
        cout << "Ingrese un número entre 1 y 10: ";
        cin >> numero;
        
        validarNumero(numero); // Lanza excepción si está fuera de rango
        
        cout << "Número válido ingresado: " << numero << endl;
    } 
    catch (const out_of_range& e) { 
        cout << "Excepción capturada: " << e.what() << endl;
    }

    return 0;
}
```

📌 **Salidas:**

✅ Entrada válida:  
```
Ingrese un número entre 1 y 10: 5
Número válido ingresado: 5
```

❌ Entrada fuera de rango:  
```
Ingrese un número entre 1 y 10: 20
Excepción capturada: Número fuera de rango permitido (1-10)
```

---

<details><summary>👨‍🏫 Explicación</summary>

- `validarNumero(int num)` verifica si el número está **entre 1 y 10**.  
- Si el número está **fuera del rango**, se lanza una excepción con `throw out_of_range("Número fuera de rango permitido (1-10)")`.  
- En `main()`, se solicita un número al usuario y se llama a `validarNumero(numero)`.  
- Si el número está fuera del rango, **`catch (const out_of_range& e)` captura la excepción** y muestra el mensaje de error.  
- `e.what()` devuelve el mensaje de la excepción lanzada, que en este caso es `"Número fuera de rango permitido (1-10)"`.  

</details>  

### 🚀 **Ejemplo 3: Manejo de Múltiples Excepciones**  

Aquí tienes un **ejemplo que combina varias excepciones** en una sola ejecución:  

```cpp
#include <iostream>
#include <stdexcept>

using namespace std;

int dividir(int a, int b) {
    if (b == 0) throw runtime_error("Error: División por cero");
    return a / b;
}

int main() {
    try {
        int num;
        cout << "Ingrese un número entre 1 y 10: ";
        cin >> num;

        if (num < 1 || num > 10) throw out_of_range("Número fuera de rango");

        int resultado = dividir(10, num);
        cout << "Resultado de la división: " << resultado << endl;
    }
    catch (const out_of_range& e) {
        cout << "Excepción capturada (rango): " << e.what() << endl;
    }
    catch (const runtime_error& e) {
        cout << "Excepción capturada (división): " << e.what() << endl;
    }

    return 0;
}
```

📌 **Salidas:**  

✅ Entrada válida:  
```
Ingrese un número entre 1 y 10: 5
Resultado de la división: 2
```

❌ Entrada fuera de rango:  
```
Ingrese un número entre 1 y 10: 20
Excepción capturada (rango): Número fuera de rango
```

❌ División por cero:  
```
Ingrese un número entre 1 y 10: 0
Excepción capturada (división): Error: División por cero
```

<details><summary>👨‍🏫 Explicación</summary>

- `throw out_of_range("Número fuera de rango")` se usa si el número ingresado **no está entre 1 y 10**.  
- `throw runtime_error("Error: División por cero")` se lanza si el usuario ingresa `0` como divisor.  
- Se usan **dos bloques `catch`**: uno para `out_of_range` y otro para `runtime_error`.  
- El programa **maneja ambas excepciones sin cerrarse abruptamente**.  

</details>


## **Excepciones Adicionales en &lt;stdexcept&gt;**  

Además de `out_of_range`, **C++ ofrece varias excepciones estándar** para manejar distintos tipos de errores:  

| Excepción              | Descripción  |  
|------------------------|-------------|  
| **`std::out_of_range`**   | Se lanza cuando se intenta acceder a un índice fuera del rango permitido (ejemplo: `std::vector::at()`). |  
| **`std::invalid_argument`** | Se lanza cuando se pasa un argumento inválido a una función (ejemplo: `std::stoi("abc")`). |  
| **`std::runtime_error`**  | Se usa para errores en **tiempo de ejecución**, como divisiones por cero personalizadas. |  
| **`std::logic_error`**  | Se usa para errores en la **lógica del código**, como condiciones incorrectas. |  
| **`std::domain_error`**  | Se lanza cuando se usa un **valor fuera del dominio válido** de una función matemática (ejemplo: `sqrt(-1)`). |  
| **`std::length_error`**  | Se lanza si se intenta **crear una estructura de datos con un tamaño superior al permitido**. |  
| **`std::bad_alloc`**  | Se lanza cuando `new` **no puede asignar memoria** (cuando no hay suficiente memoria RAM disponible). |  


---

# 12. **Estructuras**

Una **estructura** es una colección de una o más variables agrupadas bajo un mismo nombre. Permiten almacenar datos relacionados en una sola entidad, facilitando la organización del código.

### 🚀 **Ejemplo 1: Definiendo un Nuevo Tipo de Dato - Punto**

```cpp
#include <iostream>
using namespace std;

struct Punto {
    int x;
    int y;
};

int main() {
    Punto p1 = {-1, 4}, p2 = {1, 5}, p3;

    p3.x = 3;
    p3.y = 6;

    cout << "Punto 1 = (" << p1.x << ", " << p1.y << ")\n";  // Punto 1 = (-1, 4)
    cout << "Punto 2 = (" << p2.x << ", " << p2.y << ")\n";  // Punto 2 = (1, 5)
    cout << "Punto 3 = (" << p3.x << ", " << p3.y << ")\n";  // Punto 3 = (3, 6)

    return 0;
}
```

📌 **Salida:**
```
Punto 1 = (-1, 4)
Punto 2 = (1, 5)
Punto 3 = (3, 6)
```

<details><summary>👨‍🏫 Explicación</summary>

- Se define una estructura `punto` con dos variables `x` e `y`.  
- Se declaran tres variables de tipo `punto`: `p1`, `p2` y `p3`.  
- `p1` y `p2` se inicializan directamente, mientras que `p3` se asigna manualmente.  
- Se imprimen los valores almacenados en las estructuras.  

</details>

### 🚀 **Ejemplo 2: Definiendo un Nuevo Tipo de Dato - Gato**

```cpp
#include <iostream>
using namespace std;

struct Gato {
    int edad;
    int altura;
    string nombre;
    string padre;
    string madre;
};

int main() {
    Gato miGato;

    cout << "Ingrese el nombre del gato: ";
    cin >> miGato.nombre;

    cout << "¿Cuántos años tiene " << miGato.nombre << "? ";
    cin >> miGato.edad;

    cout << "¿Cuánto mide " << miGato.nombre << " (en manos)? ";
    cin >> miGato.altura;

    cout << "¿Quién es el padre de " << miGato.nombre << "? ";
    cin >> miGato.padre;

    cout << "¿Quién es la madre de " << miGato.nombre << "? ";
    cin >> miGato.madre;

    cout << "\n" << miGato.nombre << " tiene " << miGato.edad << " años, mide " << miGato.altura << " manos";
    cout << " y sus padres son " << miGato.padre << " y " << miGato.madre << ".\n";

    return 0;
}
```

📌 **Salida esperada:**
```
Ingrese el nombre del gato: Whiskers
¿Cuántos años tiene Whiskers? 3
¿Cuánto mide Whiskers (en manos)? 5
¿Quién es el padre de Whiskers? Tom
¿Quién es la madre de Whiskers? Luna

Whiskers tiene 3 años, mide 5 manos y sus padres son Tom y Luna.
```

<details><summary>👨‍🏫 Explicación</summary>

- Se define la estructura `Gato`, que almacena información sobre un gato.  
- Se solicita la entrada del usuario para asignar valores a `nombre`, `edad`, `altura`, `padre` y `madre`.  
- Los datos ingresados se imprimen en pantalla al final del programa.  

</details>

📌 **Salida:**
```
Ingrese el nombre del gato: Whiskers
¿Cuántos años tiene Whiskers? 3
¿Cuánto mide Whiskers (en manos)? 5
¿Quién es el padre de Whiskers? Tom
¿Quién es la madre de Whiskers? Luna

Whiskers tiene 3 años, mide 5 manos y sus padres son Tom y Luna.
```

<details><summary>👨‍🏫 Explicación</summary>

- Se define la estructura `Gato`, que almacena información sobre un gato.  
- Se solicita la entrada del usuario para asignar valores a `nombre`, `edad`, `altura`, `padre` y `madre`.  
- Los datos ingresados se imprimen en pantalla al final del programa.  

</details>

