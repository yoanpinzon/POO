
---

# ğŸ’» 300CIS017 ProgramaciÃ³n Orientada a Objetos 2025-02  <!-- omit in toc -->
![Version](https://img.shields.io/badge/version-1.4-blue)
[![License: CC BY-NC-ND 4.0](https://img.shields.io/badge/License-CC%20BY--NC--ND%204.0-lightgrey.svg?color=#007ec6)](https://creativecommons.org/licenses/by-nc-nd/4.0/)

---

# ğŸŒŸ Tema 2: El lenguaje C++ - Parte 2<!-- omit in toc -->

---

### ğŸ¥ Videos que inspiraron este tema:

<table style="border-collapse: collapse; width: 100%; border: none; margin: 10px 0;">
  <tr>
    <td style="text-align: center; padding: 5px; border: none;">
      <a href="https://www.youtube.com/watch?v=Hh9yZWeTmVM">
        <img src="img/vid4.png" alt="The Beginning - OOR" width="150">
      </a>
      <br>
      <span style="font-size: 12px; margin-top: 5px; display: inline-block;">The Beginning<br>OOR</span>
    </td>
    <td style="text-align: center; padding: 5px; border: none;">
      <a href="https://www.youtube.com/watch?v=Ibp_y21LHJY">
        <img src="img/vid5.png" alt="Push Back - OOR" width="150">
      </a>
      <br>
      <span style="font-size: 12px; margin-top: 5px; display: inline-block;">Push Back<br>OOR</span>
    </td>
  </tr>
</table>

---

### ğŸ’» Creado por   

Profesorcito Â© 2025

---

### ğŸ¶ Dedicado a 

[Takahiro Moriuchi](https://es.wikipedia.org/wiki/Takahiro_Moriuchi) (Taka) ğŸ¤

---

En este capÃ­tulo, aprenderemos sobre **bucles (`for`, `while`, `do-while`)**, **arreglos**, **punteros**, **referencias**, **funciones** y **asignaciÃ³n dinÃ¡mica de memoria**, conceptos clave para escribir cÃ³digo eficiente y estructurado. ğŸš€

---

### **Tabla de Contenido**

- [1. **Estructuras de RepeticiÃ³n**](#1-estructuras-de-repeticiÃ³n)
  - [**El bucle `for`**](#el-bucle-for)
    - [ğŸš€ **Ejemplo 1: Imprimir nÃºmeros del 1 al 5**](#-ejemplo-1-imprimir-nÃºmeros-del-1-al-5)
    - [ğŸš€ **Ejemplo 2: Contador en decremento**](#-ejemplo-2-contador-en-decremento)
    - [ğŸš€ **Ejemplo 3: Recorrer un array**](#-ejemplo-3-recorrer-un-array)
    - [ğŸš€ **Ejemplo 4: Tabla de multiplicar**](#-ejemplo-4-tabla-de-multiplicar)
    - [ğŸš€ **Ejemplo 5: Bucle infinito con `for`**](#-ejemplo-5-bucle-infinito-con-for)
    - [ğŸš€ **Ejemplo 6: Imprimir un triÃ¡ngulo de asteriscos con `for` anidados**](#-ejemplo-6-imprimir-un-triÃ¡ngulo-de-asteriscos-con-for-anidados)
  - [**El bucle `while`**](#el-bucle-while)
    - [ğŸš€ **Ejemplo 1: Contador del 1 al 5**](#-ejemplo-1-contador-del-1-al-5)
    - [ğŸš€ **Ejemplo 2: Cuenta regresiva**](#-ejemplo-2-cuenta-regresiva)
    - [ğŸš€ **Ejemplo 3: Leer hasta que el usuario ingrese un nÃºmero positivo**](#-ejemplo-3-leer-hasta-que-el-usuario-ingrese-un-nÃºmero-positivo)
    - [ğŸš€ **Ejemplo 4: Sumar valores ingresados por el usuario**](#-ejemplo-4-sumar-valores-ingresados-por-el-usuario)
    - [ğŸš€ **Ejemplo 5: Bucle infinito con `while`**](#-ejemplo-5-bucle-infinito-con-while)
  - [**El bucle `do-while`**](#el-bucle-do-while)
    - [ğŸš€ **Ejemplo 1: Validar entrada de usuario (BÃ¡sico y Ãºtil)**](#-ejemplo-1-validar-entrada-de-usuario-bÃ¡sico-y-Ãºtil)
    - [ğŸš€ **Ejemplo 2: Simulador de menÃº interactivo**](#-ejemplo-2-simulador-de-menÃº-interactivo)
  - [ğŸ§© **Problemas de Bucles Propuestos en C++**](#-problemas-de-bucles-propuestos-en-c)
  - [**Instrucciones `break` y `continue`**](#instrucciones-break-y-continue)
    - [ğŸš€ **Ejemplo 1: Uso de `break` (Sumar solo valores positivos)**](#-ejemplo-1-uso-de-break-sumar-solo-valores-positivos)
    - [ğŸš€ **Ejemplo 2: Uso de `continue` (Imprimir valores del 1 al 10, omitiendo el 5)**](#-ejemplo-2-uso-de-continue-imprimir-valores-del-1-al-10-omitiendo-el-5)
- [2. **Arreglos**](#2-arreglos)
  - [**DeclaraciÃ³n de un arreglo**](#declaraciÃ³n-de-un-arreglo)
  - [**InicializaciÃ³n de arreglos**](#inicializaciÃ³n-de-arreglos)
    - [ğŸš€ **Ejemplo 1: Suma de dos matrices en C++**](#-ejemplo-1-suma-de-dos-matrices-en-c)
  - [ğŸ§© **Problemas de Arreglos Propuestos en C++**](#-problemas-de-arreglos-propuestos-en-c)
- [3. **Uso de `auto` para Inferencia de Tipos**](#3-uso-de-auto-para-inferencia-de-tipos)
- [4. **Punteros**](#4-punteros)
    - [**Ejemplo bÃ¡sico**](#ejemplo-bÃ¡sico)
  - [**AritmÃ©tica de punteros**](#aritmÃ©tica-de-punteros)
    - [**Operaciones bÃ¡sicas de aritmÃ©tica de punteros**](#operaciones-bÃ¡sicas-de-aritmÃ©tica-de-punteros)
    - [**Otras operaciones con punteros**](#otras-operaciones-con-punteros)
  - [ğŸ§© **Problemas de Punteros Propuestos en C++**](#-problemas-de-punteros-propuestos-en-c)
- [5. **Referencias**](#5-referencias)
    - [ğŸš€ **Ejemplo 1: Referencia a una variable**](#-ejemplo-1-referencia-a-una-variable)
    - [ğŸš€ **Ejemplo 2: Uso de `const &`**](#-ejemplo-2-uso-de-const-)
  - [**ComparaciÃ³n entre referencias y punteros**](#comparaciÃ³n-entre-referencias-y-punteros)
- [6. **Funciones**](#6-funciones)
  - [**MÃ©todos de paso de argumentos**](#mÃ©todos-de-paso-de-argumentos)
    - [**Paso por valor**](#paso-por-valor)
    - [**Paso por referencia con punteros**](#paso-por-referencia-con-punteros)
    - [**Paso por referencia con referencias**](#paso-por-referencia-con-referencias)
  - [ğŸ§© **Problemas de Funciones Propuestos en C++**](#-problemas-de-funciones-propuestos-en-c)
- [7. **AsignaciÃ³n dinÃ¡mica de memoria en C++**](#7-asignaciÃ³n-dinÃ¡mica-de-memoria-en-c)
  - [**AsignaciÃ³n de memoria dinÃ¡mica**](#asignaciÃ³n-de-memoria-dinÃ¡mica)
  - [**LiberaciÃ³n de memoria dinÃ¡mica**](#liberaciÃ³n-de-memoria-dinÃ¡mica)
  - [**AplicaciÃ³n prÃ¡ctica: Memoria estÃ¡tica vs dinÃ¡mica en C++**](#aplicaciÃ³n-prÃ¡ctica-memoria-estÃ¡tica-vs-dinÃ¡mica-en-c)
    - [**VersiÃ³n dinÃ¡mica**](#versiÃ³n-dinÃ¡mica)
    - [**VersiÃ³n estÃ¡tica**](#versiÃ³n-estÃ¡tica)
- [8. **Templates**](#8-templates)
    - [ğŸš€ **Ejemplo 1: FunciÃ³n genÃ©rica para encontrar el mÃ¡ximo**](#-ejemplo-1-funciÃ³n-genÃ©rica-para-encontrar-el-mÃ¡ximo)
    - [ğŸš€ **Ejemplo 2: FunciÃ³n genÃ©rica para intercambiar valores**](#-ejemplo-2-funciÃ³n-genÃ©rica-para-intercambiar-valores)
- [9. **Inline Expansion**](#9-inline-expansion)
- [10. **Overloading**](#10-overloading)
- [11. **Manejo de Excepciones**](#11-manejo-de-excepciones)
    - [ğŸš€ **Ejemplo 1: Manejo de DivisiÃ³n por Cero**](#-ejemplo-1-manejo-de-divisiÃ³n-por-cero)
    - [ğŸš€ **Ejemplo 2: ValidaciÃ³n de Rango en Entrada de Usuario**](#-ejemplo-2-validaciÃ³n-de-rango-en-entrada-de-usuario)
    - [ğŸš€ **Ejemplo 3: Manejo de MÃºltiples Excepciones**](#-ejemplo-3-manejo-de-mÃºltiples-excepciones)
  - [**Excepciones Adicionales en \<stdexcept\>**](#excepciones-adicionales-en-stdexcept)
- [12. **Estructuras**](#12-estructuras)
    - [ğŸš€ **Ejemplo 1: Definiendo un Nuevo Tipo de Dato - Punto**](#-ejemplo-1-definiendo-un-nuevo-tipo-de-dato---punto)
    - [ğŸš€ **Ejemplo 2: Definiendo un Nuevo Tipo de Dato - Gato**](#-ejemplo-2-definiendo-un-nuevo-tipo-de-dato---gato)

---

# 1. **Estructuras de RepeticiÃ³n**  

En programaciÃ³n, los **bucles** ğŸ”„ permiten repetir instrucciones sin escribirlas mÃºltiples veces. En C++, existen **tres tipos de bucles** fundamentales:  

## **El bucle `for`**  

Se usa cuando **se conoce de antemano** cuÃ¡ntas veces debe repetirse la ejecuciÃ³n del bloque de cÃ³digo.  

### Sintaxis: <!-- omit in toc -->  

```cpp
for (inicializaciÃ³n; condiciÃ³n; actualizaciÃ³n) {
    // Bloque de cÃ³digo que se ejecuta en cada iteraciÃ³n
}
```  

ğŸ“Œ **ExplicaciÃ³n de cada parte:**  
1. **InicializaciÃ³n**: Se ejecuta una sola vez al inicio del bucle. Se usa para definir y asignar un valor inicial a una variable de control.  
2. **CondiciÃ³n**: Se evalÃºa antes de cada iteraciÃ³n. Si es `true`, el bloque de cÃ³digo se ejecuta; si es `false`, el bucle termina.  
3. **ActualizaciÃ³n**: Se ejecuta al final de cada iteraciÃ³n y suele modificar la variable de control.  

---

### ğŸš€ **Ejemplo 1: Imprimir nÃºmeros del 1 al 5**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 1; i <= 5; i++) {  // i inicia en 1, se detiene cuando i > 5, y se incrementa en 1
        cout << "Valor: " << i << endl;
    }
    return 0;
}
```  

ğŸ“Œ **Salida:**  
```
Valor: 1
Valor: 2
Valor: 3
Valor: 4
Valor: 5
```  

---

### ğŸš€ **Ejemplo 2: Contador en decremento**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 10; i >= 1; i--) {  // i inicia en 10 y va decreciendo hasta 1
        cout << "Cuenta regresiva: " << i << endl;
    }
    return 0;
}
```  

ğŸ“Œ **Salida:**  
```
Cuenta regresiva: 10
Cuenta regresiva: 9
Cuenta regresiva: 8
Cuenta regresiva: 7
Cuenta regresiva: 6
Cuenta regresiva: 5
Cuenta regresiva: 4
Cuenta regresiva: 3
Cuenta regresiva: 2
Cuenta regresiva: 1
```  

---

### ğŸš€ **Ejemplo 3: Recorrer un array**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numeros[] = {3, 7, 1, 9, 5};
    int tamaÃ±o = sizeof(numeros) / sizeof(numeros[0]); // Calcula el tamaÃ±o del array

    for (int i = 0; i < tamaÃ±o; i++) {  // Recorre el array usando su tamaÃ±o
        cout << "Elemento " << i << ": " << numeros[i] << endl;
    }
    return 0;
}
```  

ğŸ“Œ **Salida:**  
```
Elemento 0: 3
Elemento 1: 7
Elemento 2: 1
Elemento 3: 9
Elemento 4: 5
```  

---

### ğŸš€ **Ejemplo 4: Tabla de multiplicar**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Introduce un nÃºmero: ";
    cin >> n;

    for (int i = 1; i <= 10; i++) {
        cout << n << " x " << i << " = " << (n * i) << endl;
    }

    return 0;
}
```  

ğŸ“Œ **Salida si el usuario ingresa `7`:**  
```
7 x 1 = 7
7 x 2 = 14
7 x 3 = 21
7 x 4 = 28
7 x 5 = 35
7 x 6 = 42
7 x 7 = 49
7 x 8 = 56
7 x 9 = 63
7 x 10 = 70
```  

---

### ğŸš€ **Ejemplo 5: Bucle infinito con `for`**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (;;) {  // No hay inicializaciÃ³n, condiciÃ³n ni actualizaciÃ³n
        cout << "Esto es un bucle infinito!" << endl;
    }
    return 0;
}
```  

ğŸ“Œ **Esto imprimirÃ¡ el mensaje infinitamente hasta que detengas el programa manualmente (`Ctrl + C` en consola).**  

---

### ğŸš€ **Ejemplo 6: Imprimir un triÃ¡ngulo de asteriscos con `for` anidados**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int filas;

    cout << "Introduce el nÃºmero de filas: ";
    cin >> filas;

    for (int i = 1; i <= filas; i++) {  // Controla las filas
        for (int j = 1; j <= i; j++) {  // Controla la cantidad de asteriscos por fila
            cout << "* ";
        }
        cout << endl;  // Salto de lÃ­nea para la siguiente fila
    }

    return 0;
}
```  

ğŸ“Œ **Salida si el usuario ingresa `5`:**  
```
* 
* * 
* * * 
* * * * 
* * * * * 
```  

---

## **El bucle `while`**  

Se usa cuando **no se conoce de antemano** cuÃ¡ntas veces debe repetirse la ejecuciÃ³n del bloque de cÃ³digo. El bucle continuarÃ¡ ejecutÃ¡ndose **mientras una condiciÃ³n sea verdadera**.

### Sintaxis: <!-- omit in toc -->

```cpp
while (condiciÃ³n) {
    // Bloque de cÃ³digo que se ejecuta en cada iteraciÃ³n
}
```

ğŸ“Œ **ExplicaciÃ³n de cada parte:**  
1. **CondiciÃ³n**: Se evalÃºa antes de cada iteraciÃ³n. Si es `true`, el bloque de cÃ³digo se ejecuta; si es `false`, el bucle termina.  
2. **Bloque de cÃ³digo**: Se ejecuta una y otra vez mientras la condiciÃ³n siga siendo verdadera.  
3. **Cambio de estado**: Es necesario modificar alguna variable dentro del bucle para que eventualmente la condiciÃ³n sea `false`, evitando un bucle infinito.  

---

### ğŸš€ **Ejemplo 1: Contador del 1 al 5**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int contador = 1;  // Se inicia el contador en 1

    while (contador <= 5) {  // Se ejecuta mientras contador sea menor o igual a 5
        cout << "Valor: " << contador << endl;
        contador++;  // Se incrementa el contador en 1
    }

    return 0;
}
```

ğŸ“Œ **Salida:**
```
Valor: 1
Valor: 2
Valor: 3
Valor: 4
Valor: 5
```

---

### ğŸš€ **Ejemplo 2: Cuenta regresiva**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int contador = 10;

    while (contador >= 1) {  // Se ejecuta mientras contador sea mayor o igual a 1
        cout << "Cuenta regresiva: " << contador << endl;
        contador--;  // Se decrementa en 1
    }

    return 0;
}
```

ğŸ“Œ **Salida:**
```
Cuenta regresiva: 10
Cuenta regresiva: 9
...
Cuenta regresiva: 1
```

---

### ğŸš€ **Ejemplo 3: Leer hasta que el usuario ingrese un nÃºmero positivo**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numero;

    cout << "Ingresa un nÃºmero positivo: ";
    cin >> numero;

    while (numero <= 0) {  // Se repite mientras el nÃºmero sea negativo o cero
        cout << "El nÃºmero no es positivo. Intenta de nuevo: ";
        cin >> numero;
    }

    cout << "NÃºmero vÃ¡lido ingresado: " << numero << endl;
    return 0;
}
```

ğŸ“Œ **Ejemplo de entrada y salida:**  
```
Ingresa un nÃºmero positivo: -3
El nÃºmero no es positivo. Intenta de nuevo: 0
El nÃºmero no es positivo. Intenta de nuevo: 7
NÃºmero vÃ¡lido ingresado: 7
```

---

### ğŸš€ **Ejemplo 4: Sumar valores ingresados por el usuario**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int suma = 0, num;

    cout << "Ingresa nÃºmeros para sumar (0 para terminar): ";

    while (true) {  // Se repite hasta que el usuario ingrese 0
        cin >> num;
        if (num == 0) {
            break;  // Sale del bucle cuando el usuario ingresa 0
        }
        suma += num;
    }

    cout << "Suma total: " << suma << endl;
    return 0;
}
```

ğŸ“Œ **Ejemplo de entrada y salida:**  
```
Ingresa nÃºmeros para sumar (0 para terminar): 5
10
-2
3
0
Suma total: 16
```

---

### ğŸš€ **Ejemplo 5: Bucle infinito con `while`**  

```cpp
#include <iostream>
using namespace std;

int main() {
    while (true) {  // No hay condiciÃ³n de salida
        cout << "Esto es un bucle infinito!" << endl;
    }
    return 0;
}
```

ğŸ“Œ **Esto imprimirÃ¡ el mensaje infinitamente hasta que detengas el programa manualmente (`Ctrl + C` en consola).**  

---

## **El bucle `do-while`**  

Es similar al `while`, pero **siempre ejecuta al menos una vez** el bloque de cÃ³digo antes de evaluar la condiciÃ³n.

### Sintaxis: <!-- omit in toc -->

```cpp
do {
   // CÃ³digo a ejecutar en cada iteraciÃ³n
} while (condiciÃ³n);
```

ğŸ“Œ **ExplicaciÃ³n de cada parte:**  
1. **Bloque de cÃ³digo**: Se ejecuta **una vez antes de evaluar** la condiciÃ³n.  
2. **CondiciÃ³n**: Se evalÃºa despuÃ©s de la primera ejecuciÃ³n. Si es `true`, el bucle continÃºa; si es `false`, el bucle termina.  

---

### ğŸš€ **Ejemplo 1: Validar entrada de usuario (BÃ¡sico y Ãºtil)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numero;

    do {
        cout << "Ingresa un nÃºmero positivo: ";
        cin >> numero;

        if (numero <= 0) {
            cout << "Error: el nÃºmero debe ser positivo." << endl;
        }

    } while (numero <= 0);  // Repite mientras el nÃºmero no sea positivo

    cout << "NÃºmero vÃ¡lido ingresado: " << numero << endl;
    return 0;
}
```

ğŸ“Œ **Ejemplo de entrada y salida:**  
```
Ingresa un nÃºmero positivo: -4
Error: el nÃºmero debe ser positivo.
Ingresa un nÃºmero positivo: 0
Error: el nÃºmero debe ser positivo.
Ingresa un nÃºmero positivo: 7
NÃºmero vÃ¡lido ingresado: 7
```

> [!TIP]  
> Te estarÃ¡s preguntando cuÃ¡ndo se usa `do-while` o por quÃ© existe en primer lugar. La razÃ³n es que garantiza que el usuario vea el mensaje al menos una vez, sin importar la condiciÃ³n. AdemÃ¡s, si el usuario ingresa un valor correcto desde el inicio, el bucle solo se ejecuta una vez, evitando iteraciones innecesarias.

---

### ğŸš€ **Ejemplo 2: Simulador de menÃº interactivo**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int opcion;

    do {
        // Mostrar opciones
        cout << "\nMENÃš DE OPCIONES" << endl;
        cout << "1. Saludar" << endl;
        cout << "2. Mostrar fecha" << endl;
        cout << "3. Salir" << endl;
        cout << "Selecciona una opciÃ³n: ";
        cin >> opcion;

        // Ejecutar la opciÃ³n seleccionada
        switch (opcion) {
            case 1:
                cout << "Â¡Hola! Espero que estÃ©s teniendo un gran dÃ­a." << endl;
                break;
            case 2:
                cout << "Hoy es un gran dÃ­a para programar en C++." << endl;
                break;
            case 3:
                cout << "Saliendo del programa..." << endl;
                break;
            default:
                cout << "OpciÃ³n no vÃ¡lida, intenta de nuevo." << endl;
        }

    } while (opcion != 3);  // Repite mientras el usuario no seleccione "Salir"

    return 0;
}
```

ğŸ“Œ **Ejemplo de entrada y salida:**  
```
MENÃš DE OPCIONES
1. Saludar
2. Mostrar fecha
3. Salir
Selecciona una opciÃ³n: 1
Â¡Hola! Espero que estÃ©s teniendo un gran dÃ­a.

MENÃš DE OPCIONES
1. Saludar
2. Mostrar fecha
3. Salir
Selecciona una opciÃ³n: 2
Hoy es un gran dÃ­a para programar en C++.

MENÃš DE OPCIONES
1. Saludar
2. Mostrar fecha
3. Salir
Selecciona una opciÃ³n: 3
Saliendo del programa...
```

---

## ğŸ§© **Problemas de Bucles Propuestos en C++**  

---

### ğŸ… **Problema bucle01: Suma** | ğŸ›¡ï¸ **Novato** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Suma todos los nÃºmeros del `1` hasta `n`.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa un nÃºmero: 5
La suma es: 15
```  

> [!TIP]
> Usa un `for` para recorrer y acumular la suma.  

---

### ğŸ… **Problema bucle02: DÃ­gitos** | âš”ï¸ **Guerrero** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Cuenta cuÃ¡ntos dÃ­gitos tiene un nÃºmero entero.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa un nÃºmero: 12345
Tiene 5 dÃ­gitos.
```  

> [!TIP]
> Divide entre `10` en un `while` hasta que sea `0`.  

---

### ğŸ… **Problema bucle03: Adivina el NÃºmero** | âš”ï¸ **Guerrero** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Genera un nÃºmero aleatorio del `1` al `100`. El usuario debe adivinarlo con pistas.  

ğŸ“Œ **Ejemplo:**  
```
Adivina el nÃºmero (1-100): 50
Es mayor. Intenta de nuevo: 75
Es menor. Intenta de nuevo: 63
Â¡Correcto!
```  

> [!TIP]
> Usa `rand()` y un `do-while` para repetir intentos.  

---

### ğŸ… **Problema bucle04: PirÃ¡mide de NÃºmeros** | ğŸ”¥ **Experto** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Imprime una pirÃ¡mide de nÃºmeros con `n` filas.  

ğŸ“Œ **Ejemplo si `n = 5`:**  
```
    1
   121
  12321
 1234321
123454321
```  

> [!TIP]
> Usa `for` anidados para manejar espacios y nÃºmeros.  

---

### ğŸ… **Problema bucle05: NÃºmeros Primos** | ğŸ‘‘ **Leyenda** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Verifica si un nÃºmero es **primo** o **compuesto**.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa un nÃºmero: 17
Es primo.
```  

> [!TIP]
> Usa un `for` para contar divisores.  

---

## **Instrucciones `break` y `continue`**  

En C++, las instrucciones `break` y `continue` permiten **controlar el flujo de ejecuciÃ³n de un bucle** de manera mÃ¡s flexible.  

- **`break`**: Finaliza el bucle inmediatamente, sin importar si la condiciÃ³n del bucle sigue siendo verdadera.  
- **`continue`**: Salta el resto del cÃ³digo en la iteraciÃ³n actual y pasa directamente a la siguiente iteraciÃ³n.  

---

### ğŸš€ **Ejemplo 1: Uso de `break` (Sumar solo valores positivos)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    double suma = 0.0, valor;
    cout << "Ingresa valores uno por uno. Se sumaran mientras sean positivos." << endl;

    for (;;) { // Bucle infinito controlado con break
        cout << "Valor: ";
        cin >> valor;
        if (valor <= 0) break; // Sale del bucle si el valor es negativo o cero
        suma += valor;
    }

    cout << "Suma de los valores positivos ingresados: " << suma << endl;
    return 0;
}
```  

ğŸ“Œ **Salida:**  
```
Ingresa valores uno por uno. Se sumaran mientras sean positivos.
Valor: 5
Valor: 3.5
Valor: 10
Valor: -1
Suma de los valores positivos ingresados: 18.5
```  

---

### ğŸš€ **Ejemplo 2: Uso de `continue` (Imprimir valores del 1 al 10, omitiendo el 5)**  

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 1; i <= 10; i++) {
        if (i == 5) continue; // Salta la impresiÃ³n del 5
        cout << "Valor: " << i << endl;
    }

    cout << "Se uso 'continue' para omitir la impresion del 5." << endl;
    return 0;
}
```  

ğŸ“Œ **Salida:**  
```
Valor: 1
Valor: 2
Valor: 3
Valor: 4
Valor: 6
Valor: 7
Valor: 8
Valor: 9
Valor: 10
Se uso 'continue' para omitir la impresion del 5.
```  

---

# 2. **Arreglos**  

Los **arreglos (arrays)** permiten **almacenar mÃºltiples valores** del mismo tipo en una sola estructura, proporcionando **acceso directo a cada elemento** mediante un Ã­ndice. Son Ãºtiles cuando se necesita manejar **grupos de datos homogÃ©neos**.  

---

## **DeclaraciÃ³n de un arreglo**  

### Sintaxis: <!-- omit in toc -->  

```cpp
tipo nombre_arreglo[tamaÃ±o];
```  

ğŸ“Œ **Ejemplo:** Declarar un **arreglo unidimensional de 5 elementos**.  

```cpp
#include <iostream>
using namespace std;

int main() {
    int i, a[5];

    // Leer 5 valores
    for (i = 0; i < 5; i++) {
        cout << "a[" << i + 1 << "]= ";
        cin >> a[i];
    }

    // Imprimir los valores en orden inverso
    cout << "Los nÃºmeros en orden inverso: ";
    for (i = 4; i >= 0; i--)
        cout << a[i] << " ";

    return 0;
}
```

ğŸ“Œ **Ejemplo de entrada y salida:**  
```
a[1]= 7  
a[2]= 2  
a[3]= 9  
a[4]= 4  
a[5]= 5  
Los nÃºmeros en orden inverso: 5 4 9 2 7  
```

---

## **InicializaciÃ³n de arreglos**  

### Sintaxis: <!-- omit in toc -->  

```cpp
tipo nombre_arreglo[fila][columna] = { {valores fila 1}, {valores fila 2}, ... };
```

ğŸ“Œ **Ejemplos:**  

```cpp
int a[2][3] = { {1,2,3}, {4,5,6} };  
int b[2][3] = { 1,2,3,4,5 };  // El Ãºltimo valor se llena con 0 automÃ¡ticamente  
int c[2][3] = { {1,2}, {4} }; // Los valores faltantes son 0  
```

ğŸ“Œ **Valores de los arreglos por fila:**  

- **Arreglo `a`**  
```
1 2 3  
4 5 6  
```

- **Arreglo `b`**  
```
1 2 3  
4 5 0  
```

- **Arreglo `c`**  
```
1 2 0  
4 0 0  
```

ğŸ“Œ **Ejemplo en cÃ³digo:**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int i, j;
    int a[2][3] = { {1,2,3}, {4,5,6} };
    int b[2][3] = { 1,2,3,4,5 };  
    int c[2][3] = { {1,2}, {4} };

    cout << "Arreglo a:" << endl;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            cout << a[i][j] << " ";
        cout << endl;
    }

    cout << "Arreglo b:" << endl;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            cout << b[i][j] << " ";
        cout << endl;
    }

    cout << "Arreglo c:" << endl;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            cout << c[i][j] << " ";
        cout << endl;
    }

    return 0;
}
```

ğŸ“Œ **Salida esperada:**  
```
Arreglo a:  
1 2 3  
4 5 6  

Arreglo b:  
1 2 3  
4 5 0  

Arreglo c:  
1 2 0  
4 0 0  
```

---

> [!IMPORTANT]
> Si necesitas una estructura mÃ¡s flexible, usa **`std::vector`** o **`std::array`** en lugar de arreglos tradicionales. Estas estructuras forman parte de la **STL (Standard Template Library)** y ofrecen mayor seguridad y funcionalidad. Para utilizarlas, es necesario incluir las librerÃ­as correspondientes: `#include <array>` para `std::array` y `#include <vector>` para `std::vector`.
>

---

### ğŸš€ **Ejemplo 1: Suma de dos matrices en C++** 

```cpp
#include <iostream>
using namespace std;

int main() {
    int filas, columnas;

    // Solicitar dimensiones de la matriz
    cout << "Ingresa el nÃºmero de filas: ";
    cin >> filas;
    cout << "Ingresa el nÃºmero de columnas: ";
    cin >> columnas;

    int matriz1[filas][columnas], matriz2[filas][columnas], resultado[filas][columnas];

    // Leer la primera matriz
    cout << "Ingresa los valores de la primera matriz:" << endl;
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            cout << "Matriz1[" << i << "][" << j << "]: ";
            cin >> matriz1[i][j];
        }
    }

    // Leer la segunda matriz
    cout << "Ingresa los valores de la segunda matriz:" << endl;
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            cout << "Matriz2[" << i << "][" << j << "]: ";
            cin >> matriz2[i][j];
        }
    }

    // Sumar ambas matrices
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            resultado[i][j] = matriz1[i][j] + matriz2[i][j];
        }
    }

    // Mostrar la matriz resultante
    cout << "Matriz resultante (suma de ambas matrices):" << endl;
    for (int i = 0; i < filas; i++) {
        for (int j = 0; j < columnas; j++) {
            cout << resultado[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
```

---

ğŸ“Œ **Salida:**  

```
Ingresa el nÃºmero de filas: 2  
Ingresa el nÃºmero de columnas: 2  

Ingresa los valores de la primera matriz:  
Matriz1[0][0]: 1  
Matriz1[0][1]: 2  
Matriz1[1][0]: 3  
Matriz1[1][1]: 4  

Ingresa los valores de la segunda matriz:  
Matriz2[0][0]: 5  
Matriz2[0][1]: 6  
Matriz2[1][0]: 7  
Matriz2[1][1]: 8  

Matriz resultante (suma de ambas matrices):  
6 8  
10 12  
```

---

## ğŸ§© **Problemas de Arreglos Propuestos en C++**  

---  

### ğŸ… **Problema arreglo01: Mayor y Menor** | ğŸ›¡ï¸ **Novato** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Lee `n` nÃºmeros y encuentra el **mayor** y el **menor** valor del arreglo.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de nÃºmeros: 5
NÃºmero 1: 8
NÃºmero 2: 3
NÃºmero 3: 15
NÃºmero 4: 7
NÃºmero 5: 10
Mayor: 15
Menor: 3
```  

> [!TIP]  
> Usa un `for` para recorrer el arreglo y comparar valores.  

---  

### ğŸ… **Problema arreglo02: Promedio de Calificaciones** | âš”ï¸ **Guerrero** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Dado un arreglo con `n` calificaciones, calcula el **promedio** y muestra cuÃ¡les estÃ¡n por encima y por debajo de la media.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de calificaciones: 4
CalificaciÃ³n 1: 80
CalificaciÃ³n 2: 90
CalificaciÃ³n 3: 75
CalificaciÃ³n 4: 85
Promedio: 82.5
Por encima del promedio: 90, 85
Por debajo del promedio: 80, 75
```  

> [!TIP]  
> Usa un `for` para sumar los valores y calcular el promedio. Luego, usa un segundo `for` para imprimir las calificaciones por encima del promedio y un tercer `for` para las calificaciones por debajo de la media.  

---  

### ğŸ… **Problema arreglo03: Matriz Transpuesta** | ğŸ”¥ **Experto** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Dada una matriz `n x m`, genera su **matriz transpuesta**, es decir, intercambia sus filas y columnas.  

ğŸ“Œ **Ejemplo:**  
```
Matriz original:
1  2  3  
4  5  6  

Matriz transpuesta:
1  4  
2  5  
3  6  
```  

> [!TIP]  
> Usa dos `for` anidados para intercambiar `matriz[i][j]` por `matriz[j][i]`.  

---  

### ğŸ… **Problema arreglo04: EliminaciÃ³n de Duplicados** | ğŸ‘‘ **Leyenda** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Dado un arreglo con `n` nÃºmeros, **elimina los duplicados** y muestra el resultado sin repetir elementos.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de nÃºmeros: 8
Ingresa los nÃºmeros:
2 5 3 2 8 5 3 10

Arreglo sin duplicados: 2 5 3 8 10
```  

> [!TIP]
> Tu puedes!
> 
---

# 3. **Uso de `auto` para Inferencia de Tipos**

La palabra clave **`auto`** en C++ permite que el compilador **deduzca automÃ¡ticamente** el tipo de una variable en funciÃ³n de su valor inicial. Esto hace que el cÃ³digo sea mÃ¡s limpio y fÃ¡cil de mantener, especialmente cuando se trabaja con tipos complejos o al iterar sobre contenedores como arreglos o cadenas.

ğŸ“Œ **Ejemplo:** 

```cpp
#include <iostream>

using namespace std;

int main() {
    int a[] = {1, 5, 7, 8, 12, 33};  // Arreglo de enteros
    string pedro = R"(Mi
nombre
es
pedro)";  // Cadena multilÃ­nea
    
    cout << pedro << endl;
    
    // Uso de 'auto' para iterar sobre los elementos del arreglo
    for (auto i : a) {
        cout << i << endl;  // 'i' es deducido como int
    }
    
    // Uso de 'auto' para iterar sobre los caracteres de la cadena
    for (auto i : pedro) {
        cout << (int)i << " " << i << endl;  // 'i' es deducido como char
    }
    
    return 0;
}
```

ğŸ“Œ **Salida:** 

```
Mi
nombre
es
pedro
1
5
7
8
12
33
77 M
105 i
10

110 n
111 o
109 m
98 b
114 r
101 e
10

101 e
115 s
10

112 p
101 e
100 d
114 r
111 o
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- Declara un arreglo `a[]` con enteros `{1, 5, 7, 8, 12, 33}`.  
- Declara una cadena multilÃ­nea `pedro` usando `R"(...)"`.  
- Imprime la cadena `pedro` tal como estÃ¡.  
- Itera sobre el arreglo `a[]` usando `auto`, lo que permite que el compilador infiera que `i` es un `int`, e imprime cada nÃºmero.  
- Itera sobre la cadena `pedro` usando `auto`, que en este caso infiere `i` como `char`, e imprime el valor ASCII y el carÃ¡cter de cada letra.  

</details>

---

# 4. **Punteros**

Variables que contienen una direcciÃ³n de memoria como su valor.

> [!IMPORTANT]  
> Los punteros en **C++** son una herramienta sumamente poderosa que permite **manipular directamente la memoria**. A diferencia de otros lenguajes de alto nivel, donde la gestiÃ³n de memoria es automÃ¡tica, en C++ **tienes control total** sobre la asignaciÃ³n y liberaciÃ³n de memoria. Sin embargo, como se menciona en la pelÃ­cula *Spider-Man* (2002): "[No lo olvides, un gran poder conlleva una gran responsabilidad](https://youtu.be/kfRIn8rlFgU?feature=shared&t=60)". 


Hay dos operadores importantes para los punteros:

- `&` (direcciÃ³n de): devuelve la direcciÃ³n del objeto dado como operando
- `*` (desreferenciar): devuelve el objeto que se encuentra en la direcciÃ³n dada por el operando

### **Ejemplo bÃ¡sico**

```cpp
#include <iostream>

using namespace std;

int main() {
    int i = 16;
    int *pi;
    pi = &i;
    cout << *pi << endl;
    return 0;
}
```

**Salida esperada:**
```
16
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

Este programa muestra cÃ³mo utilizar un puntero para acceder al valor de una variable en **C++**. A continuaciÃ³n, se explican los conceptos clave del cÃ³digo:

1. **DeclaraciÃ³n de la variable `i` y el puntero `pi`**:
   - `int i = 16;` declara una variable entera `i` con el valor `16`.
   - `int *pi;` declara un puntero `pi` que almacenarÃ¡ la direcciÃ³n de una variable de tipo `int`.

2. **AsignaciÃ³n de la direcciÃ³n de `i` al puntero `pi`**:
   - `pi = &i;` asigna a `pi` la direcciÃ³n de memoria de `i` utilizando el operador `&` (operador de direcciÃ³n). Ahora, `pi` apunta a la ubicaciÃ³n en memoria donde se encuentra `i`.

3. **DesreferenciaciÃ³n del puntero (`*pi`)**:
   - `cout << *pi << endl;` utiliza el operador `*` (operador de desreferenciaciÃ³n) para acceder al valor almacenado en la direcciÃ³n de memoria a la que apunta `pi`, en este caso, `16`.  
   - Es decir, `*pi` equivale a `i`, por lo que se imprime `16`.

4. **Flujo de ejecuciÃ³n**:
   - Se declara `i` y se le asigna `16`.
   - Se declara el puntero `pi`.
   - Se almacena la direcciÃ³n de `i` en `pi`.
   - Se imprime el valor almacenado en la direcciÃ³n apuntada por `pi`, que es `16`.

En resumen, este programa demuestra cÃ³mo los punteros pueden usarse para **acceder y manipular directamente la memoria** en C++, permitiendo un mayor control sobre los datos almacenados.

</details>  

## **AritmÃ©tica de punteros**

En C++, los punteros pueden usarse en expresiones aritmÃ©ticas.

Esta aritmÃ©tica no es solo suma o resta simple; tiene en cuenta el tamaÃ±o del tipo de dato al que apunta el puntero.

---

### **Operaciones bÃ¡sicas de aritmÃ©tica de punteros**  

```cpp
#include <iostream>

using namespace std;

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    int *ptr = arr;
    
    // Imprimir el arreglo antes de modificarlo
    cout << "Arreglo original: ";
    for (int i = 0; i < 5; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    ptr++; // Ahora ptr apunta a arr[1]
    
    cout << "El valor al que apunta ptr (arr[1]) es: " << *ptr << endl;

    // Acceder a otros elementos usando aritmÃ©tica de punteros
    cout << "El siguiente elemento es: " << *(ptr + 1) << endl; // Equivalente a arr[2]
    cout << "El elemento anterior es: " << *(ptr - 1) << endl; // Equivalente a arr[0]

    // Modificar un elemento usando el puntero
    *ptr = 10; // Cambia el valor de arr[1] a 10

    // Imprimir el arreglo modificado
    cout << "Arreglo modificado: ";
    for (int i = 0; i < 5; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
```

**Salida esperada:**
```
Arreglo original: 1 2 3 4 5 
El valor al que apunta ptr (arr[1]) es: 2
El siguiente elemento es: 3
El elemento anterior es: 1
Arreglo modificado: 1 10 3 4 5 
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

Este programa demuestra cÃ³mo realizar operaciones bÃ¡sicas con punteros y cÃ³mo modificar un arreglo mediante **aritmÃ©tica de punteros** en **C++**. A continuaciÃ³n, se explican los conceptos clave:

1. **InicializaciÃ³n del arreglo y del puntero**:
   - `int arr[5] = {1, 2, 3, 4, 5};` define un arreglo de cinco enteros.
   - `int *ptr = arr;` inicializa el puntero `ptr` apuntando al **primer elemento** del arreglo (`arr[0]`).  

2. **ImpresiÃ³n del arreglo original**:
   - Se recorre el arreglo con un `for` y se imprime cada elemento.  

3. **AritmÃ©tica de punteros: desplazamiento en memoria**:
   - `ptr++;` mueve el puntero una posiciÃ³n adelante, ahora apunta a `arr[1]` (el valor `2`).  
   - `cout << *ptr;` imprime el valor al que apunta `ptr`, que es `2`.  
   - `*(ptr + 1);` accede al siguiente elemento (`arr[2]`, que es `3`).  
   - `*(ptr - 1);` accede al elemento anterior (`arr[0]`, que es `1`).  

4. **ModificaciÃ³n del arreglo usando el puntero**:
   - `*ptr = 10;` cambia el valor de `arr[1]` de `2` a `10`.  
   - Como `ptr` apunta a `arr[1]`, la modificaciÃ³n se refleja directamente en el arreglo original.  

5. **ImpresiÃ³n del arreglo modificado**:
   - Se recorre nuevamente el arreglo y se imprime su contenido, mostrando el cambio en `arr[1]`.  

En resumen, este programa ilustra cÃ³mo los punteros permiten **navegar y modificar un arreglo sin necesidad de Ã­ndices**, simplemente desplazando el puntero en la memoria.  

</details>  

---

### **Otras operaciones con punteros**  

```cpp
#include <iostream>

using namespace std;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int *ptr = arr;

    // Mostrar la direcciÃ³n inicial y el valor al que apunta
    cout << "DirecciÃ³n inicial de ptr: " << ptr << " | Valor: " << *ptr << endl;

    // Incrementar un puntero
    ptr++;
    cout << "DespuÃ©s de incrementar, ptr apunta a: " << *ptr << " (DirecciÃ³n: " << ptr << ")" << endl;

    // Sumar un entero a un puntero
    ptr += 2; // Ahora apunta a arr[3]
    cout << "DespuÃ©s de sumar 2, ptr apunta a: " << *ptr << " (DirecciÃ³n: " << ptr << ")" << endl;

    // Restar un entero a un puntero
    ptr -= 1; // Ahora apunta a arr[2]
    cout << "DespuÃ©s de restar 1, ptr apunta a: " << *ptr << " (DirecciÃ³n: " << ptr << ")" << endl;

    // Restar dos punteros
    int *ptr1 = &arr[1];
    int *ptr2 = &arr[4];
    int difference = ptr2 - ptr1; // Diferencia en tÃ©rminos de elementos
    cout << "Diferencia entre ptr2 y ptr1: " << difference << " elementos" << endl;

    return 0;
}
```

**Salida esperada:**  
```
DirecciÃ³n inicial de ptr: 0x12345678 | Valor: 10
DespuÃ©s de incrementar, ptr apunta a: 20 (DirecciÃ³n: 0x1234567C)
DespuÃ©s de sumar 2, ptr apunta a: 40 (DirecciÃ³n: 0x12345684)
DespuÃ©s de restar 1, ptr apunta a: 30 (DirecciÃ³n: 0x12345680)
Diferencia entre ptr2 y ptr1: 3 elementos
```

> [!NOTE]
>   
> Las direcciones de memoria en la salida son solo un ejemplo, asÃ­ que no te preocupes si ves algo diferente al ejecutar el cÃ³digo. ğŸ˜‰  


<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

Este programa muestra **operaciones bÃ¡sicas con punteros** en C++, como desplazamientos y diferencias entre punteros.

1. **InicializaciÃ³n del puntero**  
   - `ptr` apunta al primer elemento del arreglo `arr[0]`.

2. **Incremento (`ptr++`)**  
   - Avanza una posiciÃ³n en el arreglo (`arr[1]` â†’ `20`).

3. **Suma (`ptr += 2`)**  
   - Mueve el puntero dos posiciones adelante (`arr[3]` â†’ `40`).

4. **Resta (`ptr -= 1`)**  
   - Retrocede una posiciÃ³n (`arr[2]` â†’ `30`).

5. **Diferencia entre punteros (`ptr2 - ptr1`)**  
   - Calcula cuÃ¡ntos **elementos** separan `arr[1]` y `arr[4]` (3 elementos).

</details>  

---

## ğŸ§© **Problemas de Punteros Propuestos en C++**  

---

### ğŸ… **Problema puntero01: Suma de Elementos con Punteros** | âš”ï¸ **Guerrero** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Dado un arreglo de `n` nÃºmeros, usa **punteros** para calcular la **suma total**.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de nÃºmeros: 4
NÃºmero 1: 3
NÃºmero 2: 7
NÃºmero 3: 2
NÃºmero 4: 5
Suma total: 17
```  

> [!TIP]  
> Usa un puntero para recorrer el arreglo y sumar los valores.  

---

### ğŸ… **Problema puntero02: InversiÃ³n de un Arreglo** | ğŸ”¥ **Experto** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Dado un arreglo, usa **punteros** para invertir su contenido.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de nÃºmeros: 5
NÃºmeros originales: 1 2 3 4 5
NÃºmeros invertidos: 5 4 3 2 1
```  

> [!TIP]  
> Usa dos punteros: uno al inicio y otro al final, intercambiando valores hasta la mitad del arreglo.  

---

### ğŸ… **Problema puntero03: BÃºsqueda en un Arreglo con Punteros** | ğŸ‘‘ **Leyenda** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Dado un arreglo y un nÃºmero a buscar, usa punteros para verificar si el nÃºmero estÃ¡ presente y en quÃ© posiciÃ³n.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de nÃºmeros: 6
Ingresa los nÃºmeros: 4 8 15 16 23 42
Ingresa el nÃºmero a buscar: 15
El nÃºmero 15 se encuentra en la posiciÃ³n 3.
```  

> [!TIP]  
> Usa un puntero para recorrer el arreglo y comparar cada elemento con el nÃºmero buscado.  

---

# 5. **Referencias**  

Las **referencias** en **C++** permiten crear un alias para una variable existente, lo que significa que cualquier operaciÃ³n sobre la referencia afecta directamente a la variable original.  

> [!NOTE]
>
> Las referencias son una caracterÃ­stica nueva en C++ y no existen en C. Fueron introducidas para facilitar la manipulaciÃ³n de variables sin necesidad de punteros, mejorando la legibilidad y seguridad del cÃ³digo.

ğŸ“Œ **Diferencia clave con los punteros:**  
- Una referencia **no puede ser `nullptr`**.  
- Una vez inicializada, **no puede cambiar de objeto** al que hace referencia.  
- Su sintaxis es mÃ¡s sencilla y directa que la de los punteros.  

---

### Sintaxis: <!-- omit in toc -->   

```cpp
tipo &nombreReferencia = variable;
```  

ğŸ“Œ **ExplicaciÃ³n:**  
- `tipo`: El tipo de dato de la referencia debe coincidir con el de la variable original.  
- `&nombreReferencia`: Declara una referencia.  
- `variable`: Es la variable a la que hace referencia.  

---

### ğŸš€ **Ejemplo 1: Referencia a una variable**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int valor = 10;
    int &ref = valor;  // 'ref' es una referencia a 'valor'

    cout << "Valor original: " << valor << endl;
    cout << "Referencia: " << ref << endl;

    ref = 20;  // Cambia el valor de 'valor' a travÃ©s de la referencia

    cout << "Nuevo valor: " << valor << endl;
    return 0;
}
```  

ğŸ“Œ **Salida:**  
```
Valor original: 10
Referencia: 10
Nuevo valor: 20
```  

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- `int &ref = valor;` â†’ `ref` se comporta como un alias de `valor`, por lo que cualquier operaciÃ³n sobre `ref` afecta directamente a `valor`.  
- Modificar `ref` **tambiÃ©n modifica `valor`**, ya que ambas representan la misma variable en memoria.  

</details>

---

## **Referencias constantes (`const &`)**  <!-- omit in toc -->

Si no queremos modificar la variable original pero tampoco queremos hacer una copia, podemos usar **referencias constantes**.  

---

### ğŸš€ **Ejemplo 2: Uso de `const &`**  


```cpp
#include <iostream>
using namespace std;

int main() {
    int valor = 50;
    const int &ref = valor;  // Referencia constante a 'valor'

    cout << "Valor original: " << valor << endl;
    cout << "Referencia constante: " << ref << endl;

    // ref = 100;  // Esto darÃ­a error porque 'ref' es constante

    valor = 75;  // Se puede modificar 'valor' directamente

    cout << "Nuevo valor de 'valor': " << valor << endl;
    cout << "La referencia constante refleja el cambio: " << ref << endl;

    return 0;
}
```

ğŸ“Œ **Salida esperada:**  
```
Valor original: 50
Referencia constante: 50
Nuevo valor de 'valor': 75
La referencia constante refleja el cambio: 75
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- `const int &ref = valor;` â†’ `ref` es una **referencia constante**, lo que significa que **no se puede modificar `valor` a travÃ©s de `ref`**.  
- **Sin embargo**, `valor` **sÃ­ puede cambiar**, y como `ref` es solo un alias de `valor`, reflejarÃ¡ el nuevo valor automÃ¡ticamente.  
- **Intentar hacer `ref = 100;` generarÃ­a un error de compilaciÃ³n**, ya que `ref` es constante.  

</details>

---

## **ComparaciÃ³n entre referencias y punteros**  

| CaracterÃ­stica | Referencias (`&`) | Punteros (`*`) |
|--------------|----------------|--------------|
| Puede ser `nullptr` | âŒ No | âœ… SÃ­ |
| Puede cambiar de objeto | âŒ No | âœ… SÃ­ |
| MÃ¡s seguro y fÃ¡cil de leer | âœ… SÃ­ | âŒ No |
| Necesita `*` para acceder al valor | âŒ No | âœ… SÃ­ |

# 6. **Funciones**

Las funciones permiten reutilizar cÃ³digo dentro de un programa. Una funciÃ³n en **C++** estÃ¡ compuesta por:  

- Tipo de retorno  
- Nombre de la funciÃ³n  
- Lista de parÃ¡metros  
- Cuerpo de la funciÃ³n  

```cpp
tipo_retorno nombre_funcion(param1, param2, ...) {
    ...
    cuerpo_de_la_funciÃ³n;
    ...
}
```

### **Ejemplo:**  <!-- omit in toc -->

```cpp
#include <iostream>

using namespace std;

// FunciÃ³n para sumar dos nÃºmeros
int sumar(int num1, int num2) {
    return num1 + num2;
}

int main() {
    int a = 5, b = 3;
    cout << "La suma de " << a << " y " << b << " es: " << sumar(a, b) << endl;

    int c = 10, d = 7;
    cout << "La suma de " << c << " y " << d << " es: " << sumar(c, d) << endl;

    cout << "La suma de 20 y 15 es: " << sumar(20, 15) << endl;
    cout << "La suma de -5 y 8 es: " << sumar(-5, 8) << endl;
    cout << "La suma de 0 y 0 es: " << sumar(0, 0) << endl;

    return 0;
}
```

> [!IMPORTANT]
>
> Es fundamental comprender la diferencia entre un *parÃ¡metro* y un *argumento* para evitar confusiones:
> 
> - **ParÃ¡metros**: Son las variables que aparecen en la definiciÃ³n de la funciÃ³n. En este cÃ³digo, `num1` y `num2` en `sumar(int num1, int num2)` son parÃ¡metros.
> - **Argumentos**: Son los valores reales que se pasan a la funciÃ³n cuando esta es invocada. En este cÃ³digo, `a`, `b`, `c`, `d`, `20, 15`, `-5, 8`, etc., son argumentos porque representan los datos especÃ­ficos que se envÃ­an a la funciÃ³n al momento de su llamada.
>
> Es comÃºn confundirlos, pero la diferencia clave es que los **parÃ¡metros** existen en la **definiciÃ³n** de la funciÃ³n, mientras que los **argumentos** aparecen en la **llamada**.

> [!NOTE]
> 
> Cuando te hablen de la **firma** (*signature*) de una funciÃ³n, recuerda que simplemente se refiere a su nombre y la cantidad, tipo y orden de sus parÃ¡metros. No incluye el tipo de retorno.  
> 
> En el ejemplo anterior, la firma de la funciÃ³n `sumar` es `sumar(int, int)`, lo que significa que recibe dos enteros como parÃ¡metros.

---

## **MÃ©todos de paso de argumentos**  

En **C++**, los parÃ¡metros de una funciÃ³n pueden pasarse de tres maneras:  

### **Paso por valor**  

Este es el mÃ©todo predeterminado. Se pasa una copia del valor del argumento a la funciÃ³n, por lo que **las modificaciones dentro de la funciÃ³n no afectan al argumento original**.  

#### Ejemplo: <!-- omit in toc -->  

```cpp
#include <iostream>

using namespace std;

void intercambiar(int x, int y) {
    int temp = x;
    x = y;
    y = temp;
}

int main() {
    int a = 4, b = 5;
    intercambiar(a, b);
    cout << "DespuÃ©s de la funciÃ³n:\na = " << a << "\nb = " << b << endl;
    return 0;
}
```

**Salida esperada:**  
```
DespuÃ©s de la funciÃ³n:
a = 4
b = 5
```

> [!NOTE]
> 
> Como `x` e `y` son copias, el intercambio **no afecta** a `a` y `b`.
>

---

### **Paso por referencia con punteros**  

AquÃ­ se pasa la direcciÃ³n de los argumentos a la funciÃ³n usando **punteros**. Esto permite modificar los valores originales.  

#### Ejemplo:  <!-- omit in toc -->  

```cpp
#include <iostream>

using namespace std;

void intercambiar(int* x, int* y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main() {
    int a = 4, b = 5;
    intercambiar(&a, &b);
    cout << "DespuÃ©s de la funciÃ³n:\na = " << a << "\nb = " << b << endl;
    return 0;
}
```

**Salida esperada:**  
```
DespuÃ©s de la funciÃ³n:
a = 5
b = 4
```

> [!NOTE]
> 
> AquÃ­ sÃ­ se intercambian los valores, ya que se estÃ¡n modificando directamente en memoria.
> 

---

### **Paso por referencia con referencias**  

Este mÃ©todo utiliza **referencias (`&`)** en lugar de punteros, lo que simplifica el cÃ³digo sin perder eficiencia.  

#### Ejemplo:  <!-- omit in toc -->  

```cpp
#include <iostream>

using namespace std;

void intercambiar(int &x, int &y) {
    int temp = x;
    x = y;
    y = temp;
}

int main() {
    int a = 4, b = 5;
    intercambiar(a, b);
    cout << "DespuÃ©s de la funciÃ³n:\na = " << a << "\nb = " << b << endl;
    return 0;
}
```

**Salida esperada:**  
```
DespuÃ©s de la funciÃ³n:
a = 5
b = 4
```
> [!NOTE]
> 
> Al pasar por referencia, `a` y `b` se modifican **sin necesidad de usar punteros**.

---

## ğŸ“Œ ConclusiÃ³n <!-- omit in toc -->

| MÃ©todo | Â¿Modifica el valor original? | Complejidad |
|--------|-----------------------------|------------|
| **Por valor (`int x`)** | âŒ No | Baja (se crea una copia) |
| **Por referencia con punteros (`int* x`)** | âœ… SÃ­ | Media (requiere `&` y `*`) |
| **Por referencia con referencias (`int &x`)** | âœ… SÃ­ | Baja (mÃ¡s intuitivo que punteros) |

> [!IMPORTANT]
> 
> Si necesitas proteger el valor original, usa **paso por valor**.  
> Si quieres modificarlo sin copias, usa **paso por referencia (con punteros o referencias)**.  

---
## ğŸ§© **Problemas de Funciones Propuestos en C++**  

---

### ğŸ… **Problema funciÃ³n01: ConversiÃ³n de Tiempo** | â³ **Novato** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Crea una funciÃ³n `convertirTiempo` que reciba una cantidad de **segundos** y devuelva su equivalente en **horas, minutos y segundos**.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa los segundos: 3661
Resultado: 1 horas, 1 minutos, 1 segundos
```  

ğŸ“Œ **Nombre de la funciÃ³n:** `convertirTiempo`  
ğŸ“Œ **Lista de parÃ¡metros:** `(int segundos, int &horas, int &minutos, int &segundos)`  

> [!TIP]  
> Desglosa el tiempo en partes: los **segundos totales** se pueden dividir para obtener las **horas** y el **resto de segundos**. Luego, haz lo mismo para calcular los **minutos** y los **segundos finales**. AsegÃºrate de que la funciÃ³n pueda manejar diferentes valores de entrada, incluyendo `0` segundos. ğŸš€  

---

### ğŸ… **Problema funciÃ³n02: Operaciones con Arreglos** | ğŸ“Š **Experto** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Crea una funciÃ³n `calcularOperaciones` que reciba un **arreglo de nÃºmeros** y devuelva la **suma**, el **promedio** y el **mayor nÃºmero**.  

ğŸ“Œ **Ejemplo:**  
```
Ingresa la cantidad de nÃºmeros: 4
NÃºmeros: 10 20 30 40
Suma: 100
Promedio: 25
Mayor: 40
```  

ğŸ“Œ **Nombre de la funciÃ³n:** `calcularOperaciones`  
ğŸ“Œ **Lista de parÃ¡metros:** `(int arr[], int n, int &suma, float &promedio, int &mayor)`  

> [!TIP]  
> Usa un `for` para recorrer el arreglo y calcular los valores requeridos en una sola pasada. Ten en cuenta que el primer nÃºmero leÃ­do puede ser el **mayor** temporalmente hasta que encuentres uno mÃ¡s grande. TambiÃ©n, asegÃºrate de manejar casos donde el arreglo tenga solo un nÃºmero. ğŸš€  

---

### ğŸ… **Problema funciÃ³n03: CÃ¡lculo de InterÃ©s Compuesto** | ğŸ’° **Maestro** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Crea una funciÃ³n `calcularInteresCompuesto` que reciba el **capital inicial**, la **tasa de interÃ©s** y los **aÃ±os**, y calcule el **monto final** aplicando **interÃ©s compuesto**.  

ğŸ“Œ **Ejemplo:**  
```
Capital inicial: 1000
Tasa de interÃ©s anual: 5%
AÃ±os: 3
Monto total: 1157.63
```  

ğŸ“Œ **Nombre de la funciÃ³n:** `calcularInteresCompuesto`  
ğŸ“Œ **Lista de parÃ¡metros:** `(double capital, double tasa, int aÃ±os) -> retorna double`  

> [!TIP]  
> Usa la fÃ³rmula `M = C * (1 + r/100)^t` y la funciÃ³n `pow()` de `<cmath>`. ğŸš€  

---

### ğŸ… **Problema funciÃ³n04: CÃ¡lculo de Ãrea y PerÃ­metro de un RectÃ¡ngulo** | ğŸ“ **Leyenda** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Crea una funciÃ³n `calcularRectangulo` que reciba el **largo** y **ancho** de un rectÃ¡ngulo y devuelva su **Ã¡rea** y **perÃ­metro**.  

ğŸ“Œ **Ejemplo:**  
```
Largo: 5
Ancho: 3
Ãrea: 15
PerÃ­metro: 16
```  

ğŸ“Œ **Nombre de la funciÃ³n:** `calcularRectangulo`  
ğŸ“Œ **Lista de parÃ¡metros:** `(double largo, double ancho, double &area, double &perimetro)`  

> [!TIP]  
> Usa las fÃ³rmulas `Ã¡rea = largo * ancho` y `perÃ­metro = 2 * (largo + ancho)`. AsegÃºrate de probar la funciÃ³n con diferentes valores, incluyendo rectÃ¡ngulos con lados iguales. ğŸš€  

---

### ğŸ… **Problema funciÃ³n05: Cifrado CÃ©sar** | ğŸ” **Gran Maestro** <!-- omit in toc -->  

ğŸ”¹ **DescripciÃ³n:** Crea una funciÃ³n `cifrarCesar` que reciba una **cadena** y un **desplazamiento `n`** y la cifre usando **Cifrado CÃ©sar**.  

ğŸ“Œ **Ejemplo:**  
```
Texto original: HOLA
Desplazamiento: 3
Texto cifrado: KROD
```  

ğŸ“Œ **Nombre de la funciÃ³n:** `cifrarCesar`  
ğŸ“Œ **Lista de parÃ¡metros:** `(string texto, int desplazamiento) -> retorna string`  

> [!TIP]  
> Usa `isalpha(c)` para verificar si un carÃ¡cter es una letra antes de cifrarlo. Ajusta los valores con `mod 26` para evitar desbordamientos y mantener el cifrado dentro del alfabeto. ğŸš€  

---

# 7. **AsignaciÃ³n dinÃ¡mica de memoria en C++**  

La **asignaciÃ³n dinÃ¡mica de memoria** ocurre cuando se reserva memoria en **tiempo de ejecuciÃ³n** usando una funciÃ³n de la biblioteca estÃ¡ndar. En **C++**, esto se logra con los operadores `new` y `delete`.  

---

## **AsignaciÃ³n de memoria dinÃ¡mica**  

Para crear objetos dinÃ¡micos en C++, se usa la palabra clave **`new`**.  

ğŸ“Œ **Ejemplo 1: Reservar memoria para un solo entero**  

```cpp
int *p = new int;
```

> [!NOTE]
> 
> Esto asigna **memoria sin nombre** para almacenar un valor de tipo `int` y devuelve la direcciÃ³n de esa memoria.  

ğŸ“Œ **Ejemplo 2: Reservar memoria para un array dinÃ¡mico**  

```cpp
int *q = new int[128];
```

Esta lÃ­nea reserva **memoria para un arreglo de 128 elementos de tipo `int`**.  

---

## **LiberaciÃ³n de memoria dinÃ¡mica**  

Para evitar **fugas de memoria**, es importante liberar la memoria asignada con `delete`.  

> [!NOTE]
> 
> Si no liberas la memoria asignada con `new`, seguirÃ¡ ocupando espacio incluso cuando ya no la necesites, causando **fugas de memoria**. Esto puede ralentizar el sistema y, en casos extremos, hacer que el programa **colapse**. Siempre que uses `new`, asegÃºrate de usar `delete` para liberar la memoria. ğŸš€


ğŸ“Œ **Ejemplo:**  

```cpp
delete p;      // Libera la memoria de un solo entero
delete[] q;    // Libera la memoria de un array dinÃ¡mico
```

---

## **AplicaciÃ³n prÃ¡ctica: Memoria estÃ¡tica vs dinÃ¡mica en C++**  

En esta prÃ¡ctica, comparamos el uso de **memoria dinÃ¡mica** y **memoria estÃ¡tica** en C++ para almacenar los promedios de un grupo de estudiantes. Ambas versiones del programa permiten ingresar y visualizar los promedios, pero difieren en cÃ³mo gestionan la memoria.  

---

### **VersiÃ³n dinÃ¡mica**  

```cpp
#include <iostream>
using namespace std;

int main() {
    int numEstudiantes;

    cout << "Ingrese el nÃºmero de estudiantes: ";
    cin >> numEstudiantes;

    // Reservar memoria para un array dinÃ¡mico de promedios
    float *promedios = new float[numEstudiantes];

    // Verificar si la asignaciÃ³n de memoria fue exitosa
    if (!promedios) {
        cerr << "Error: No se pudo asignar memoria.\n";
        return 1;
    }

    // Ingresar los promedios de los estudiantes
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Promedio del estudiante " << i + 1 << ": ";
        cin >> promedios[i];
    }

    // Imprimir los promedios
    cout << "\nPromedios de los estudiantes:\n";
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Estudiante " << i + 1 << ": " << promedios[i] << endl;
    }

    // Liberar la memoria asignada dinÃ¡micamente
    delete[] promedios;

    return 0;
}
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- Se usa `new float[numEstudiantes]` para **reservar memoria dinÃ¡mica**, permitiendo definir el tamaÃ±o del arreglo en tiempo de ejecuciÃ³n.  
- Se verifica si la asignaciÃ³n de memoria fue exitosa para evitar **errores en tiempo de ejecuciÃ³n**.  
- Se capturan e imprimen los promedios ingresados por el usuario.  
- Finalmente, se libera la memoria con `delete[] promedios` para **evitar fugas de memoria**, asegurando un uso eficiente de los recursos.  

</details>

---

### **VersiÃ³n estÃ¡tica**  

En esta versiÃ³n, usamos memoria estÃ¡tica para almacenar los promedios de los estudiantes, como lo hacÃ­amos convencionalmente. A diferencia de la memoria dinÃ¡mica, el tamaÃ±o del arreglo es fijo y, una vez creado, no puede modificarse ni liberarse para devolver la memoria al sistema.

```cpp
#include <iostream>
using namespace std;

#define MAX_ESTUDIANTES 100  // TamaÃ±o mÃ¡ximo del array

int main() {
    int numEstudiantes;
    float promedios[MAX_ESTUDIANTES];

    cout << "Ingrese el nÃºmero de estudiantes (mÃ¡ximo " << MAX_ESTUDIANTES << "): ";
    cin >> numEstudiantes;

    if (numEstudiantes > MAX_ESTUDIANTES) {
        cout << "El nÃºmero de estudiantes supera el lÃ­mite.\n";
        return 1;
    }

    // Ingresar los promedios de los estudiantes
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Promedio del estudiante " << i + 1 << ": ";
        cin >> promedios[i];
    }

    // Imprimir los promedios
    cout << "\nPromedios de los estudiantes:\n";
    for (int i = 0; i < numEstudiantes; i++) {
        cout << "Estudiante " << i + 1 << ": " << promedios[i] << endl;
    }

    return 0;
}
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- Se declara un **arreglo estÃ¡tico** con un tamaÃ±o mÃ¡ximo definido (`MAX_ESTUDIANTES = 100`).  
- El usuario ingresa la cantidad de estudiantes, pero **no se puede superar el lÃ­mite predefinido**.  
- Se capturan e imprimen los promedios de los estudiantes, igual que en la versiÃ³n dinÃ¡mica.  
- **No es necesario liberar memoria manualmente**, ya que el arreglo se destruye automÃ¡ticamente cuando el programa finaliza.  

</details>

---

## **Diferencias clave entre memoria dinÃ¡mica y estÃ¡tica**  <!-- omit in toc -->

| CaracterÃ­stica | Memoria DinÃ¡mica (`new`) | Memoria EstÃ¡tica (Array fijo) |
|---------------|-------------------------|------------------------------|
| **TamaÃ±o ajustable en ejecuciÃ³n** | âœ… SÃ­ | âŒ No |
| **Eficiencia en uso de memoria** | âœ… Mejor | âŒ Puede desperdiciar espacio |
| **Riesgo de fuga de memoria** | âŒ SÃ­ (si no se usa `delete`) | âœ… No |
| **Velocidad de acceso** | ğŸ”„ Ligeramente mÃ¡s lenta | âš¡ MÃ¡s rÃ¡pida |

---

> [!IMPORTANT]
> 
> - Usa **memoria dinÃ¡mica (`new`)** cuando **no conoces el tamaÃ±o exacto** en tiempo de compilaciÃ³n.  
> - Usa **memoria estÃ¡tica (arrays normales)** si el tamaÃ±o es fijo y conocido.  
> - **Siempre** libera la memoria con `delete` para evitar **fugas de memoria**. ğŸš€

# 8. **Templates**  

Los **templates** en **C++** permiten parametrizar funciones o clases para trabajar con diferentes tipos de datos sin duplicar cÃ³digo.  

> [!NOTE]
> 
> Los templates proporcionan flexibilidad y reutilizaciÃ³n, permitiendo definir algoritmos genÃ©ricos sin especificar un tipo de dato concreto.  

---

### ğŸš€ **Ejemplo 1: FunciÃ³n genÃ©rica para encontrar el mÃ¡ximo**  

```cpp
#include <iostream>
#include <string>

using namespace std;

template <typename T>
T maximum(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    string x{"Hello"};
    string y{"World"};
    auto result = maximum(x, y);

    cout << "Entre \"" << x << "\" y \"" << y << "\", el resultado es: " << result << endl;

    // Pruebas con otros tipos
    int a = 10, b = 25;
    double d1 = 3.5, d2 = 7.8;
    char c1 = 'A', c2 = 'Z';

    cout << "Entre " << a << " y " << b << ", el resultado es: " << maximum(a, b) << endl;
    cout << "Entre " << d1 << " y " << d2 << ", el resultado es: " << maximum(d1, d2) << endl;
    cout << "Entre '" << c1 << "' y '" << c2 << "', el resultado es: " << maximum(c1, c2) << endl;

    return 0;
}
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- `template <typename T>` permite definir una funciÃ³n genÃ©rica que puede trabajar con distintos tipos de datos.  
- La funciÃ³n `maximum(T a, T b)` compara dos valores del mismo tipo y devuelve el mayor.  
- `auto` se usa para deducir automÃ¡ticamente el tipo de `result` en `main()`.  
- Se demuestra su uso con **`int`**, **`double`**, **`char`** y **`string`**, mostrando que funciona de forma genÃ©rica sin necesidad de sobrecargas manuales.  

</details>

ğŸ“Œ **Salida:**  
```
Entre "Hello" y "World", el resultado es: World
Entre 10 y 25, el resultado es: 25
Entre 3.5 y 7.8, el resultado es: 7.8
Entre 'A' y 'Z', el resultado es: Z
```

---

### ğŸš€ **Ejemplo 2: FunciÃ³n genÃ©rica para intercambiar valores**  

```cpp
#include <iostream>
using namespace std;

template <class T>
void mySwap(T &x, T &y) {  
    T t = x; x = y; y = t;
}

int main() {
    int a = 10, b = 20;
    double d = 10.0, e = 20.0;
    char c = 'a', s = 'b';

    mySwap(a, b); mySwap(d, e); mySwap(c, s);

    cout << "a = " << a << "   b = " << b << endl;
    cout << "d = " << d << "   e = " << e << endl;
    cout << "c = " << c << "   s = " << s << endl;

    return 0;
}
```

ğŸ“Œ **Salida:**  
```
a = 20   b = 10
d = 20   e = 10
c = b   s = a
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- `template <class T>` permite definir una funciÃ³n genÃ©rica que puede intercambiar valores de cualquier tipo de dato.  
- La funciÃ³n `mySwap(T &x, T &y)` intercambia dos variables sin necesidad de sobrecargar la funciÃ³n para cada tipo especÃ­fico.  
- Se prueba con **`int`**, **`double`** y **`char`**, demostrando su flexibilidad y reutilizaciÃ³n.  
- La salida muestra que los valores han sido correctamente intercambiados, manteniendo la estructura del cÃ³digo limpia y eficiente.  

</details>

---

# 9. **Inline Expansion**  

Algunas funciones son tan pequeÃ±as que la sobrecarga de invocarlas puede ser mayor que su ejecuciÃ³n. **C++** permite definir funciones **inline** para que el compilador reemplace la llamada a la funciÃ³n con el cÃ³digo en sÃ­.  


> [!WARNING]  
> Un uso excesivo de la **expansiÃ³n en lÃ­nea** (*inline expansion*) puede aumentar el tamaÃ±o del cÃ³digo binario (*code bloat*), reduciendo la eficiencia y afectando la optimizaciÃ³n del compilador.  

---

### ğŸš€ **Ejemplo 1: FunciÃ³n inline**  <!-- omit in toc -->

```cpp
inline int max(int x, int y) {
    return (x > y ? x : y);
}
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- `inline` sugiere al compilador que expanda la funciÃ³n en lugar de llamarla.  
- Se usa para funciones cortas que se ejecutan con frecuencia.  

</details>

---

### ğŸš€ **Ejemplo 2: Template inline**  <!-- omit in toc -->

```cpp
template<class T> inline
T square(T x) {
    return x * x;
}
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- `inline` mejora el rendimiento eliminando la sobrecarga de la llamada.  
- `template<class T>` permite usar cualquier tipo de dato para `square()`.  

</details>

---

# 10. **Overloading**  

La **sobrecarga de funciones** en **C++** permite definir mÃºltiples versiones de una misma funciÃ³n con diferentes tipos o cantidades de parÃ¡metros.  
El compilador elige automÃ¡ticamente la versiÃ³n correcta en funciÃ³n de los argumentos proporcionados.  

Esta tÃ©cnica mejora la **reutilizaciÃ³n de cÃ³digo** y **la legibilidad**, evitando la necesidad de nombres de funciÃ³n distintos para cada tipo de dato.  

El compilador selecciona la versiÃ³n correcta en funciÃ³n del nÃºmero y tipo de argumentos.  

---

### ğŸš€ **Ejemplo:**  <!-- omit in toc -->

```cpp
#include <iostream>

using namespace std;

// NotificaciÃ³n bÃ¡sica
void sendNotification(const string& message) {
    cout << "[NOTIFICACIÃ“N] " << message << endl;
}

// NotificaciÃ³n con nivel de prioridad
void sendNotification(const string& message, int priority) {
    cout << "[PRIORIDAD " << priority << "] " << message << endl;
}

// NotificaciÃ³n con destinatario y prioridad
void sendNotification(const string& message, const string& recipient, int priority) {
    cout << "[Para: " << recipient << "] [PRIORIDAD " << priority << "] " << message << endl;
}

int main() {
    sendNotification("El sistema se ha actualizado.");                       // NotificaciÃ³n bÃ¡sica
    sendNotification("Carga de CPU alta", 2);                                // NotificaciÃ³n con prioridad
    sendNotification("ActualizaciÃ³n de seguridad disponible", "Admin", 1);   // NotificaciÃ³n con destinatario y prioridad

    return 0;
}
```

ğŸ“Œ **Salida:**  
```
[NOTIFICACIÃ“N] El sistema se ha actualizado.
[PRIORIDAD 2] Carga de CPU alta
[Para: Admin] [PRIORIDAD 1] ActualizaciÃ³n de seguridad disponible
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

1. **DefiniciÃ³n de `sendNotification()`**:  
   - La versiÃ³n simple muestra un mensaje: `void sendNotification(const string& message)`.  
   - La versiÃ³n con prioridad agrega un parÃ¡metro `priority`: `void sendNotification(const string& message, int priority)`.  
   - La versiÃ³n con destinatario y prioridad: `void sendNotification(const string& message, const string& recipient, int priority)`.

2. **Uso en `main()`**:  
   - Se llaman las diferentes versiones de `sendNotification()` segÃºn los parÃ¡metros.

3. **SelecciÃ³n automÃ¡tica**:  
   - El compilador elige la versiÃ³n adecuada segÃºn los argumentos.

4. **Beneficio**:  
   - El cÃ³digo es mÃ¡s claro y reutilizable sin necesidad de nombres de funciÃ³n adicionales.
</details>

> [!NOTE]
>
> Es importante resaltar que existen otros tipos de sobrecarga que veremos mÃ¡s adelante, como:
>
>- **Sobrecarga de operadores**: Permite redefinir el comportamiento de los operadores (como `+`, `-`, etc.) para tipos definidos por el usuario.
>- **Sobrecarga de constructores**: Permite definir mÃºltiples constructores para una clase, con diferentes parÃ¡metros, para crear objetos de diversas formas.
>

---

# 11. **Manejo de Excepciones**  

El **manejo de excepciones** en **C++** permite capturar errores en tiempo de ejecuciÃ³n sin detener bruscamente el programa.  

> [!NOTE]  
>  
> `try` encapsula el cÃ³digo propenso a errores, mientras que `catch` maneja las excepciones cuando ocurren.  
>  

---

### ğŸš€ **Ejemplo 1: Manejo de DivisiÃ³n por Cero**  

```cpp
#include <iostream>

using namespace std;

double dividir(double a, double b) {
    if (b == 0) throw runtime_error("Error: DivisiÃ³n por cero");
    return a / b;
}

int main() {
    try {
        double resultado = dividir(10, 0);  // Error: DivisiÃ³n por cero
        cout << "Resultado: " << resultado << endl;
    } 
    catch (const runtime_error& e) { 
        cout << "ExcepciÃ³n capturada: " << e.what() << endl;
    }

    return 0;
}
```

ğŸ“Œ **Salida:**  
```
ExcepciÃ³n capturada: Error: DivisiÃ³n por cero
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- `throw runtime_error("Error: DivisiÃ³n por cero")` lanza una excepciÃ³n cuando `b == 0`.  
- `try` intenta ejecutar `dividir(10, 0)`, pero esto genera una excepciÃ³n.  
- `catch (const runtime_error& e)` captura la excepciÃ³n especÃ­fica y muestra el mensaje.  
- `e.what()` devuelve el mensaje del error.  

</details>

---

### ğŸš€ **Ejemplo 2: ValidaciÃ³n de Rango en Entrada de Usuario** 

```cpp
#include <iostream>
#include <stdexcept> // Necesario para usar out_of_range

using namespace std;

void validarNumero(int num) {
    if (num < 1 || num > 10) {
        throw out_of_range("NÃºmero fuera de rango permitido (1-10)");
    }
}

int main() {
    int numero;

    try {
        cout << "Ingrese un nÃºmero entre 1 y 10: ";
        cin >> numero;
        
        validarNumero(numero); // Lanza excepciÃ³n si estÃ¡ fuera de rango
        
        cout << "NÃºmero vÃ¡lido ingresado: " << numero << endl;
    } 
    catch (const out_of_range& e) { 
        cout << "ExcepciÃ³n capturada: " << e.what() << endl;
    }

    return 0;
}
```

ğŸ“Œ **Salidas:**

âœ… Entrada vÃ¡lida:  
```
Ingrese un nÃºmero entre 1 y 10: 5
NÃºmero vÃ¡lido ingresado: 5
```

âŒ Entrada fuera de rango:  
```
Ingrese un nÃºmero entre 1 y 10: 20
ExcepciÃ³n capturada: NÃºmero fuera de rango permitido (1-10)
```

---

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- `validarNumero(int num)` verifica si el nÃºmero estÃ¡ **entre 1 y 10**.  
- Si el nÃºmero estÃ¡ **fuera del rango**, se lanza una excepciÃ³n con `throw out_of_range("NÃºmero fuera de rango permitido (1-10)")`.  
- En `main()`, se solicita un nÃºmero al usuario y se llama a `validarNumero(numero)`.  
- Si el nÃºmero estÃ¡ fuera del rango, **`catch (const out_of_range& e)` captura la excepciÃ³n** y muestra el mensaje de error.  
- `e.what()` devuelve el mensaje de la excepciÃ³n lanzada, que en este caso es `"NÃºmero fuera de rango permitido (1-10)"`.  

</details>  

### ğŸš€ **Ejemplo 3: Manejo de MÃºltiples Excepciones**  

AquÃ­ tienes un **ejemplo que combina varias excepciones** en una sola ejecuciÃ³n:  

```cpp
#include <iostream>
#include <stdexcept>

using namespace std;

int dividir(int a, int b) {
    if (b == 0) throw runtime_error("Error: DivisiÃ³n por cero");
    return a / b;
}

int main() {
    try {
        int num;
        cout << "Ingrese un nÃºmero entre 1 y 10: ";
        cin >> num;

        if (num < 1 || num > 10) throw out_of_range("NÃºmero fuera de rango");

        int resultado = dividir(10, num);
        cout << "Resultado de la divisiÃ³n: " << resultado << endl;
    }
    catch (const out_of_range& e) {
        cout << "ExcepciÃ³n capturada (rango): " << e.what() << endl;
    }
    catch (const runtime_error& e) {
        cout << "ExcepciÃ³n capturada (divisiÃ³n): " << e.what() << endl;
    }

    return 0;
}
```

ğŸ“Œ **Salidas:**  

âœ… Entrada vÃ¡lida:  
```
Ingrese un nÃºmero entre 1 y 10: 5
Resultado de la divisiÃ³n: 2
```

âŒ Entrada fuera de rango:  
```
Ingrese un nÃºmero entre 1 y 10: 20
ExcepciÃ³n capturada (rango): NÃºmero fuera de rango
```

âŒ DivisiÃ³n por cero:  
```
Ingrese un nÃºmero entre 1 y 10: 0
ExcepciÃ³n capturada (divisiÃ³n): Error: DivisiÃ³n por cero
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- `throw out_of_range("NÃºmero fuera de rango")` se usa si el nÃºmero ingresado **no estÃ¡ entre 1 y 10**.  
- `throw runtime_error("Error: DivisiÃ³n por cero")` se lanza si el usuario ingresa `0` como divisor.  
- Se usan **dos bloques `catch`**: uno para `out_of_range` y otro para `runtime_error`.  
- El programa **maneja ambas excepciones sin cerrarse abruptamente**.  

</details>


## **Excepciones Adicionales en &lt;stdexcept&gt;**  

AdemÃ¡s de `out_of_range`, **C++ ofrece varias excepciones estÃ¡ndar** para manejar distintos tipos de errores:  

| ExcepciÃ³n              | DescripciÃ³n  |  
|------------------------|-------------|  
| **`std::out_of_range`**   | Se lanza cuando se intenta acceder a un Ã­ndice fuera del rango permitido (ejemplo: `std::vector::at()`). |  
| **`std::invalid_argument`** | Se lanza cuando se pasa un argumento invÃ¡lido a una funciÃ³n (ejemplo: `std::stoi("abc")`). |  
| **`std::runtime_error`**  | Se usa para errores en **tiempo de ejecuciÃ³n**, como divisiones por cero personalizadas. |  
| **`std::logic_error`**  | Se usa para errores en la **lÃ³gica del cÃ³digo**, como condiciones incorrectas. |  
| **`std::domain_error`**  | Se lanza cuando se usa un **valor fuera del dominio vÃ¡lido** de una funciÃ³n matemÃ¡tica (ejemplo: `sqrt(-1)`). |  
| **`std::length_error`**  | Se lanza si se intenta **crear una estructura de datos con un tamaÃ±o superior al permitido**. |  
| **`std::bad_alloc`**  | Se lanza cuando `new` **no puede asignar memoria** (cuando no hay suficiente memoria RAM disponible). |  


---

# 12. **Estructuras**

Una **estructura** es una colecciÃ³n de una o mÃ¡s variables agrupadas bajo un mismo nombre. Permiten almacenar datos relacionados en una sola entidad, facilitando la organizaciÃ³n del cÃ³digo.

### ğŸš€ **Ejemplo 1: Definiendo un Nuevo Tipo de Dato - Punto**

```cpp
#include <iostream>
using namespace std;

struct Punto {
    int x;
    int y;
};

int main() {
    Punto p1 = {-1, 4}, p2 = {1, 5}, p3;

    p3.x = 3;
    p3.y = 6;

    cout << "Punto 1 = (" << p1.x << ", " << p1.y << ")\n";  // Punto 1 = (-1, 4)
    cout << "Punto 2 = (" << p2.x << ", " << p2.y << ")\n";  // Punto 2 = (1, 5)
    cout << "Punto 3 = (" << p3.x << ", " << p3.y << ")\n";  // Punto 3 = (3, 6)

    return 0;
}
```

ğŸ“Œ **Salida:**
```
Punto 1 = (-1, 4)
Punto 2 = (1, 5)
Punto 3 = (3, 6)
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- Se define una estructura `punto` con dos variables `x` e `y`.  
- Se declaran tres variables de tipo `punto`: `p1`, `p2` y `p3`.  
- `p1` y `p2` se inicializan directamente, mientras que `p3` se asigna manualmente.  
- Se imprimen los valores almacenados en las estructuras.  

</details>

### ğŸš€ **Ejemplo 2: Definiendo un Nuevo Tipo de Dato - Gato**

```cpp
#include <iostream>
using namespace std;

struct Gato {
    int edad;
    int altura;
    string nombre;
    string padre;
    string madre;
};

int main() {
    Gato miGato;

    cout << "Ingrese el nombre del gato: ";
    cin >> miGato.nombre;

    cout << "Â¿CuÃ¡ntos aÃ±os tiene " << miGato.nombre << "? ";
    cin >> miGato.edad;

    cout << "Â¿CuÃ¡nto mide " << miGato.nombre << " (en manos)? ";
    cin >> miGato.altura;

    cout << "Â¿QuiÃ©n es el padre de " << miGato.nombre << "? ";
    cin >> miGato.padre;

    cout << "Â¿QuiÃ©n es la madre de " << miGato.nombre << "? ";
    cin >> miGato.madre;

    cout << "\n" << miGato.nombre << " tiene " << miGato.edad << " aÃ±os, mide " << miGato.altura << " manos";
    cout << " y sus padres son " << miGato.padre << " y " << miGato.madre << ".\n";

    return 0;
}
```

ğŸ“Œ **Salida esperada:**
```
Ingrese el nombre del gato: Whiskers
Â¿CuÃ¡ntos aÃ±os tiene Whiskers? 3
Â¿CuÃ¡nto mide Whiskers (en manos)? 5
Â¿QuiÃ©n es el padre de Whiskers? Tom
Â¿QuiÃ©n es la madre de Whiskers? Luna

Whiskers tiene 3 aÃ±os, mide 5 manos y sus padres son Tom y Luna.
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- Se define la estructura `Gato`, que almacena informaciÃ³n sobre un gato.  
- Se solicita la entrada del usuario para asignar valores a `nombre`, `edad`, `altura`, `padre` y `madre`.  
- Los datos ingresados se imprimen en pantalla al final del programa.  

</details>

ğŸ“Œ **Salida:**
```
Ingrese el nombre del gato: Whiskers
Â¿CuÃ¡ntos aÃ±os tiene Whiskers? 3
Â¿CuÃ¡nto mide Whiskers (en manos)? 5
Â¿QuiÃ©n es el padre de Whiskers? Tom
Â¿QuiÃ©n es la madre de Whiskers? Luna

Whiskers tiene 3 aÃ±os, mide 5 manos y sus padres son Tom y Luna.
```

<details><summary>ğŸ‘¨â€ğŸ« ExplicaciÃ³n</summary>

- Se define la estructura `Gato`, que almacena informaciÃ³n sobre un gato.  
- Se solicita la entrada del usuario para asignar valores a `nombre`, `edad`, `altura`, `padre` y `madre`.  
- Los datos ingresados se imprimen en pantalla al final del programa.  

</details>

